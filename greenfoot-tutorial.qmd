---
title: Tutorial do Greenfoot
subtitle: GAC125 - IPOO
---

# Sobre o Tutorial {background-color="#40666e"}

Este tutorial apresenta o Greenfoot, uma IDE baseada no BlueJ e usada para criação de jogos 
e simulações em Java.

##

Nós estamos usando o Greenfoot na aula porque 

- o trabalho da disciplina terá como tema a implementação de um jogo com gráficos em 2D, 
- desenvolvido em Java, com a IDE Greenfoot.

. . .

Em casa, você pode baixar e instalar o greenfoot acessando o site: [https://greenfoot.org/download]()

. . .

Este material se baseia no tutorial disponibilizado no site do Greenfoot: [https://www.greenfoot.org/doc/tut-1]()

- Mas ele foi estendido esse semestre, trazendo mais conteúdo.

# Parte 1: Interagindo com o Greenfoot {background-color="#40666e"}

## A interface do Greenfoot {.smaller}

Baixe o projeto [greenfoot-ursos](https://github.com/ufla-ipoo/greenfoot-ursos) e abra-o no Greenfoot.

. . .

A interface do Greenfoot tem três áreas principais.

- O **mundo**.
  - Na maior parte da tela aparece o mundo do jogo.
- As **classes**.
  - São exibidas em *caixas* no diagrama do lado direito.
- E os botões de **controle de execução**.
  - Botões abaixo do mundo que permitem controlar a execução do jogo.

## Colocando objetos no mundo {.smaller}

Clique com o botão direito na classe `Urso` e acesse a opção `new Urso()`.

- E então clique em qualquer lugar do mundo.
- Você acabou de criar um objeto `Urso`.

. . .

Faça o mesmo tipo de operação com as folhas, colocando algumas folhas no mundo.

. . .

**Dica**:

- Existe um atalho para colocar objetos no mundo.
- Selecione uma classe, e clique no mundo segurando a tecla `Shift` do teclado.

## Fazendo objetos agirem {.smaller}

Clique no botão **Executar uma vez** (obs.: no Greenfoot em inglês o botão se chama `Act`).

- Ao clicar no botão, cada objeto age.
- Ou seja, faz o que foi programado para fazer.

. . .

Neste exemplo, as folhas não fazem nada.

- E os ursos são programados para andar para frente.
- Experimente criar dois ursos e clicar de novo no botão **Executar uma vez**. 
  - Os dois ursos vão se mover.

. . .

Ursos também comem folhas.

- Experimente colocar uma folha na frente de um urso e clicar no botão **Executar uma vez**.

## Chamar métodos diretamente {.smaller}

Em vez de executar todo o cenário, você pode chamar métodos para cada objeto separadamente.

- Experimente clicar em um urso colocado no mundo.
- Você verá as opções de chamar os métodos, da mesma forma que vemos no BlueJ.

. . .

Experimente chamar o método `virarAEsquerda` para algum urso.

- E depois o método `mover`.

. . .

Repare que há um método chamado `act`.

- É este método que é chamado toda vez que clicamos no botão **Executar uma vez**.


## Criar um novo mundo {.smaller}

Você pode recomeçar tudo, criando um novo mundo.

- Para isso use o obtão **Reiniciar**.
- O objeto do mundo será descartado (junto com os objetos adicionados nele).
- E um novo mundo será criado.
  - Obs.: Só pode existir um mundo ativo por vez.

## Chamando um método do mundo {.smaller}

É possível também chamar métodos do mundo.

- Basta clicar em uma área vazia do mundo (sem ursos, nem folhas),
  - ou na área cinza ao redor do mundo.
- E serão exibidos os seus métodos.

. . .

Experimente chamar o método `povoar`.

- Este método cria vários ursos e folhas.
- Execute então o jogo.

. . .

Experimente agora o método `folhasAleatorias`.

- A quantidade de folhas pode ser passada por parâmetro.
- Obs.: às vezes pode parecer que não apareceram todas as folhas.
  - Mas é que pode acontecer de duas folhas acabarem caindo na mesma célula.

## {.smaller}

Bom, chega de ursos andando em círculos...

- Vamos agora para outro exemplo no qual faremos algo mais interessante: [programar]{.alert}!

# Parte 2: Movimento e controle pelo teclado {background-color="#40666e"}

Nesta parte veremos como criar movimento, e usar o teclado para controlar um ator (personagem).

## O cenário caranguejo {.smaller}

Baixe o projeto [greenfoot-caranguejo](https://github.com/ufla-ipoo/greenfoot-caranguejo) e abra-o no Greenfoot.

- Você verá um mundo de areia.

. . .

Crie um caranguejo e coloque-o no mundo.

- Clique então em **Executar**.
- Aconteceu alguma coisa?

## {.smaller}

O caranguejo não fez nada porque não tem nada programado para ele fazer.

- Vamos mudar isso!

. . .

Abra a classe Caranguejo (clicando duas vezes na caixa da classe).

- Veja que a classe tem um método `act` (agir) vazio, por isso o caranguejo não faz nada.
- Experimente colocar o comando `move(4)` dentro do método `act`.
  - Compile a classe, coloque um caranguejo no mundo e clique em executar.
  - Veja que o caranguejo se move para a direita até parar na borda do mundo.
  - Você pode até pausar o mundo e arrastar o caranguejo para que ele ande novamente.

## Só para os curiosos {.smaller}

Mas de onde veio esse método `move`? 

- E por que estamos chamando o método sem usar nenhum objeto?

. . .

Nós vamos entender isso melhor ao estudarmos o conceito de [Herança]{.alert}.

. . .

Mas, para os curiosos, vai aqui um *spoiler*:

- O método `move` (e outros que usaremos da mesma forma) está definido na classe `Actor`.
- A classe `Caranguejo` é uma subclasse de `Actor`.
  - Isso significa que ela herda os métodos da classe `Actor`.
  - E assim, podemos chamar os métodos da classe `Actor` dentro da classe `Caranguejo` como se eles estivessem definidos na própria classe `Caranguejo`.

## {.smaller}

Experimente agora colocar dois caranguejos e chamar o método **Executar**.

- Os dois caranguejos fazem a mesma coisa, pois são objetos da mesma classe.

. . .

Experimente passar valores diferentes para o método `move`.

- Você pode testar valores menores, maiores e até negativos.

. . .

O método `move` faz um ator se mover para frente pela quantidade passada.

- Um ator sempre começa "olhando" para a direita da tela.
- Portanto, a princípio, ele se move para a direita da tela.

## {.smaller}

Acrescente agora mais uma linha no método `act`, de forma que ele fique como mostrado abaixo:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    move(4);
    turn(3);
```
:::

. . .

Execute o jogo, com alguns caranguejos e veja o que acontece.

- Experimente passar valores diferentes para o método `turn`.
  - Mais uma vez, valores maiores, menores e até negativos.

. . .

Note que o método `turn` gira o ator pelo ângulo passado (em graus).

## Controle usando o teclado {.smaller}

Fica mais interessante se pudermos controlar o caranguejo.

- para isso, podemos usar o método estático `isKeyDown` da classe `Greenfoot`.

. . .

Por exemplo, podemos verificar se a tecla seta para a esquerda está pressionada assim:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    if (Greenfoot.isKeyDown("left")) {
        // implementamos aqui o que deve acontecer se a tecla seta para
        // a esquerda estiver pressionada
    }
```
:::

## {.smaller}

Experimente, por exemplo, implementar o método `act` conforme mostrado abaixo:

- Teste o jogo com um e com vários caranguejos.
- Use seta para a esquerda e seta para a direita para controlar os caranguejos.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    public void act() 
    {
        move(4);
        
        if (Greenfoot.isKeyDown("left")) {    
            turn(-3);   
        }
        if (Greenfoot.isKeyDown("right")) {    
            turn(3);   
        }
    }  
```
:::

## {.smaller}

Você pode alterar os valores passados para o método `turn` para mudar o quanto os caranguejos giram.

- E pode também alterar as teclas utilizadas para controlar o caranguejo.
- Você pode usar as letras ou caracteres para indicar as teclas (ex.: `"a"`).
  - Ou os nomes das teclas (ex.: `"space"` ou `"control"`). 

. . .

Para pensar:

- Como você pode tratar para que o jogo possa ser jogado tanto nas teclas de direção quanto usando as teclas `ASDW`?

## Opcional: controlando um carro {.smaller}

Em casa, tente criar uma classe `Carro` e controlar os carros da seguinte forma:

- Usando seta para cima para acelerar o carro.
- Seta para baixo dar ré no carro.
- Seta para a esquerda para virar o carro para a esquerda.
- Seta para a direita para virar o carro para a esquerda.

# Parte 3: Detectando e removendo atores {background-color="#40666e"}


Agora vamos descobrir como podemos detectar que um ator está tocando outro (detecção de colisão), e como remover aquele ator do mundo.

## Comendo larvas {.smaller}

Vamos criar uma classe para representar larvas que serão a comida dos caranguejos.

- Para isso clique com o botão direito na classe `Actor` e vá na opção `Nova subclasse...`.

. . .

Na janela que se abre dê o nome `Larva` para a classe (lembre-se de usar `L` maiúsculo).

- E escolha a imagem `larva.png` para representar as larvas.
- Ao clicar em OK, a classe `Larva` aparecerá no diagrama do Greenfoot.

. . .

Se abrir o código da classe verá que ela ainda não faz nada.

- Mas nós vamos deixar assim.
- As larvas desse jogo são preguiçosas e só ficam paradas mesmo.

## {.smaller}

A ideia agora é modificar a classe `Caranguejo` para que um caranguejo coma uma larva sempre que passar sobre ela.

. . .

Para fazer isso, vamos usar o método `getOneIntersectingObject`.

- Podemos acrescentar o seguinte trecho de código ao final do método `act`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    // se o caranguejo estiver colidindo (tocando) uma larva, a larva será
    // retornada. Se não estiver colidindo com nenhuma, o método retornará null.
    Actor larva = getOneIntersectingObject(Larva.class);
    // Se havia colisão com alguma larva
    if (larva != null) {
        // Obtemos uma referência (ponteiro) para o mundo
        World mundo = getWorld();
        // Removemos a larva do mundo
        mundo.removeObject(larva);
    }
```
:::

## {.smaller}

Altere o método `act` conforme mostrado no slide anterior.

- Coloque várias larvas e vários caranguejos no mundo.
- E testes as alterações. Conseguiu capturar todas as larvas?

## Coesão de método {.smaller}

Repare que nosso método `act` está ficando um pouco confuso.

- Isso porque ele agora faz duas coisas: movimenta o caranguejo e o faz comer larvas.

. . .

Como podemos melhorar isso?

- Podemos criar um método `movimentar` e outro `tentarComer`.
 - Levando para esses métodos os trechos de código que hoje estão no método `act`.
- O método `act` passaria então a ter apenas duas linhas:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    public void act() {
        movimentar();
        tentarComer();
    }
```
:::

## {.smaller}

Veja que, com a alteração que fizemos, o código fica mais fácil de entender e de se alterar.

- Mais adiante na disciplina aprofundaremos essa questão, ao estudarmos o conceito [coesão de métodos]{.alert}.

# Parte 4: Salvando o mundo e criando e tocando sons {background-color="#40666e"}

Vamos aprender agora a inicializar o mundo já contendo atores.

- E também a criar e tocar sons.

## Tamanho do mundo {.smaller}

A cada passo nosso jogo terá mais personagens.

- Pode ser interessante então criar um mundo de tamanho maior,
  aproveitando a resolução disponível na tela do computador.

. . .

Para alterar o tamanho do mundo, faça o seguinte:

- Localize o construtor da classe `MundoDoCaranguejo`.
- Altere os dois primeiros parâmetros da chamada `super`
  usando, por exemplo, 800 de largura e 600 de altura.
- Reinicie o jogo e teste.

. . .

Agora você tem mais espaço para projetar seu jogo 😉

## Salvando o mundo {.smaller}

Você deve ter ficado cansado de tanto colocar caranguejos e larvas no mundo.

- Mas nós podemos adicionar código para que isso seja feito automaticamente.
- Ou melhor ainda, pedir ao Greenfoot para fazer esse código para nós.

. . .

Para isso, faça o seguinte:

- Acrescente alguns caranguejos e algumas larvas no mundo.
- Antes de clicar em *Executar*, clique com o botão direito no mundo e acesse a opção **Salvar o mundo**.
  - O Greenfoot colocará trechos de código na classe do mundo.
  - Que criam e posicionam os atores nos mesmos lugares onde você tinha colocado.
  - Dê uma olhada no código!

. . .

Depois disso, toda vez que o mundo for criado, ele já terá os caranguejos e as larvas
como você os tinha posicionado ao salvar. 

## Tocando sons {.smaller}

É bem simples tocar sons no Greenfoot.

- Basta que você tenha um arquivo de som na pasta `sounds` do seu projeto.
- E use o método estático `playSound` da classe `Greenfoot` para tocar o arquivo.

. . .

O projeto caranguejo já tem um arquivo `comendo.wav` na pasta `sounds`.

- Experimente então acrescentar a linha de código abaixo na classe `Caranguejo`, logo após remover uma larva do mundo:
  - `Greenfoot.playSound("comendo.wav");`
- Teste o jogo!

## Criando sons {.smaller}

Para criar seu jogo, você pode procurar por trilha e efeitos sonoros livres e gratuitos na internet.

- Ou você pode criar seus próprios sons usando o Greenfoot mesmo.

. . .

Para criar um som, acesse o menu `Ferramentas` &rarr; `Mostrar gravador de som...`.

- Você pode gravar sons e ouvi-los.
- E, ao final, dar um nome para o arquivo e salvar.
  - Depois, basta usar esse nome de arquivo no código para tocá-lo.

## Criando sons {.smaller}

[Dica]{.alert}:

- Silêncios no início ou no final do som podem criar uma experiência desagradável para o jogador.
- Você pode evitar isso usando o botão `Cortar até a seleção`.
  - Você pode selecionar o trecho do áudio que tem a parte que você quer que fique no arquivo.
  - E usar o botão para cortar o áudio, ignorando o que tinha antes e depois da seleção.


# Parte 5: Adicionando inimigo com movimento aleatório {background-color="#40666e"}

O jogo está muito fácil! É hora de criarmos algum desafio.

## {.smaller}

Vamos criar uma lagosta que se move em linha reta e que pode comer caranguejos.

- Crie uma classe `Lagosta` clicando com o botão direito em `Actor` e depois em `Nova subclasse...`.
- Escolha a imagem da lagosta que já existe no projeto.
  - Obs.: quando você quiser usar uma imagem que não tem no Greenfoot, basta colocá-la na pasta `images` do projeto. 

. . .

Nas partes anteriores do tutorial já vimos como movimentar um ator e como remover um ator do mundo.

- Então você mesmo pode implementar a ação da lagosta.
- Ela deve se movimentar sempre para a direita e,
  - Se colidir com um caranguejo, o caranguejo deve ser removido do mundo.
  - Para ficar mais interessante, grave o seu próprio som e use-o quando isso acontecer.

## Aleatoriedade {.smaller}

Bom, o jogo ainda está muito fácil. Vamos deixá-lo menos previsível.

- A ideia é que as lagostas possam girar a cada hora por um ângulo diferente.
- Podemos fazer isso usando o método estático `getRandomNumber` da classe `Greenfoot`.
  - Exemplo: `int angulo = Greenfoot.getRandomNumber(90);`.
- E então usamos o ângulo como parâmetro do método `turn`.
  - Exemplo: `turn(angulo);`.
- Implemente e teste o jogo.

. . .

O que achou do resultado?

- A lagosta não é um oponente desafiador ainda, certo? :)

## {.smaller}

Um dos problemas é que a lagosta gira toda hora, com isso ela fica só rodopiando.

- Seria melhor se ela virasse apenas de vez em quando.
- Podemos implementar isso, fazendo com que o método `turn` não seja chamado toda hora que o `act` é executado.

. . .

Uma das formas de fazer isso é mostrada abaixo.

- Experimente implementar e ver a diferença no comportamento da lagosta.


::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    move(4);
    if (Greenfoot.getRandomNumber(100) < 10) {
        int angulo = Greenfoot.getRandomNumber(90);
        turn(angulo);
    }
```
:::

## {.smaller}

Mas o que exatamente foi feito?

- Veja que o comando `Greenfoot.getRandomNumber(100)` retorna um número aleatório entre 0 a 99.
- Se esse método for chamado muitas vezes ele vai retornar cada numéro possível a mesma quantidade de vezes (em média).
  - Portanto, em média, ele retorna 0 em 1% das vezes, retorna 1 em 1% das vezes e assim por diante.
  - Logo, ele retorna um valor menor que 10 em 10% das vezes, certo?
- Com isso, a expressão do comando `if (Greenfoot.getRandomNumber(100) < 10)`, retornará `true`, em média, a cada 10 vezes que for chamado.
  - Isso faz com que cada lagosta se movimente de forma diferente, girando só de vez em quando. 

## {.smaller}

Repare que podemos deixar a lagosta ainda melhor fazendo com que ela possa girar para os dois lados.

- Como estamos passando sempre um número positivo, ela está girando sempre para o mesmo lado.
- Como podemos fazê-la girar para os dois lados?

. . .

Podemos mudar a forma que o ângulo é definido:

- Agora teremos valores variando entre:
  - 0 - 45 = -45 
  - e 89 - 45 = 44.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
        int angulo = Greenfoot.getRandomNumber(90) - 45;
```
:::

## {.smaller}

Faça as últimas alterações no seu código e coloque várias lagostas e larvas, e alguns caranguejos no mundo.

- Não esqueça de salvar o mundo!
- Jogue e veja como a lagosta é agora um inimigo bem mais desafiador.

. . .

Mas você deve ter reparado que a lagosta ainda não sabe lidar bem com as bordas do mundo.

- Como podemos melhorar isso?
- Basta acrescentarmos um código para que ela gire 180 graus sempre que chegar perto da borda do mundo.
  - Obs.: você pode chamar o método `isAtEdge` para verificar se um ator está na borda do mundo.

## Desafio (Opcional) {.smaller}

Como você poderia fazer um [jogo para dois jogadores]{.alert}?

- Imagine que um jogador utilize as setas do teclado e outro as teclas ASDW.
- Crie uma nova classe no jogo do caranguejo com um animal que possa ser controlado por um segundo jogador.
  - E faça os tratamentos necessários.

# Parte 6: Exibindo informações na tela {background-color="#40666e"}

Vamos aprender como exibir informações na tela do jogo.

- Com isso poderemos exibir pontuações, quantidade de vidas, mensagens para o jogador, etc.


## Exibindo um texto na tela {.smaller}

A classe `World` possui um método chamado `showText` que permite exibir um texto
em uma determinada posição da tela.

- O método recebe como parâmetros uma String e as coordenadas X e Y que definem
  o ponto central do texto.

. . .

Vamos começar então exibindo o texto `Jogo do Caranguejo` na tela.

- Para isso, altere a classe `MundoDoCaranguejo` acresentando a 
  linha abaixo no final do construtor da classe.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    showText("Jogo do Caranguejo", 200, 20);
```
:::

. . .

Veja que o texto apareceu na parte superior da tela.

- Experimente posições diferentes.

## Mensagem de vitória {.smaller}

Agora que sabemos como exibir um texto na tela, podemos exibir uma
mensagem quando o jogador vence jogo.

- No nosso jogo, a vitória acontece quando todas as larvas são devoradas.

. . .

Mas como saber se ainda existem larvas?

- A classe `World` possui um método chamado `getObjects` que permite
  consultar os objetos de uma determinada classe que estão presentes no mundo
  naquele momento.
- Portanto, se usarmos `getObjects(Larva.class)` vamos obter uma lista
  com as larvas que estão no mundo.
- Se a lista estiver vazia significa que jogador venceu o jogo.

. . .

Mas nós precisamos verificar a todo momento se as larvas já acabaram, certo?

- Como fazer isso?

## Mensagem de vitória {.smaller}

Podemos implementar um método `act` na classe `MundoDoCaranguejo` com a mesma
assinatura dos métodos das classes de atores.

- Esse método também é chamado a cada iteração do Greenfoot.
- Portanto, para tratar a mensagem de vitória, basta verificarmos 
  se ainda existe larva dentro desse método.

. . .

Nós vamos então implementar o método como mostrado abaixo.

- Mas, para ele compilar, precisaremos importar a classe `List`.
  - Podemos fazer isso acrescentado `import java.util.List;` no início do arquivo.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    public void act() {
        List<Larva> larvas = getObjects(Larva.class);
        if (larvas.size() == 0) {
            showText("Voce venceu!", 200, 300);
        }
    }
```
:::

## {.smaller}

A implementação que fizemos funciona, mas não é eficiente.

- Isso porque, depois que o jogador vence o jogo, a cada iteração do Greenfoot, 
  um novo texto `"Voce venceu!"` é colocado no lugar do anterior.
- Seria melhor se o texto fosse colocado apenas uma vez.

. . .

Como podemos fazer isso?

- Veja que podemos criar um atributo booleano para indicar se o jogo terminou.
- E usá-lo para escrever a mensagem apenas uma vez.

. . .

Altere então a classe `MundoDoCaranguejo` acrescentando um booleano chamado
`jogoTerminou`.

- O atributo deve ser inicializado com valor `false` no construtor.
- E o método `act` deve ser alterado para utilizá-lo.

## {.smaller}

Vamos então alterar o método `act` como mostrado abaixo.

- Veja que foi acrescentado um `if` para que a lista de larvas só
  seja verificada se o jogo ainda não terminou.
- Além disso, depois que o texto é mostrado, o booleano `jogoTerminou`
  é alterado para `true`.
- Com isso, o texto `"Voce venceu"` é inserido na tela uma única vez.  

::: {.halfincfontsize}
```{.java code-line-numbers="false" code-line-numbers="2,6"}
    public void act() {
        if (!jogoTerminou) {
            List<Larva> larvas = getObjects(Larva.class);
            if (larvas.size() == 0) {
                showText("Voce venceu!", 200, 300);
                jogoTerminou = true;
            }
        }
    }
```
:::

## Game Over! {.smaller}

Baseado no que fizemos para a mensagem de vitória, exiba a mensagem
`"Game Over!"` quando todos os caranguejos forem comidos pelas lagostas.

- Veja que basta seguirmos a mesma ideia, mas agora verificando se ainda existem caranguejos em vez de larvas.

. . .

```{.java code-line-numbers="false" code-line-numbers="9-14"}
    public void act() {
        if (!jogoTerminou) {
            // verificando vitoria
            List<Larva> larvas = getObjects(Larva.class);
            if (larvas.size() == 0) {
                showText("Voce venceu!", 200, 300);
                jogoTerminou = true;
            }
            // verificando derrota
            List<Caranguejo> caranguejos = getObjects(Caranguejo.class);
            if (caranguejos.size() == 0) {
                showText("GameOver!", 200, 300);
                jogoTerminou = true;
            }
        }
    }
```

# Parte 7: Tratando pontuação {background-color="#40666e"}

Agora que sabemos como exibir informações na tela, podemos fazer algo mais interessante.

- Podemos passar a contabilizar a pontuação do jogador e exibi-la na tela.

## Contabilizando pontos {.smaller}

Para contabilizar os pontos do jogador, precisaremos:

- Criar um atributo na classe `MundoDoCaranguejo` para guardar a pontuação.
- Criar um método para incrementar a pontuação.
- Chamar esse método toda vez que um caranguejo comer uma larva.
- E exibir a pontuação na tela, sempre que ela for alterada.

. . .

Altere então a classe `MundoDoCaranguejo` incluindo um atributo inteiro chamado `pontos`.

. . .

Em seguida, crie um método público chamado `contarPontos` que:

- acrescenta 10 unidades ao atributo `pontos`;
- e exibe na tela o placar atualizado, utilizando o método `showText`

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
showText("Placar: " + pontos + " pontos", 200, 50);
```
:::

## {.smaller}

A pontuação ainda não aparece, porque precisamos agora chamar o 
método `contarPontos` toda vez que o caranguejo comer uma larva.

Para isso, altere o método `act` da classe `Caranguejo`.

- Localize o trecho de código que remove a larva comida do jogo.
- Logo após a remoção da larva, chame do método `contarPontos` de `MundoDoCaranguejo`.
  - Para isso, precisaremos obter uma referência do mundo como uma instância 
    da classe `MundoDoCaranguejo`.
  - Isso pode ser feito como mostrado abaixo.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    MundoDoCaranguejo mundoCaranguejo = getWorldOfType(MundoDoCaranguejo.class);
    mundoCaranguejo.contarPontos();
```
:::

# Parte 8: Um inimigo que persegue as larvas {background-color="#40666e"}

Vamos dificultar um pouco mais a vida do jogador :)

## Criando aranhas comedoras de larvas {.smaller}

A ideia agora é criar aranhas que também comam larvas, e assim dificultem
a vida do jogador na obteção de uma boa pontuação.

- Num primeiro passo, vamos fazer uma versão simplificada da aranha. 
- Ela sempre andará para frente e comerá uma larva se der sorte de ter uma
no caminho dela.

. . .

Crie então uma classe `Aranha` de forma similar ao que fizemos antes.

- No método `act` da classe faça a aranha movimentar (com `move(2)`);
- e faça com que ela coma uma larva se tocar nela 
  - (com o mesmo código que usamos para os caranguejos).

. . .

Posicione uma ou mais aranhas à esquerda de algumas larvas e teste o jogo.

## Tornando as aranhas mais espertas {.smaller} 

Poderíamos deixar o jogo mais imprevisível se as aranhas se movimentassem
aleatoriamente como as lagotas.

- Mas podemos fazer algo ainda mais interessante:
  - Fazer com que as aranhas caminhem em direção às larvas de forma automática.

. . .

Nós podemos fazer isso usando o método `turnTowards`.

- Esse método vira um ator na direção das coordenadas passadas por parâmetro.
- Portanto, se passarmos as coordenadas de uma larva, a aranha se movimentará
  em direção a ela.

. . .

Nós precisamos então ter uma maneira de identificar uma larva que seja
o alvo da aranha.

## {.smaller}

Nosso primeiro passo será criar um método público na classe `MundoCaranguejo` 

- que retorna qualquer uma das larvas existentes do mundo (escolhendo aleatoriamente).

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    public Larva buscarUmaLarva() {
        List<Larva> larvas = getObjects(Larva.class);
        if (larvas.size() > 0) {
            int posicao = Greenfoot.getRandomNumber(larvas.size());        
            return larvas.get(posicao);
        }
        return null;
    }
```
:::

## {.smaller}

Nós podemos agora chamar o método que criamos na classe `Aranha` para 
definir qual larva ela vai perseguir.

- Por enquanto vamos apenas guardar qual é a larva-alvo.

. . .

Altere então a classe `Aranha` da seguinte forma:

- Crie um atributo do tipo `Larva` chamado `larvaAlvo`.
- Altere o método `act` para chamar o método `buscarUmaLarva` da classe
  `MundoDoCaranguejo`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    MundoDoCaranguejo mundoCaranguejo = getWorldOfType(MundoDoCaranguejo.class);
    larvaAlvo = mundoCaranguejo.buscarUmaLarva();
```
:::

. . .

Precisamos testar se o nosso método funciona, para isso faça o seguinte:

- Inicie o jogo e, em seguida, clique em `Pausar`.
- Clique com o botão direito em uma aranha e acesse a opção `Inspecionar`.
- Verifique o valor do atributo `larvaAlvo` clicando na seta.
  - Deve aparecer então as coordenadas da larva que foi definida como alvo.

## {.smaller}

Nosso próximo passo é então fazer com que a aranha se vire na direção
da larva alvo.

- Parece que basta acrescentar o trecho de código abaixo ao final do método `act`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false" code-line-numbers="5-6"}
    public void act()
    {
        move(2);
        tentarComer();
        if (larvaAlvo != null) {
            turnTowards(larvaAlvo.getX(), larvaAlvo.getY());
        }
    }
```
:::

. . .

Funcionou?

- Não né? O problema é que estamos escolhendo uma nova larva-alvo a cada iteração do Greenfoot.
  - Com isso a aranha fica girando sem sentido.
- Como podemos resolver?


## {.smaller}

O que precisamos é manter o alvo e só mudar quando a larva for devorada

- seja pela aranha, seja pelos caranguejos.

. . .

Podemos fazer isso com a seguite implementação no método `act`

```{.java code-line-numbers="false"}
    public void act()
    {
        move(2);
        tentarComer();

        // se já tem uma larva definida como alvo
        if (larvaAlvo != null) {
            // e ela ainda não foi devorada
            if (larvaAlvo.getWorld() != null) {
                // a aranha se vira na direção dela
                turnTowards(larvaAlvo.getX(), larvaAlvo.getY());
            }
            else { // se a larva já foi devorada
                // reinicializamos o atributo para definir um novo alvo
                larvaAlvo = null;
            }
        }
        // se NÃO tem uma larva definida com o alvo
        if (larvaAlvo == null) {
            // definimos uma obtendo-a do mundo
            MundoDoCaranguejo mundoCaranguejo = getWorldOfType(MundoDoCaranguejo.class);
            larvaAlvo = mundoCaranguejo.buscarUmaLarva();
        }
    }
```

# Parte 9: Documentação do Greenfoot {background-color="#40666e"}

## {.smaller}

Para desenvolver jogos no Greenfoot é importanter ter uma ideia do que ele é capaz de fazer.

- Uma boa maneira de fazer isso é consultando a sua documentação.

. . .

Você pode acessar a documentação do Greenfoot através do menu:

- `Ajuda` &rarr; `Documentação de Classe Greenfoot`.

. . .

Será exibida a documentação em HTML das classes disponíveis do Greenfoot.

- Como `Actor`, `Font`, `Greenfoot`, `GreenfootImage` e `World`.
- Você pode clicar em uma classe e verificar os métodos que estão disponíveis.

. . .

Você também podem acessar diretamente a documentação das classes `Actor` e `World` clicando
nas caixas com esses nomes no painel direito do Greenfoot.

# Entrega {background-color="#40666e"}

## 

::: {.callout-important title="Entrega no Campus Virtual"}
Acesse, no Campus Virtual, a atividade correspondente a essa aula e envie o código do projeto `greenfoot-caranguejo` da forma que ficou após as suas alterações (compacte a pasta do projeto em um arquivo `.zip` para enviar).
:::


