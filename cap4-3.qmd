---
title: IPOO - Cap. 4 Agrupando Objetos
subtitle: Aula 4.3 - Teórica
---

## {.smaller}

Este material é baseado no livro-texto da disciplina:

![](imagens/livro_bluej.png).

. . .

Dessa vez não vou colocar os lembretes antes de começar a aula.

- A essa altura você já sabe né? Não preciso repetir.

# Buscando em uma coleção {background-color="#40666e"}

## {.smaller}

Na aula anterior nós aprendemos sobre o loop **for-each** que é usado para **processar uma coleção inteira**.

- Mas há situações na quais queremos percorrer uma coleção, mas sem necessariamente precisar passar por todos os elementos dela.
- É o que chamamos de **interação indefinida**.

. . .

Suponha, por exemplo, que queremos encontrar a primeira música que tenha uma determinada string.

- Nesses casos, o loop *for-each* não é a melhor opção, pois ele é projetado para iterar por todos os elemento da coleção.
  - Mas, ao encontrarmos a primeira música, não precisaríamos percorrer o restante da coleção.
- Nós podemos então utilizar outro tipo de loop, com o comando `while`.

## O loop `while` {.smaller}

Antes de entrarmos no exemplo da busca da primeira música, vamos detalhar um pouco mais o [comando `while`]{.alert}.

- A **sintaxe** do `while` em Java é **igual à do C++** que vocês viram na disciplina IALG.

## O loop `while` {.smaller}

Como exemplo, os trechos de código abaixo fazem a mesma coisa, mas um usando **for-each** e outro `while`.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  public void listarTodosOsArquivos() {
      for(String nomeDoArquivo : arquivos) {
          System.out.println(nomeDoArquivo);  
      }
  }
```
:::

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  public void listarTodosOsArquivos() {
      int indice = 0;
      while (indice < arquivos.size()) {
          String nomeDoArquivo = arquivos.get(indice);
          System.out.println(nomeDoArquivo);
          indice++;
      }
  }
```
::: 

## O loop `while` {.smaller .autoanimate}

Repare que, **neste caso**, como estamos processando a coleção inteira, a opção **com *for-each* é melhor**:

- Primeiro porque o código é mais simples de implementar.
- Segundo porque não corremos o risco de cometer algum erro e provocar um loop infinito.
- Além disso, o código do *for-each* é o mesmo para diversas coleções diferentes.
  - Há coleções nas quais o acesso não é por índice ou não é com um método chamado `get`, por exemplo.

## O loop `while` {.smaller}

Assim, você pode estar se perguntando, mas então para que usar o comando `while`?

- Primeiro, porque podemos usar `while` para outras situações, que não sejam percorrer uma coleção.
- E, no caso de coleções, porque podemos precisar parar as iterações antes de processar a coleção inteira.
- Por fim, pode ser que precisemos do índice do elemento na coleção.

## O loop `while` {.smaller}

O código abaixo, por exemplo, exibe o índice das músicas

- o que pode ajudar na hora de chamar os métodos de tocar ou remover uma música.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public void listarTodosOsArquivos() {
    int indice = 0;
    while (indice < arquivos.size()) {
        String nomeDoArquivo = arquivos.get(indice);
        // inclui o índice da música na impressão
        System.out.println(indice + ": " + nomeDoArquivo); 
        indice++;
    }
}
```
::: 

## Exemplo de busca com `while` {.smaller}

Na aula passada, vimos o método `buscarMusicas` que listava os nomes de todas as músicas que tinham uma string de busca.

- Mas suponha que queiramos um método para encontrar a primeira música que tenha a string.
- Este é um exemplo de situação na qual podemos interromper a interação sem precisar processar a coleção inteira.
  - *Obs.: apesar de existir uma forma de parar a iteração de um _for-each_ ela é considerada um estilo ruim de programação.*

## Exemplo de busca com `while` {.smaller}

```{.java code-line-numbers="false"}
/**
 * Busca o índice da primeira música que bate com a string passada.
 * @param stringDeBusca A string a ser procurada.
 * @return O índice da primeira ocorrência, ou -1 se nenhuma música tem a string passada.
 */
public int buscarPrimeiraMusica(String stringDeBusca)
{
    int indice = 0;
    // Indica se a primeira música foi encontrada
    boolean encontrou = false;
    // A busca continua enquanto a coleção não terminar e nenhuma música foi encontrada
    while (indice < arquivos.size() && !encontrou) {
        String nomeDoArquivo = arquivos.get(indice);
        if (nomeDoArquivo.contains(stringDeBusca)) {
            // Uma música foi encontrada, podemos parar a busca
            encontrou = true;
        }
        else {
            // Não encontramos a música ainda, podemos continuar a busca
            indice++;
        }
    }
    if (encontrou) {
        // Retorna a posição onde a música foi encontrada
        return indice;
    }
    else {
        // Não encontramos nenhuma música
        return -1;
    }
}
```

# Melhorando a estrutura: a classe `Musica` {background-color="#40666e"}

## {.smaller}

Como vimos no final da aula passada, **usar String para representar as músicas não é o ideal**.

- Qualquer tocador de música comercial permite, por exemplo, buscar por título, artista, álbum, gênero, etc.
  - Além de ter informações adicionais como a duração da música, por ex..

. . .

Um dos poderes da Orientação a Objetos é justamente permitir que **entidades do mundo real possam ser representadas como objetos** em nossos programas.

- Como já sabemos como criar classes, com construtores, atributos e métodos, podemos **criar uma classe `Musica`** que represente as músicas.

## {.smaller}

Mas repare que, se quisermos ter todos os atributos mencionados para cada música (artista, título, gênero, álbum, etc.), 

- precisaríamos pedir ao usuário para fornecer todas essas informações.

. . .

Para evitar esse trabalho, vamos ilustrar essa questão com um **exemplo bem simples**.

- Vamos aproveitar o fato de que os arquivos de música fornecidos têm o nome do artista e da música no nome,
  - e usar uma classe auxiliar, chamada `LeitorDeMusica`,
  - que vai procurar todas as músicas .mp3 que estão em uma pasta, e usar os nomes dos arquivos para criar objetos da classe `Musica`.

## {.smaller}

O projeto [organizador-musicas-v5](https://github.com/ufla-ipoo/organizador-musicas-v5) tem a implementação proposta, com a classe `Musica`.

- Obs.: não vamos avaliar a classe `LeitorDeMusica` pois ela usa conceitos que ainda não vimos.

. . .

**Leia o código da classe `OrganizadorDeMusica`**. 

- Quais são as principais alterações?

## {.smaller}

Você deve ter notado que as principais alterações são:

- A classe `OrganizadorDeMusicas` tem agora um `ArrayList` de `Musica`s em vez de um `ArrayList` de Strings.
  - Isso afeta diversos métodos que tínhamos implementado.
- No método `listarTodasAsMusicas`, pedimos ao objeto `Musica` que retorna uma String contendo seus detalhes.
  - Isso indica que estamos deixando a classe `Musica` responsável por fornecer os detalhes a serem exibidos, como o título e o artista.
  - Este é um exemplo de **design baseado em responsabilidade** que veremos em mais detalhes no Cap. 7.
- No método `tocarMusica`, precisamos agora obter o nome do arquivo do objeto `Musica` para passá-lo para o tocador.
- Foram adicionados também códigos para buscar todas as músicas que estão na pasta principal do projeto.

## {.smaller}

Repare que ao utilizarmos a classe `Musica` alguns métodos ficaram um pouco mais complicados.

- Mas a estrutura do programa é agora muito melhor.
- A classe `Musica` é mais bem estruturada que uma simples String 
  - e ainda nos permite guardar informações mais interessantes, como, por exemplo, uma imagem do artista ou do álbum de música, por exemplo.

. . .

Além disso, agora conseguimos evitar o problema mencionado no final da aula anterior,

- De querermos buscar todas as músicas que tenham a palavra `renda` no título, mas isso acabar retornando músicas de uma cantora chamada `Brenda`.

## {.smaller}

No método abaixo resolvemos essa questão usando o fato de que a classe `Musica` tem a informação do título separada do nome do arquivo.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
/**
 * Lista todas as músicas que tenham uma string passada em seu título
 * @param stringDeBusca A string a ser procurada.
 */
public void buscarNoTitulo(String stringDeBusca)
{
    for (Musica musica : musicas) {
        String titulo = musica.obterTitulo();
        if (titulo.contains(stringDeBusca)) {
            System.out.println(musica.obterDetalhes());
        }
    }
}
```
:::

## 

::: {.callout-note title="Exercício [(entrega)]{.alert}" icon=false}
Adicione um atributo `numeroDeExecucoes` à classe `Musica`.
Implemente métodos para reiniciar a contagem (voltando para zero) e para incrementá-la em um.
Altere também o método `obterDetalhes` para que inclua essa informação.

Em seguida, altere a classe `OrganizadorDeMusicas` de forma que toda vez que uma música for tocada, seja contabilizada mais uma execução dela.
:::

::: {.callout-note title="Exercício [(entrega)]{.alert}" icon=false}
Você deve ter notado que se você tocar duas músicas sem parar a primeira, elas ficam tocando simultaneamente.
E, claro, isso não é muito útil.
Implemente as alterações necessárias para que uma música pare de tocar automaticamente quando uma outra música começa a tocar.
:::

# O tipo `Iterator` {background-color="#40666e"}

## {.smaller}

Existe uma **terceira forma de iterar sobre uma coleção** que é uma espécie de um meio-termo entre **for-each** e `while`.

- Ela usa um loop `while`, mas com um [objeto iterador]{.alert} em vez de uma variável inteira índice para guardar a posição na lista.
- A seguir usaremos `Iterator`, uma classe, e `iterator` um método. Repare a diferença pela letra `i` maiúscula e minúscula, respectivamente.

. . .

A classe `ArrayList` tem um método `iterator` que retorna um objeto `Iterator`.

- Para usar a classe, precisamos importá-la do pacote `java.util`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
import java.util.ArrayList;
import java.util.Iterator;
```
:::

## {.smaller}

Um iterador tem apenas quatro métodos, e usamos dois deles para iterar sobre uma coleção.

- O **método `hasNext`** (*temProximo*) indica se há mais elementos na coleção.
- E **o método `next`** (*proximo*) retorna o próximo elemento.

. . .

O pseudocódigo abaixo mostra como geralmente utilizamos iteradores para percorrer uma coleção

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  // Obtemos o iterador da coleção
  // - Como Iterator é uma classe genérica, precisamos informar um segundo tipo 
  //   (que é o tipo dos elementos da coleção)
  Iterator<TipoDoElemento> it = minhaColecao.iterator();
  // Enquanto há elementos a processar
  while (it.hasNext()) {      
      // Chamamos it.next() para obter o próximo elemento
      // Fazemos alguma coisa com o elemento
  }
```
:::

## {.smaller}

Podemos fazer então uma terceira versão do método que lista todas as músicas, agora usando um `Iterator`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  public void listarTodasAsMusicas() {
      Iterator<Musica> it = musicas.iterator();
      while (it.hasNext()) {
          Musica musica = it.next();
          System.out.println(musica.obterDetalhes());
      }
  }
```
::: 

. . .

Quais são as diferenças para as versões anteriores do método `listarTodosOsArquivos`?

- Nós usamos um loop `while`, mas não precisamos nos preocupar com uma variável de índice.
- Repare que o principal ponto a entender é que o método `next`, além de retornar o próximo elemento, passa o iterador para frente.
- Portanto, chamadas sucessivas do método `next` retornam sempre elementos diferentes.
  - Mas cuidado, se terminarem os elementos, e o método `next` for chamado sem antes verificar se `hasNext` retorna `true`, ocorrerá um erro no programa.

## {.smaller}

::: {.callout-tip title="Conceito" icon=false}
Um **iterador** é um objeto que permite iterar sobre todos os elementos de uma coleção.
:::

. . .

![](imagens/duvida-utilidade-iterator.png)

. . .

Realmente, o que fizemos até agora não traz vantagens. Mas há duas situações nas quais um `Iterator` é muito útil:

1. Para coleções cujo acesso por posição não é possível, ou muito lento.
2. Para a remoção de vários elementos de uma coleção.

## Acesso por índice vs. iteradores {.smaller}

Quando estamos usando um `ArrayList`, não faz nenhuma diferença utilizar `while` acessando por índice ou com iteradores.

- Mas nem toda coleção funciona assim.
- Veremos coleções mais adiante que não permitem acesso por posição.
  - Ou esse acesso seria muito lento.
  - E, portanto, seria inviável utilizar `while` acessando por índice.

. . .

A solução de **utilizar `while` com um `Iterator` funciona para todas as coleções da biblioteca** de classes do Java.

- E, portanto, é um **padrão de código** que usaremos novamente mais adiante.

# Removendo elementos de uma coleção {background-color="#40666e"}

## {.smaller}

Remover elementos traz consequências importantes quando estamos iterando uma coleção.

- Suponha, por exemplo, que não estamos mais interessados em um artista e queremos remover todas as suas músicas.
- Pode parecer bem simples implementar um método para isso, seguindo pseudocódigo abaixo.
  ```{.java code-line-numbers="false"}
  para cada música na colecao {
      se musica.obterArtista() é o artista que não queremos mais {
          colecao.remove(musica);
      }
  }
  ```

. . .

Apesar dessa forma parecer perfeitamente razoável, não é possível remover elementos usando um loop **for-each**.

- Se você tentar fazer isso, ocorrerá um erro no programa (`ConcurrentModificationException`).
- Isso ocorre porque a remoção causa uma confusão sobre qual seria o próximo elemento nesta situação.

## {.smaller}

A solução para usar isso é **usar um `Iterator` para remover elementos** de uma coleção.

- Além dos métodos `hasNext` e `next`, a classe tem um método `remove`.
- O método remove o elemento que foi retornado pela última chamada do método `next`.

. . .

O trecho de código abaixo mostra como remover as músicas de um artista da coleção de músicas.

- Repare que **chamamos o método `remove` do iterador e não do `ArrayList`**.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  Iterator<Musica> it = musicas.iterator();
  while (it.hasNext()) {
      Musica musica = it.next();
      String artista = musica.obterArtista();
      if (artista.equals(artistaARemover)) {
          it.remove();
      }
  }
```
:::

## {.smaller}

Há outras formas de remover elementos de uma coleção.

- Por ex.: fazer um loop para encontrar a posição de um elemento.
- E depois do loop remover o elemento daquela posição.

. . .

Mas veja que há desvantagens:

- Como já mencionamos, nem toda coleção permite acessar elementos por posição, ou esse acesso é lento.
- Além disso, com iterador podemos fazer a remoção já dentro do loop, sem precisar fazer uma operação separada.

. . .

Portanto, é uma boa ideia saber como remover elementos de uma coleção usando um objeto `Iterator`. :)

##

::: {.callout-note title="Exercício [(entrega)]{.alert}" icon=false}
Implemente um método na classe `OrganizadorDeMusicas` que receba uma string por parâmetro e remova todas as músicas cujos títulos tenham aquela string.
:::


# Coleções de tamanho fixo {background-color="#40666e"}

## {.smaller}

Apesar de coleções de tamanho flexível serem úteis na maioria dos casos,

- Há situações nas quais sabemos quantos elementos uma coleção terá durante todo o tempo de execução de um programa.
- Nesses casos, é melhor utilizar uma **coleção de tamanho fixo**: [um vetor]{.alert} (ou *array*).

. . .

Mas qual a **vantagem de usarmos vetores**?

- É que o acesso por índice (posição) é geralmente mais eficiente do que em uma coleção de tamanho flexível, como a `ArrayList`.
- Outra vantagem é que, em Java, podemos ter vetores de elementos que são tipos primitivos.
  - Enquanto `ArrayList`, por exemplo, permite guardar apenas objetos.
  - Apesar de que, como veremos no próximo capítulo, há uma forma de lidarmos comn isso usando *wrappers* (classes empacotadoras).

## {.smaller}

Um **vetor** é um grupo de variáveis que contém **elementos de um mesmo tipo**.

- Em Java, vetores são considerados objetos, portanto, são considerados tipos por referência.
- Como já mencionado, os elementos de um vetor podem ser de tipos primitivos (`int`, `double`, `boolean`, etc.) ou de tipos por referência (objetos).

. . .

Exemplo de um vetor:

![](imagens/exemplo_vetor.png)

## {.smaller}

Podemos **declarar um vetor** em Java, utilizando uma das seguintes formas:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
TipoDosElementos[] nomeDoVetor;
TipoDosElementos nomeDoVetor[];
```
:::

. . .

Exemplos:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
double[] notas;
int meuVetorDeInteiros[];
```
:::

## {.smaller}

Como os demais objetos, os **vetores são criados** por meio da palavra-chave `new`:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
nomeDoVetor = new TipoDosElementos[capacidade];
```
:::

. . .

Exemplos:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
double[] notas;
notas = new double[3];

int meuVetorDeInteiros[];
meuVetorDeInteiros = new int[10];
```
:::

## {.smaller}

Há ainda outras duas formas alternativas de se instanciar um vetor.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
// Declara e instancia em uma única linha
int meuVetorDeInteiros[] = new int[10];

// Declara, instancia um vetor com 3 posições e já inicializa os seus valores
double notas[] = {7.5, 8.0, 9.0};
```
:::

. . .

Em C++ um vetor criado, mas não inicializado, pode conter lixo de memória.

- Mas em Java, vale a regra de inicialização igual a dos atributos.
  - **Vetor de tipos numéricos** tem todos os elementos **inicializados com zero**.
  - **Vetor de booleanos** tem todos os elementos **inicializados com `false`**.
  - **Vetor de objetos** tem todos os elementos **inicializados com `null`**.

## O loop `for` {.smaller}

Geralmente utilizamos um [loop `for`]{.alert} para percorrer os elementos de um vetor.

- A **sintaxe** do loop `for` em Java é **igual à do C++**.
- Usamos o atributo `length`, que é constante e público, e retorna o tamanho do vetor.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
for(int i = 0; i < vetor.length; i++) {
    // Usando vetor[i], estamos acessando a posição i do vetor.
	vetor[i] = i;
}
```
:::

## O loop `for` {.smaller}

Como podemos então exibir todos os elementos de um vetor de inteiros chamado `vet`?

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
for(int i = 0; i < vet.length; i++) {
	System.out.println(vet[i]);
}
```
:::

## Usando vetores em métodos {.smaller}

Podemos passar vetores como parâmetro de métodos. 

- A passagem é por referência, ou seja, estamos passando o ponteiro para o vetor.
- Portanto, se o método alterar o vetor, ele estará alterando o vetor original passado por parâmetro

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public void preencherVetor(int vet[]) {
	for (int i = 0; i < vet.length; i++) {
    	vet[i] = i;
	}
}
```
:::

## Usando vetores em métodos {.smaller}

Podemos também criar métodos que retornam vetores.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public int[] criarVetor() {
	int v[] = new int[10];
	return v;
}
```
:::

## Vetores de objetos {.smaller}

Nós podemos também criar vetores para guardar objetos.

- Suponha, por exemplo, que queiramos poder criar e trabalhar com vários objetos de uma classe `Carro`.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
// Estamos declarando um vetor de carros, com capacidade de
// guardar 10 objetos Carro
Carro[] carros = new Carro[10];

// Em cada posição do vetor, podemos colocar um objeto do tipo Carro.
carros[0] = new Carro("Gol");
carros[1] = new Carro("Onix");
```
:::

## Vetores de objetos {.smaller}

Nós podemos então acessar cada objeto `Carro` no vetor, a partir de sua posição.

. . .

::: {.halfincfontsize}
```{.java}
for(int i = 0; i < carros.length; i++) {
	if (carros[i] != null) {
        // Estamos exibindo nome do carro chamando o método obterNome
	    System.out.println(carros[i].obterNome());
    }
}
```
:::

. . .

Repare que a condição (`if`) da linha 2 é muito importante:

- pois caso alguma posição do vetor não tenha sido inicializada, seu valor é `null`.
- E poderia então ocorrer um erro (`NullPointerException`) ao tentar chamar o método `obterNome`.


## Usando for-each com vetores {.smaller}

Nós também podemos usar um **loop *for-each*** para percorrer os elementos de um vetor.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
for(Carro carro : carros) {
	if (carro != null) {
        // Estamos exibindo nome do carro chamando o método obterNome
	    System.out.println(carro.obterNome());
    }
}
```
:::

. . .

Este exemplo nos permite enfatizar uma das vantagens do loop *for-each*:

- Repare que esse código seria exatamente igual se a variável `carros` fosse um `ArrayList` em vez de um vetor.
- Já na opção anterior, usando loop for tradicional, os códigos seriam diferentes.
  - Primeiro porque consultamos o tamanho de um vetor usando o atributo `length` e de um `ArrayList` usando o método `size`.
  - E segundo que acessamos um elemento por posição em um vetor usando `[i]` e em um `ArrayList` usando `get(i)`.

## Vetores vs. ArrayList {.smaller}

Agora que conhecemos tanto **vetores** quanto `ArrayList`, qual deles devemos utilizar?

- É melhor usar `ArrayList` se o número de elementos pode ser alterado durante a execução do programa.
  - Ou se você não sabe, antes de criar a coleção, quantos elementos serão usados.
- Seria melhor usar um vetor quando o número de elementos é pré-determinado.
  - E a eficiência de acesso por posição é muito importante.

. . .

Na prática acabamos usando `ArrayList` em muitas situações mesmo quando temos uma quantidade fixa de elementos.

- Mas, de toda forma, precisamos saber utilizar vetores pois é comum precisarmos usar métodos de classes da biblioteca do Java (ou de terceiros) que trabalham com vetores.


# Entregas dessa Aula {background-color="#40666e"}

## {.smaller}

::: {.nonincremental}

Para ter **presença** nessa aula teórica ANP, demostrando que você estudou o conteúdo, você deve fazer a atividade abaixo.

::: {.callout-important title="Entregas no Campus Virtual"}
Responda às tarefas no Campus Virtual enviando o o seu projeto do `organizador-musicas-v5`,
contendo as alterações solicitadas nos exercícios ao longo dos slides.
:::

:::