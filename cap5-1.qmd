---
title: IPOO - Cap. 5 Comportamento Mais Sofisticado
subtitle: Aula 5.1 - Teórica
---

## {.smaller}

Os tópicos abaixo te lembram alguma coisa? :)

:::: {.columns}

::: {.column width="70%"}

- **Praticar enquanto estuda**.
- **Ler o capítulo do livro**.
- **Anotar conceitos dúvidas**.

:::

::: {.column width="30%"}
![](imagens/livro_bluej.png){fig-alt="Capa do livro do Barnes e Kolling." fig-align="left" width=50%}
:::

::::

## {.smaller}

## Principais Conceitos do Capítulo {.smaller}

::: {.nonincremental}
- Encapsulamento
- Atributos e métodos estáticos
- Constantes
- Uso de classes de biblioteca
- Documentação de classes
:::

. . .

Construções Java do capítulo

::: {.nonincremental}
- `String`, `Random`, `static`, `final`,  autoboxing, classes empacotadoras.
:::

## {.smaller}

No capítulo anterior conhecemos a classe `ArrayList` da biblioteca de classes do Java.

- Com ela, ficou mais fácil fazer programas para guardar uma quantidade qualquer de objetos.
- O que sem ela seria bem mais complicado.

. . .

Mas ela é apenas um exemplo da classe de biblioteca.

- Existem muitas que serão muito úteis em nossos softwares.
- E outras que, possivelmente, nunca usaremos.

. . .

Um bom programador Java precisa conseguir trabalhar com as classes da biblioteca.

- E saber quando utilizar cada uma.
- De forma a tornar a implementação de um programa mais fácil.

## {.smaller}

Muitas classes da biblioteca têm certas características comuns entre si.

- Especialmente as coleções, são classes que compartilham muitos atributos.
- E, usando a abstração, podemos tratar de classes de coleções de uma maneira mais geral.

. . .

Neste capítulo, vamos trabalhar com um sistema de Suporte Técnico.

- Começaremos com uma versão rudimentar.
- E ela será melhorado, incrementalmente, utilizando diferentes classes da biblioteca Java.
  - Obs.: parte do conteúdo será tratada como Material de Estudo Autônomo, como previsto no Plano de Ensino.

## {.smaller}

# Documentação das classes de biblioteca {background-color="#40666e"}

## {.smaller}

A biblioteca de classes do Java tem centenas de classes, com muitas opções de métodos.

- Será que um bom programador precisa conhecer todas elas de cor?

. . .

Na verdade, um bom programador deveria:

- Conhecer pelo nome as classes mais importantes e seus métodos (`ArrayList` é uma delas).
- Saber encontrar informações sobre outras classes e pesquisar seus detalhes (tais como métodos e parâmetros).

. . .

O livro da disciplina recomenda que um programador conheça a documentação do Java para essas classes.

- A documentação é formada por páginas HTML bem detalhadas sobre todas as classes da biblioteca.
- Mas para quem não é fluente em inglês, isso pode gerar uma barreira inicial.
  - Portanto, uma sugestão é usar também outras fontes para saber como usar as classes (como buscas no Google ou o ChatGPT).
- Mas, à medida que você fique mais experiente, saber usar a documentação pode ser muito útil.

## {.smaller}

Um ponto importante sobre o uso da classe `ArrayList` é que nós já a utilizamos sem nunca termos visto o código da classe.

- Nós não conferimos como ela foi implementada.
- E isso não foi necessário para utilizarmos suas funcionalidades.

. . .

Tudo o que precisamos saber é:

- O nome da classe.
- As assinaturas dos seus métodos (nomes, parâmetros e tipos de retorno).
- E o que exatamente esses métodos fazem.

## {.smaller}

A mesma coisa acontece em projetos de software grandes de uma empresa.

- Geralmente, várias pessoas trabalham em diferentes partes do sistema.
- Cada programador deveria se concentrar em sua parte, e não ter que entender detalhes das outras partes.
  - Como discutimos ao falar sobre abstração e modularização.

. . .

Na verdade, cada programador deveria:

- Conseguir usar as classes das outras equipes como se elas fossem classes de biblioteca.
- Sabendo o que elas fazem, mas sem precisar saber como elas funcionam internamente.

. . .

Mas, para isso funcionar, cada membro de equipe deveria documentar sua classe assim como é feito para as classes da biblioteca

- Permitindo que outros programadores usem a classe sem precisar ler o código.
- Veremos como fazer isso nos materiais de estudo autônomo.

# O sistema de suporte técnico {background-color="#40666e"}

## {.smaller}

A ideia do sistema de Suporte Técnico é que ele seja um chat para atendimento de clientes

- de uma empresa fictícia, chamada *DesonestosSistemas*.

Antigamente a empresa tinha funcionários que faziam atendimento por telefone.

- Mas ela passou por problemas financeiros e demitiu a equipe.
- E agora ela quer criar um sistema de suporte para dar a impressão que ela atende os clientes.
- A ideia é que o sistema imite o atendimento que uma pessoa faria ao telefone.

## {.smaller}

Vamos começar com uma versão bem rudimentar do sistema, disponível no projeto [suporte-tecnico1](https://github.com/ufla-ipoo/suporte-tecnico1).

- A ideia é que, ao longo da aula, possamos melhorar o sistema.
- E, ao longo do processo, vamos aprender diversos conceitos.

##

::: {.callout-note title="Exercício" icon=false}
Experimente a versão rudimentar do sistema de suporte técnico.

Crie um objeto da classe `SistemaDeSuporte` e chame o método `iniciar`.
Experimente conversar com o sistema pelo terminal e repare como é atendido.
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Para conhecermos melhor o projeto, crie um objeto da classe `LeitorDeEntrada` e experimente seu(s) método(s).

Faça o mesmo com um objeto da classe `Respondedor`.
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Agora leia o código da classe `SistemaDeSuporte` e tente entender como ela funciona.
:::

## {.smaller}

Você deve ter notado que o sistema é realmente muito rudimentar.

- A classe `LeitorDeEntrada` basicamente retorna uma string digitada pelo usuário no terminal.
- A classe `Respondedor` tem um método que sempre retorna a mesma resposta.
- Já a classe `SistemaDeSuporte` tem um objeto de cada uma das duas classes anteriores.
  - E um loop `while` que, repetidamente, obtém um texto do usuário e exibe uma resposta.
  - Isso é repetido até que o usuário digite qualquer string que comece com `tchau`.


# Lendo documentação de classes {background-color="#40666e"}

## {.smaller}

Experimente usar o sistema de suporte técnico e digitar `"Tchau"` ou `" tchau"` (com espaço) para sair.

- O que acontece?
- Para o usuário isso é muito chato, certo?
  - Mas nós podemos usar a documentação da classe String para melhorar isso.

. . .

A classe String é uma das classes da biblioteca padrão do Java.

- Nós podemos acessar a documentação da classe, no BlueJ, no menu `Ajuda` --> `Biblioteca de classes do Java`.
- Será aberta a documentação online do Java no seu navegador web.
  - Na parte superior direita há uma caixa de busca.
  - Digite string e escolha primeira opção (`java.lang.String`).    

##

::: {.callout-note title="Exercício" icon=false}
Abra a documentação de alguma outra classe do Java e compare a estrutura da documentação das duas classes.
O que as páginas têm em comum?
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Procure pelo método `startsWith` na documentação da classe `String`.
Veja que o método é sobrecarregado, há duas versões.

Escreva com suas palavras o que as duas versões fazem e a diferença entre eles.
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Há algum método na classe String que retorna quantos caracteres ela tem?
Como o método se chama e quais são seus parâmetros?
:::

##

::: {.callout-note title="Exercício" icon=false}
Procure se existe algum método na classe String que verifica se uma string termina com um dado sufixo.
Se existir, como o método se chama, e quais são seus parâmetros e tipo de retorno?
:::

## Interface vs. Implementação {.smaller}

Você deve ter notado que a documentação tem diferentes tipos de informação:

- o nome da classe;
- uma descrição geral do objetivo da classe;
- uma lista dos construtores e métodos da classe;
- os parâmetros e tipos de retorno de cada construtor e cada método;
- e uma descrição do objetivo de cada construtor e cada método.

. . .

Todas essas informações formam o que chamamos de [interface de uma classe]{.alert}.

- Repare que que a interface **não** mostra o código que implementa a classe.
- Se uma classe é bem descrita (ou seja, sua interface é bem escrita),
  - um programador não precisa ver o código da classe para conseguir utilizá-la.
- A interface já tem toda a informação que ele precisa.
  - (olha a **abstração** aí de novo!)

## {.smaller}

O código que não vemos, que é o que faz a classe funcionar, é chamado de [implementação da classe]{.alert}.

- Geralmente um programador trabalha na implementação de uma classe de cada vez,
  - e, para isso, usa várias outras classes através de suas interfaces.

. . .

Essa diferenciação entre **interface** e **implementação** é um conceito muito importante.

- E vamos ver isso repetidamente nessa disciplina (e em disciplinas avançadas de POO).

. . .

::: {.callout-note title="Nota" appearance="simple" icon=false}
A palavra **interface** tem diferentes significados em POO.
Pode se referir a parte pública visível de uma classe (que é o que acabamos de aprender).
Mas pode também se referir a interface gráfica de usuário ou a um tipo especial de classe que você conhecerá se puxar PPOO como eletiva :)
:::

## {.smaller}

Nós também podemos falar de interface de um método específico.

- Veja, por exemplo, a documentação do método `length` da classe `String`.

. . .

![](imagens/java-doc-String-length.png)


## {.smaller}

![](imagens/java-doc-String-length.png)

A interface de um método consiste em sua **assinatura** e um comentário. 

. . .

E a assinatura de um método contém:

- Um modificador de acesso (`public`, nesse caso).
- O tipo de retorno do método (`int`, nesse caso).
- O nome do método.
- Uma lista de parâmetros (vazia, nesse caso).

. . .

Repare que a interface do método tem tudo que precisamos saber para conseguirmos usá-lo. 

##

::: {.callout-tip title="Conceito" icon=false}
A **interface** de uma classe descreve o que a classe faz e como ela pode ser usada sem mostrar a implementação.
:::

::: {.callout-tip title="Conceito" icon=false}
O código-fonte completo que define uma classe é chamado de **implementação** da classe.
:::

## Usando métodos de classes da biblioteca {.smaller}

Em nosso sistema de suporte, já vimos que o sistema não aceita que o usuário digite `"Tchau"` ou `" tchau"`.

- Vamos melhorar isso de forma que todas essas variações sejam reconhecidas como `"tchau"`.

. . .

::: {.callout-note title="Exercício" icon=false}
Encontre o método `trim` na documentação da classe `String`.
Escreva com suas palavras o que ele faz, e como ele poderia ser chamado usando uma variável `String` chamada `texto`.
:::

## {.smaller}

Um importante detalhe sobre objetos String em Java, é que eles são **imutáveis**.

- Isso significa que esses objetos não podem ser alterados depois de criados.
- Repare que o método `trim`, por exemplo, retorna uma nova String.
  - Ele não modifica a String original.

. . .

:::: {.columns}

::: {.column width="30%"}

![](imagens/fica_a_dica.png)

:::

::: {.column width="70%"}
É um erro comum em Java, tentar alterar uma String usando chamadas como:

  `texto.toUpperCase();`

Essa chamada não provoca nenhum erro, mas também não causa nenhum efeito.
Isso porque o método retorna uma nova String, ele não altera a original.

Portanto, se queremos alterar a variável `texto`, precisamos descartar o objeto String original, atribuindo à variável `texto` a nova String gerada:

  `texto = texto.toUpperCase();`
:::

::::

## {.smaller}

Pelo que você leu sobre o método `trim` na documentação, como podemos usá-lo no sistema de suporte?

- Você deve ter visto que podemos usá-lo para remover espaços no início e no final da string.

. . .

O código da classe `SistemaDeSuporte` poderia ser então alterado da seguinte forma:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    String entrada = leitor.obterEntrada();
    entrada = entrada.trim();
    if(entrada.startsWith("tchau")) {
        terminou = true;
    }
    else {
        String resposta = respondedor.generateResponse();
        System.out.println(resposta);
    }
```
:::

## {.smaller}

Você acha que haveria diferença entre escrever essas duas linhas de código:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    String entrada = leitor.obterEntrada();
    entrada = entrada.trim();
```
:::

ou escrever assim?

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    String entrada = leitor.obterEntrada().trim();
```
:::

. . .

O efeito é exatamente o mesmo.

- Você pode escolher a forma que acha mais fácil de entender.
- Veja que na segunda opção, a ordem de execução é como se existissem os parênteses como mostrado abaixo.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  String entrada = (leitor.obterEntrada()).trim();
```
:::


## 

::: {.callout-tip title="Conceito" icon=false}
Um objeto é chamado **imutável** se seu conteúdo ou estado não pode ser alterado depois que ele foi criado. Strings são exemplos de objetos imutáveis.
:::

::: {.callout-note title="Exercício" icon=false}
Implemente a alteração usando o método `trim` da classe String.
Teste a alteração digitando espaço antes da palavra tchau.
:::

## {.smaller} 


::: {.callout-note title="Exercício" icon=false}
O exercício anterior ainda não resolveu o problema do usuário digitar `"Tchau"` com letra maiúscula.

Veja na documentação da classe String como funciona o método `toLowerCase` e o utilize de forma que o programa saia independente do usuário digitar tchau com letras maiúsculas ou minúsculas.
:::

::: {.callout-note title="Exercício" icon=false}
Encontre o método `equals` na documentação da classe String.
Utilize o método `equals` em vez do método `startsWith` na implementação da classe `SuporteTecnico`
:::

::: {.nonincremental}

:::: {.columns}

::: {.column width="30%"}

![](imagens/fica_a_dica.png)

:::

::: {.column width="70%"}
Lembre-se que, como já foi dito em aulas práticas anteriores, não podemos comparar objetos String em Java utilizando o operador `==`.

- Usando o operador estamos verificando se é o mesmo objeto, e não se os dois objetos têm o mesmo conteúdo.
- Para comparar se dois objetos String têm o mesmo conteúdo, devemos utilizar o método `equals`.
:::

::::

:::


# Adicionando comportamento aleatório {background-color="#40666e"}

## {.smaller}

No início da disciplina, nós utilizamos um objeto da classe `Random` no exercício da Nave para acrescentar aleatoriedade em nosso jogo.

- Nós podemos agora utilizar a mesma classe para mudar o comportamento do `Respondedor` do nosso sistema de suporte.
- A ideia é que o sistema exiba respostas aleatórias, em vez de sempre responder a mesma coisa.

. . .

Nós podemos fazer isso, alterando a classe `Respondedor` seguindo os passos abaixo:

- declarando um atributo do tipo `Random` para guardar um gerador de números aleatórios;
- declarando um atributo do tipo `ArrayList` para guardar nossas possíveis respostas;
- criando os objetos `Random` e `ArrayList` no construtor da classe `Respondedor`;
- preenchendo a lista com algumas frases de resposta;
- selecionando e retornando uma frase aleatória quando o método `gerarResposta` é chamado.

##

::: {.callout-note title="Exercício" icon=false}
Melhore a classe `Respondedor` de forma que ela gere respostas aleatórias como descrito no slide anterior.

Veja que, para gerar respostas aleatórias, basta sortearmos uma posição do `ArrayList` e usarmos essa posição para obter uma mensagem.
Podemos sortear uma posição usando o método `nextInt` da classe `Random`, e o método `size` da classe `ArrayList`.

::: {.nonincremental}
Dicas:

- Veja no próximo slide alguns exemplos de frase de resposta (mas não precisam ser exatamente essas, use sua criatividade!).
- Reveja o uso da classe `Random` no exercício da nave.
- Leia a    seção 5.4 do livro da disciplina.
:::
:::

## {.smaller}

Exemplos de frases de resposta do sistema de suporte técnico:

::: {.halfincfontsize}
```
Isso parece estranho. Você poderia descrever com mais detalhes?
Nenhum outro cliente reclamou disso antes. Qual é a configuração do seu sistema?
Poderia me dar mais informações sobre o problema?
Isso é abordado no manual. Você já leu o manual?
Sua descrição é um pouco ruim. Você tem um especialista com você que poderia descrever isso melhor?
Isso não é um bug, é uma funcionalidade!
Você poderia detalhar melhor isso?
Você já tentou executar o aplicativo no seu telefone?
Já verifiquei no StatckOverflow e ChatGPT e nem eles sabem como responder :(
```
:::

# Melhorando o sistema de suporte {background-color="#40666e"}

## {.smaller}

Nosso sistema ficou mais dinâmico, mas ainda é muito ruim, pois as respostas são independentes do que o usuário escreve.

- Nós podemos melhorar um pouco isso, fazendo algo pelo menos próximo do que o usuário perguntou.
- O livro apresenta uma solução usando a classe `HashMap`.
  - Mas vamos tratar essa classe como material de Estudo Autônomo.
  - Então vamos implementar aqui primeiro uma solução com blocos `if` e `else` para ter um resultado similar.

. . .

A ideia é identificar alguma palavra-chave na pergunta feita pelo usuário.

- e fornecer uma resposta que tenha algo a ver com essa palavra-chave.

## {.smaller}

Por exemplo, suponha que na pergunta do usuário apareça a palavra `"lento"`.

- A resposta poderia ser então algo como:

. . .

::: {.halfincfontsize}
```
Acredito que isso tem a ver com o seu hardware. Atualizar seu processador deve resolver todos os problemas de desempenho. Você tem algum problema com nosso software?
```
:::

. . .

Já se na pergunta do usuário aparecer a palava `"bug"`, a resposta poderia ser:

. . .

::: {.halfincfontsize}
```
Bem, você sabe, todo software tem alguns bugs. Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. Você pode descrever o problema com mais detalhes?
```
:::

. . .

Como podemos implementar isso?

## {.smaller}

**Atenção**:

- O próximo exercício pede para alterar o método `gerarResposta` da classe `Respondedor`.
- Mas para que o professor consiga corrigir seu exercício anterior (de respostas aleatórias) você não pode apagar o código que tinha feito antes.
  - Então coloque o código que você tinha feito em um método chamado `gerarRespostaAleatoria`.

##

::: {.callout-note title="Exercício" icon=false}
::: {.nonincremental}
Vamos implementar a ideia discutida nos slides anteriores.  Neste exercício, faça o seguinte:

- Altere o método `gerarResposta` da classe `Respondedor` para que ele receba por parâmetro a pergunta feita pelo usuário.
  - Você precisará, claro, alterar a chamada do método na classe `SistemaDeSuporte` para passar a entrada do usuário.
- No método `gerarResposta`, faça uma sequência de `if`/`else if` para verificar se as palavras-chave existem na pergunta do usuário.
  - Para isso, você pode usar o método `contains` da classe String.
  - E no bloco de cada `if`, retornar um texto correspondente àquela palavra-chave (veja sugestões no próximo slide).
  - Exemplo:

```{.java code-line-numbers="false"}
    if (entrada.contains("lento")) {
        return "Acredito que isso tem a ver com o seu hardware. " +
               "Atualizar seu processador deve resolver todos os " +
               "problemas de desempenho. Você tem algum problema " + 
               "com nosso software?"
    }
    else if (entrada.contains("bug")) {
        ...
``` 
:::
:::

## {.smaller}

::: {.fontsize70}

| Palavra-chave| Resposta                                                                                                           |
|--------------|--------------------------------------------------------------------------------------------------------------------|
| travou       | Bem, nunca trava em nosso sistema. Deve ter algo a ver com o seu sistema. Conte mais sobre sua configuração. |
| travando     | Bem, nunca trava em nosso sistema. Deve ter algo a ver com o seu sistema. Conte mais sobre sua configuração. |
| lento        | Acredito que isso tem a ver com o seu hardware. Atualizar seu processador deve resolver todos os problemas de desempenho. Você tem algum problema com nosso software? |
| desempenho   | O desempenho foi bastante adequado em todos os nossos testes. Você está executando outros processos em segundo plano? |
| bug          | Bem, você sabe, todo software tem alguns bugs. Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. Você pode descrever o problema com mais detalhes? |
| erro         | Bem, você sabe, todo software tem alguns bugs. Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. Você pode descrever o problema com mais detalhes? |
| windows      | Este é um bug conhecido relacionado ao sistema operacional Windows. Por favor, informe à Microsoft. Não há nada que possamos fazer a respeito. |
| mac          | Este é um bug conhecido relacionado ao sistema operacional Mac. Por favor, informe à Apple. Não há nada que possamos fazer a respeito. |
| caro         | O custo de nosso produto é bastante competitivo. Você deu uma olhada e realmente comparou nossos recursos? |
| instalação   | A instalação é realmente bastante simples. Temos muitos assistentes que fazem todo o trabalho para você. Você leu as instruções de instalação? |
| memória      | Se você ler atentamente os requisitos do sistema, verá que os requisitos de memória especificados são de 1,5 gigabyte. Você realmente deve atualizar sua memória. Mais alguma coisa que você gostaria de saber? |
| linux        | Levamos o suporte ao Linux muito a sério. Mas há alguns problemas. A maioria está relacionada a versões incompatíveis do glibc. Você pode ser um pouco mais preciso? |
| bluej        | Ah, o BlueJ, sim. Tentamos comprá-los há muito tempo, mas eles simplesmente não vendem... São pessoas teimosas. Não há nada que possamos fazer a respeito, desculpe. |

:::

# Estudo Autônomo: a classe `HashMap` {background-color="#40666e"}

## {.smaller}

Conforme descrito no Plano de Ensino da disciplina, esse semestre tem 15 semanas letivas

-  e, para completar as 17 semanas previstas de carga horária, parte dos conteúdos da disciplina é tratada como Estudo Autônomo.

. . .

Uma dessas partes é sobre a classe `HashMap`.

- Você pode estudar sobre isso nos slides disponibilizados no Campus Virtual.
- E na seção 5.6 do livro da disciplina.
  - E, se você estudar também as seções 5.7 a 5.9, fazendo os exercícios, você terminará com um Sistema de Suporte bem mais interessante.

. . .

**Atenção**: 

- Você pode estudar o conteúdo do Estudo Autônomo a qualquer momento.
- Mas é importante que seja antes do Capítulo 7, pois nele utilizaremos a classe `HashMap`.

# Autoboxing e classes empacotadoras {background-color="#40666e"}

## {.smaller}

Nós vimos que um `ArrayList` consegue guardar qualquer tipo de objeto.

- Mas como `int` não é um objeto, não é possível usar um `ArrayList` para guardar uma lista de números inteiros?

. . .

Isso é possível através das [classes empacotadoras (*wrapper classes*)]{.alert}.

- Cada tipo primitivo em Java tem uma classe empacotadora que representa o mesmo tipo,
  - Mas que é um objeto de verdade.
- A classe empacotadora para `int`, por exemplo, se chama `Integer`.

## {.smaller}

Nós poderíamos criar um objeto do tipo `Integer` explicitamente:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    int n = 10;
    Integer objetoInt = new Integer(n);
```
:::

. . .

E poderíamos então declarar um `ArrayList<Integer>` e guardar o `objetoInt`.

- Mas, na verdade, nós nunca fazemos isso, pois podemos guardar valores de tipo primitivo no `ArrayList`!
- Isso porque sempre que um valor de tipo primitivo é usado em um contexto que requer um tipo empacotador (*wrapper*),
  - o compilador converte o valor automaticamente    objeto empacotador correspondente.
  - Essa funcionalidade se chama [*autoboxing*]{.alert} (algo como, auto-empacotamento).

## {.smaller}

Portanto, na prática, podemos escrever códigos como os abaixo:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    private ArrayList<Integer> notas;
    ...
    public void guardarNotasNaLista(int nota) {
        notas.add(nota);
    }
```
:::

. . .

Repare que estamos guardando o valor da variável `nota`, do tipo `int`, em um `ArrayList<Integer>`.

## {.smaller}

Seguindo a mesma ideia, o compilador realiza o [unboxing]{.alert} quando obtemos um valor da coleção:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    int primeiraNota = notas.get(0);
```
:::

. . .

Veja portanto que, em termos práticos, a única coisa que precisamos lembrar é de declarar o `ArrayList` usando a classe empacotadora (como a `Integer`).

- Mas na hora de usar o `ArrayList` podemos tratar todos os dados como `int` normalmente.


## {.smaller}

Veja no Apêndice B do livro uma lista completa dos tipos primitivos e suas classes empacotadoras.

- Vale ressaltar também que o mesmo conceito é aplicado para as demais coleções, como a classe `HashMap`.

. . .

::: {.callout-tip title="Conceito" icon=false}
**Autoboxing** é realizado automaticamente quando um valor de tipo primitivo é usado em um contexto que requer um tipo empacotador (*wrapper*).
:::


# Estudo Autônomo: escrevendo a documentação de classes {background-color="#40666e"}

## {.smaller}

Em grandes empresas, é muito comum precisarmos utilizar uma classe que foi desenvolvida há muito tempo,

- e, possivelmente, quem criou a classe nem trabalha mais na empresa.

. . .

Nesses casos, é muito importante que a classe tenha uma documentação, assim com as classes da biblioteca do Java.

- Pois, com ela, podemos utilizar a classe sem precisar entender sua implementação.
- Portanto, é muito importante que saibamos gerar a documentação de nossas classes.

## {.smaller}

O Java possui uma ferramenta ([`javadoc`]{.alert}) para geração de documentação a partir de comentários do código.

- E o BlueJ possui uma integração bem fácil com essa ferramenta.

. . .

Como material de estudo autônomo, estude a seção 5.10 do livro da disciplina.

- Você verá que podemos gerar e visualizar a documentação de nossas classes, facilmente, no próprio BlueJ.

# Encapsulamento {background-color="#40666e"}

## Público vs. Privado {.smaller}

Vocês já notaram que usamos a todo momento as palavras-chave `public` e `private` em nossos programas em Java, como mostrado no exemplo abaixo:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    // declaração de atributos
    private int numeroDeAssentos;

    // métodos
    public void definirIdade(int novaIdade) {
      ...
    }
    
    private int calcularMedia() {
      ...
    }
```
:::

. . .

Chegou a hora de entendermos para que essas palavras-chaves servem.

## {.smaller}

Nós chamamos essas palavras-chave de [modificadores de acesso]{.alert}.

- elas definem a visibilidade de atributos, construtores e métodos.

. . .

Se um método, por exemplo, é **público**:

- Ele pode ser chamado de dentro da mesma classe e também a partir de outra classe.

. . .

Já métodos **privados**, por outro lado,

- Só podem ser chamados de dentro da mesma classe onde foram declarados.
- Eles não são visíveis para as outras classes.

## {.smaller}

Como agora já conhecemos os conceitos de **interface** e **implementação** fica mais fácil entendermos o objetivo dessas palavras-chave.

. . .

Lembre-se que a **interface de uma classe** é o conjunto de detalhes que um programador que vai usar a classe precisa ver.

- Ela fornece informações sobre como usar a classe.
  - E inclui assinaturas e comentários de construtores e métodos.
- Nós também a chamamos de a parte **pública** da classe.
- Seu objetivo é definir **o que** a classe faz.

## {.smaller}

Já a **implementação** é a parte da classe que define precisamente **como** a classe funciona.

- Os corpos dos métodos, contendo comandos Java, e muitos atributos são parte da implementação.
- Ela também é chamada de parte **privada** da classe.
- Quem usa a classe não precisa conhecer a implementação.
- Inclusive, há boas razões para que o programador não possa fazer uso desse conhecimento (como veremos mais adiante).

## {.smaller}

Portanto, podemos dizer que:

- A palavra-chave `public` declara que um elemento de uma classe (atributo ou método) faz parte de sua **interface**.
  - Ou seja, é visível publicamente.
- Já a palavra-chave `private` declara que um elemento é parte da implementação.
  - Ou seja, está escondida de acesso externo.

. . .

::: {.callout-tip title="Conceito" icon=false}
**Modificadores de acesso** definem a visibilidade de um atributo, construtor ou método.
Elementos públicos são acessíveis de dentro da classe e a partir de outras classes;
já elementos privados são acessíveis somente de dentro da mesma classe.
:::

## Encapsulamento {.smaller}

Em muitas linguagens OO, a implementação de uma classe (seus detalhes internos) é ocultada de outras classes.

. . .

Isso tem a ver com duas questões.

1. Um programador que usa uma classe **não deveria [precisar conhecer]{.alert}** seus detalhes internos.
  - Isso tem a ver com a **modularização** e **abstração** que já discutimos antes.
  - Se fosse necessário saber os detalhes de todas as classes, seria impossível desenvolver grandes sistemas.

2. Outra questão é que um programador que usa uma classe **não deveria [ter permissão de conhecer]{.alert}** seus detalhes internos

- Apesar de também ter a ver com modularização, a ideia aqui é que a linguagem não deveria permitir o acesso à parte privada de uma classe a partir de comandos em outras classes.
- Isso garante que uma classe não depende de **como** exatamente uma outra classe está implementada.

## {.smaller}

Esta última questão é muito importante para a manutenção de sistemas.

- Quando precisamos incluir novas funcionalidades ou corrigir bugs é muito comum precisarmos alterar ou aumentar uma classe.
- O ideal é que a alteração de uma classe não provoque alterações em outras classes.
  - Isso tem a ver com o que chamamos de **acoplamento**.
  - Se a alteração em uma classe não provoca alterações em outras classes, temos um baixo acoplamento.
  - E isso é muito bom, porque torna o trabalho de manutenção muito mais fácil.
  - Já que em vez de entender e alterar várias classes, o programador precisa trabalhar apenas em uma.

## {.smaller}

Suponha, por exemplo, que a equipe que mantém a linguagem Java faça uma melhoria na implementação da classe `ArrayList`.

- Nós esperaríamos que nosso código não precisasse ser alterado por causa dessa alteração da `ArrayList`.
- Repare que isso é possível porque nosso código não faz referência à implementação da classe `ArrayList`.




. . .


::: {.callout-tip title="Conceito" icon=false}
**Encapsulamento** (ou *ocultamento de informações*) é um princípio que define que os detalhes internos da implementação de uma classe deveriam ser ocultados das outras classes.
Isso permite uma melhor modularização de uma aplicação.
:::









## 

::: {.callout-note title="Exercício" icon=false}

:::
