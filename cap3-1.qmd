---
title: IPOO - Cap. 3 Interação entre Objetos
subtitle: Aula 3.1 - Teórica
---


## Como estudar? {.smaller}

Será que preciso dizer de novo as [dicas]{.alert}? :)

:::: {.columns}

::: {.column width="70%"}

- É essencial **praticar enquanto estuda**, usando o BlueJ.
- Ajuda muito se você **ler o** capítulo do **livro** da disciplina para tirar dúvidas e complementar o que está sendo estudado.
- Use um caderno e caneta para [anotar]{.alert} os principais [conceitos]{.alert} e eventuais [dúvidas]{.alert} que surgirem.

:::

::: {.column width="30%"}
![](imagens/bluej_completo_vertical.png){fig-alt="Prints do BlueJ." width=50%}
![](imagens/livro_bluej.png){fig-alt="Capa do livro do Barnes e Kolling." fig-align="left" width=50%}
:::

::::

## Principais Conceitos do Capítulo {.smaller}

::: {.nonincremental}
- Abstração
- Modularização
- Criação de objetos
- Chamadas de métodos
- Depuradores
:::

. . .

Construções Java do capítulo

::: {.nonincremental}
- Tipos de classe, operadores lógicos (`&&` e `||`), concatenação de strings, construção de objetos (operador `new`), chamadas de métodos, `this`.
:::

. . .

Nós já temos uma boa noção do que são objetos, como são implementados através de classes e como são utilizados individualmente.

- Nós agora vamos ver que, para criar aplicações interessantes, precisamos usar objetos que cooperam entre si para realizar alguma tarefa.

# Abstração e Modularização {background-color="#40666e"}

## {.smaller}

Para entender como podemos criar aplicações com **objetos que cooperam entre si**, vamos começar com um exemplo bem simples.

. . .

:::: {.columns}

::: {.column width="70%"}
Um **visor de um relógio digital** que mostra horas e minutos, separados por dois-pontos.
:::

::: {.column width="30%"}
![](imagens/visor_relogio_digital.png)
:::

::::

. . .

Em um primeiro momento poderíamos pensar em criar uma única classe para representar o visor do relógio.

- Mas vamos usar uma abordagem diferente.
- O objetivo é usar esse exemplo bem simples para demonstrar como podemos tratar um problema, **dividindo-o em subproblemas** menores, que são **mais fáceis de resolver**.

## {.smaller}

![](imagens/duvida_modularizacao.png)

. . .

O motivo para criarmos mais de uma classe em vez de fazer tudo em uma só é a [complexidade]{.alert}.

- À medida que avançarmos na disciplina, vamos criar programas cada vez mais complexos.
- Problemas simples como o da máquina de ingressos podem ser resolvidos com uma única classe.
- Mas para projetos maiores é muito **difícil** conseguir **tratar todos os detalhes ao mesmo tempo**.
- O que fazemos então é **identificar subcomponentes** do problema que possam ser **tratados em classes separadas**.

## {.smaller}

Para lidar com a complexidade, usamos a [abstração]{.alert}.

## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

![](imagens/dividir-conquistar-1.png){.relative width="70%"}

:::


## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.

![](imagens/dividir-conquistar-2.png){.relative width="70%"}

:::


## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.
  - E dividimos novamente em problemas ainda menores.

![](imagens/dividir-conquistar-3.png){.relative width="70%"}

:::

## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.
  - E dividimos novamente em problemas ainda menores.
  - Fazemos isso até que eles sejam pequenos o suficiente para conseguirmos lidar com eles.

![](imagens/dividir-conquistar-3.png){.relative width="70%"}

:::

## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.
  - E dividimos novamente em problemas ainda menores.
  - Fazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.
- Depois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles.

![](imagens/dividir-conquistar-3.png){.relative width="70%"}

:::

## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.
  - E dividimos novamente em problemas ainda menores.
  - Fazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.
- Depois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles.
  - E os utilizamos como blocos (caixa-preta) para resolver os problemas maiores.

![](imagens/dividir-conquistar-4.png){.relative width="70%"}

:::

## {.smaller auto-animate=true}

::: {.nonincremental}

O problema a ser resolvido, às vezes é muito grande.

- Nós então dividimos o problema subproblemas.
  - E dividimos novamente em problemas ainda menores.
  - Fazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.
- Depois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles.
  - E os utilizamos como blocos (caixa-preta) para resolver os problemas maiores.
  - Até termos todo o problema resolvido.

![](imagens/dividir-conquistar-5.png){.relative width="70%"}

:::

## {.smaller}

Essa técnica de dividir o problema em problemas menores é chamada de [dividir para conquistar]{.alert}.

. . .

Podemos entender isso melhor com um exemplo.

## {.smaller}

Vamos pensar em uma equipe de engenheiros **projetando um carro**.

- Eles pensam nas **partes do carro**: *design*, tamanho, local do motor, quantidade de assentos, espaçamento entre rodas, etc.

![](imagens/engenheiros_carro.jpg){width="40%"}^[Imagem de vectorjuice no Freepik ]



## {.smaller}

Outra equipe de engenheiros projeta o **motor**.

- Eles pensam em cada **parte do motor**: as cilindradas, o mecanismo de injeção, a eletrônica, etc.
- Para eles o motor não é uma peça única, e sim **um sistema complexo** de várias partes
  ![](imagens/motor_carro.png){width="50%"}

- Uma delas pode ser a vela de ignição.


## {.smaller}

Há então uma terceira equipe de engenheiros (muitas vezes de outra empresa) que projeta a **vela de ignição**.

- Eles pensam na vela como um sistema com **várias partes**.
  ![](imagens/vela_ignicao.png){width="50%"}
- Eles podem ter feito estudos complexos para saber o metal certo a ser usado, e como é o processo detalhado de fabricação e instalação.

# {.smaller}

A mesma coisa acontece com as outras partes do carro.

. . .

:::: {.columns}

::: {.column width="50%"}
Um *designer* de alto nível vai pensar no **pneu como uma peça única**.

![](imagens/pneu.png){width="30%"} 
:::

::: {.column width="50%"}
::: {.fragment}
Mas outro engenheiro estuda a **composição química ideal** para produzir o material certo para os pneus.

- Para ele, o **pneu é uma coisa complexa**.
  ![](imagens/pneu_detalhado.png){width="50%"}
:::
:::

:::: 

. . .

Já a empresa que fabrica o carro, vai apenas comprar o pneu da fabricante de pneus e enxergá-lo como uma única peça.

- Isto é [abstração]{.alert}!

# {.smaller}

Os engenheiros da fabricante de carros [abstraem]{.alert} (*ignoram*) os detalhes da fabricação dos pneus para conseguirem se concentrar nos detalhes de criação da roda, por exemplo.

- Já os *designers* ignoram os detalhes da roda ou do motor para se concentrar no *design* do carro como um todo.
  - Eles se preocupam apenas com o tamanho do motor e das rodas.

. . .

Repare que um carro é formado por tantas partes que é praticamente **impossível** uma pessoa só **saber todos os detalhes**, de todas as partes, ao mesmo tempo.

- Se fosse assim, provavelmente carros nem seriam fabricados.

# {.smaller}

Se os carros podem ser fabricados aos milhares hoje em dia é porque os engenheiros usam [modularização]{.alert} e abstração.

- Eles **dividem** o carro **em módulos** independentes (roda, motor, caixa de marcha, assento, etc.).
  - E equipes separadas trabalham em **cada módulo** de forma **independente**.
- Quando o módulo é construído, eles usam **abstração**.
  - Ou seja, eles enxergam o **módulo como uma peça única** e o utilizam para construir componentes mais complexos.

# {.smaller}

Modularização e abstração se complementam.

. . .

::: {.callout-tip title="Conceito" icon=false}
**Abstração** é a habilidade de ignorar detalhes das partes, para focar a atenção em um nível mais alto de um problema.
:::

. . .

::: {.callout-tip title="Conceito" icon=false}
**Modularização** é o processo de dividir um todo em partes bem definidas que podem ser construídas e examinadas separadamente, e que interagem de formas bem definidas.
:::

# Abstração em Software {background-color="#40666e"}

## {.smaller}

A mesma ideia de **modularização e abstração** do exemplo do carro **é aplicada no desenvolvimento de software**.

- Para conseguirmos implementar um sistema complexo, nós tentamos dividi-lo em subcomponentes que possamos programar de forma independente.
- Depois tentamos usar esses componentes, como se eles fossem partes simples, sem nos preocuparmos com seus detalhes internos.

. . .

Em **POO**, os componentes e subcomponentes são **objetos**.

- Para criar um carro completo em um sistema OO, faríamos como no exemplo da fábrica.
- Criaríamos objetos separados para motor, roda, caixa de marcha, etc.
- E usaríamos esses objetos para construir um objeto carro.

## {.smaller}

Não é simples pensar nos tipos de objetos (e, consequentemente, nas classes) que precisamos ter em um software.

- Por isso, vamos começar com o exemplo simples do mostrador do relógio.

## Quiz 3.1 {background-color="#f7fad1" .smaller}

::: {.nonincremental}
[O conceito de abstração tem relações com:]{.alert}

a. Prestar muita atenção aos detalhes de um problema.
b. Ignorar completamente os detalhes de um problema.
c. Dividir um problema em problemas menores, de forma a ter diferentes níveis de atenção aos seus detalhes.
d. Criar atributos abstratos.
:::

# Modularização no exemplo do relógio {background-color="#40666e"}

## {.smaller}

Voltando ao exemplo do visor de relógio digital, qual seria a maneira mais direta de implementá-lo?

- Poderíamos pensar em uma única classe que representasse os quatro dígitos do relógio, certo?

![](imagens/visor_relogio_digital.png)

. . .

Mas vamos tentar usar **modularização**.

- Como você poderia dividir o "problema" de representar o visor, em subproblemas?

## {.smaller}

Repare como funcionam os dígitos das horas.

- Eles começam em 0, incrementam de 1 em 1, até chegar a 23, e depois voltam para zero.

. . .

E como funcionam os dígitos dos minutos?

- Eles começam em 0, incrementam de 1 em 1, até chegar a 59, e depois voltam para zero.

. . .

Repare que o comportamento dos dígitos das horas e dos minutosé exatamente o mesmo.

- O que muda é apenas o valor limite que faz o valor voltar para zero.

- Podemos pensar então em um objeto capaz de representar um visor de dois dígitos.
  ![](imagens/visor_numeros.png)
- E poderíamos usar dois objetos desse tipo, um para as horas e outro para os minutos, para representar o relógio.

# Implementando o visor do relógio {background-color="#40666e"}

## {.smaller}

Precisamos então definir uma classe para representar um visor de número de dois dígitos.

- Ela poderia ter um método de acesso para retornar seus valores.
- E dois métodos modificadores:
  - Para definir o valor.
  - E para incrementá-lo (adicionar 1), zerando ao chegar no limite.

. . .

Com a classe pronta, podemos criar dois objetos dela com limites diferentes para representar o relógio.

## {.smaller}

Quais **atributos** são necessários na classe que representa números de dois dígitos?

- Veja que precisamos guardar o valor propriamente dito.
- E o limite que faz o valor voltar para zero.

. . .

Esses valores devem ser de que tipo?

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public class VisorDeNumero
{
    private int limite;
    private int valor;

    // construtor e métodos omitidos.
}
```
:::

## {.smaller}

Antes de pensar nos detalhes da classe `VisorDeNumero`, imagine que já temos a classe pronta.

- Como poderíamos construir um visor de relógio completo, usando essa classe?
- Precisamos de dois objetos visor de números (um para as horas e outro para os minutos).
  - Portanto, cada um desses objetos deve ser um **atributo** na classe que representa o visor do relógio.

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public class VisorDeRelogio
{
    private VisorDeNumero horas;
    private VisorDeNumero minutos;

    // construtor e métodos omitidos.
}
```
:::

. . .

Repare que [classes definem tipos]{.alert}.

## {.smaller}

O **tipo de um atributo** determina o tipo dos valores que ele pode guardar.

- Se o tipo é uma classe, o atributo pode guardar objetos daquela classe.

. . .

::: {.callout-warning title="Declaração não cria objetos"}
Uma declaração de um atributo ou uma variável do tipo de uma classe não cria automaticamente um objeto daquela classe.

- A princípio o atributo ou variável fica vazio.
- Portanto, no construtor da classe `VisorDeRelogio` precisaremos criar os objetos a serem guardados pelos atributos.
:::

. . .

::: {.callout-tip title="Conceito" icon=false}
**Classes definem tipos**. Um nome de classe pode ser usado como tipo de uma variável. Variáveis de tipo de uma classe podem guardar objetos daquela classe.
:::

# Diagramas de classe vs. diagramas de objetos {background-color="#40666e"}

## {.smaller}

Compare as duas figuras abaixo:

- À esquerda temos o [diagrama de objetos]{.alert} do visor de relógio.
- À direita temos o [diagrama de classes]{.alert} para a mesma situação.

:::: {.columns}

::: {.column width="50%"}
![](imagens/visor_relogio_diagrama_objetos.png)
:::

::: {.column width="50%"}
![](imagens/visor_relogio_diagrama_classes.png)
:::

:::: 

. . .

![](imagens/duvida_2_classes_3_objetos.png){width="40%"}

## {.smaller}

Repare que nós criamos dois objetos da mesma classe `VisorDeNumero`.

. . .

Os dois diagramas mostram diferentes visões do mesmo programa.

- O diagrama de classes mostra uma [visão estática]{.alert}.
  - Ou seja, representa o **momento da programação**, quando estamos escrevendo o código.
  - Dizemos que `VisorDeRelogio` usa (ou depende) de `VisorDeNumero`.

. . .

Quando o programa é iniciado, vamos criar um objeto `VisorDeRelogio`.

- E vamos implementar a classe de forma que ela crie automaticamente dois objetos `VisorDeNumero`.
- Portanto, o diagrama de objetos mostra uma [visão dinâmica]{.alert}.
- Ele representa o **tempo de execução**, quando o programa está executando.

## {.smaller}

![](imagens/visor_relogio_diagrama_objetos.png){width="40%"} 

Vamos avaliar o diagrama de objetos novamente, pois ele traz um detalhe importante.

- Repare que quando uma variável que guarda um objeto, ela não o guarda diretamente.
- Na verdade a variável guarda uma [referência]{.alert} (um ponteiro) [para o objeto]{.alert} .

. . .

No diagrama a variável é representada pela caixa branca.

- E a referência do objeto pela seta.
- Portanto, repare que o objeto `VisorDeNumero` é armazenado fora do objeto `VisorDeRelogio`.
  - E a referência (o ponteiro) é que liga os dois.

##

::: {.callout-note title="Exercício" icon=false}
Pense no projeto de exemplo `disciplina` que vimos antes.
Suponha que criamos um objeto `Disciplina` e três objetos `Estudante`, e matriculamos os estudantes na disciplina.
Tente desenhar um diagrama de classes e um diagrama de objetos para essa situação.
Explique a diferença entre os diagramas.
:::

::: {.callout-note title="Exercício" icon=false}
Quando um diagrama de classes é alterado? E como ele é alterado?
:::

::: {.callout-note title="Exercício" icon=false}
Quando um diagrama de objetos é alterado? E como ele é alterado?
:::

::: {.callout-note title="Exercício" icon=false}
Escreva a declaração de um atributo `orientador` que guarde uma referência para um objeto `Professor`.
:::

## Quiz 3.2 {background-color="#f7fad1" .smaller}

::: {.nonincremental}
[Marque a alternativa incorreta:]{.alert}

a. Classes definem tipos.
b. Diagramas de classes dão uma visão estática do programa.
c. Diagramas de objetos dão uma visão dinâmica do programa.
d. Visão estática se refere ao tempo de execução do programa.
:::

# Tipos primitivos e tipos objetos {background-color="#40666e"}

## {.smaller}

Java tem dois tipos diferentes de tipos : 

:::: {.columns}

::: {.column width="50%"}
::: {.fragment}
[Tipos primitivos]{.alert}

![](imagens/homem_cavernas.jpg){width="30%"} <!--^[Imagem de macrovector no Freepik]-->
:::
:::

::: {.column width="50%"}
::: {.fragment}
[Tipos objeto]{.alert} (ou *tipos por referência*)

![](imagens/o_objeto.png){width="40%"}
:::
:::

::::

. . .

Tipos primitivos são predefinidos na linguagem Java

- Ex.: `int`, `boolean`, `double`.

. . .

Já os tipos objeto são definidos por classes.

- Algumas classes fazem parte do Java padrão (como a `String`).
- E podemos criar nossas próprias classes.

## {.smaller}

Tipos objeto e tipos primitivos têm **semelhanças**:

- Ambos podem ser usados como tipos.

. . .

Mas se comportam de forma **diferente**:

- Tipos primitivos são guardados diretamente nas variáveis.
  - No diagrama de objetos mostramos os valores diretamente nas caixas das variáveis.
- Já tipos objeto guardam apenas uma referência (ponteiro) para o objeto.
  - No diagrama representamos com uma seta.

. . .


::: {.callout-tip title="Conceito" icon=false}
Os **tipos primitivos** em Java não definem objetos. Tipos como `int`, `boolean` e `double` são os tipos primitivos mais comuns. Tipos primitos não possuem métodos.
:::

# A classe `VisorDeNumero` {background-color="#40666e"}

## {.smaller}

Antes de vermos o exemplo do relógio, é importante entendermos a classe `VisorDeNumero`.

- E assim sabermos como ela pode ser usada para construir o relógio.

. . .

Vamos avaliar o código da classe, baixando o projeto [visor-numero](https://github.com/ufla-ipoo/visor-numero).


##

::: {.callout-note title="Exercício" icon=false}
No BlueJ acesse a opção: **Exibir** --> **Exibir terminal**, e no terminal acesse **Opcoes** --> **Anotar chamadas de métodos**.

Crie um objeto `VisorDeNumero` com limite `24` e dê o nome `horas` para a variável.

- Abra o inspetor e, com ele aberto, chame o método `incrementar` do objeto criado.
- Repare, no terminal, como é a chamada do método.
- Chame repetidamente o método `incrementar` até que ele volte para zero. Obs.: use um limite menor se estiver impaciente :)
:::

##

::: {.callout-note title="Exercício" icon=false}
Crie outro objeto `VisorDeNumero`, com limite 60 , e dê o nome `minutos`.

- Chame o método `incrementar` do objeto e repare como é a chamada no terminal.
- Repare que você está fazendo o papel do relógio já que tem um visor de horas e um de minutos.
- O que você deveria fazer a cada chamada do método `incrementar` para o objeto `minutos` para saber se é hora de incrementar o objeto de `horas`?
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Usando o bloco de códigos do BlueJ, crie um objeto `VisorDeNumero`, chamado `vn`, com limite 6, e experimente todos os seus métodos.
:::

##

::: {.callout-note title="Exercício" icon=false}
Experimente digitar o código abaixo no Bloco de Códigos:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
VisorDeNumero.obterValor();
```
:::

O que a mensagem de erro indica? 
:::

::: {.callout-note title="Exercício" icon=false}
Experimente agora a linha abaixo:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
vn.definirValor(int 5);
```
:::

A mensagem de erro, nesse caso, te ajuda a identificar o problema?

Tente corrigir o código e memorizar essa situação que é muito comum para quem está começando.
:::

## {.smaller}

Repare que o método `definirValor` utiliza uma expressão booleana

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
public void definirValor(int novoValor)
{
    if((novoValor >= 0) && (novoValor < limite)) {
        valor = novoValor;
    }
}
```
:::

. . .

Em **Java**, os [operadores lógicos]{.alert} são:

- `&&`
  - **e** lógico (*and em C++*).
- `||`
  - **ou** lógico (*or em C++*).
- `!`
  - **negação** (*not em C++*).

##

::: {.callout-note title="Exercício" icon=false}
O que acontece quando o método `definirValor` é chamado com um valor inválido (experimente!).

Você acha que da forma que foi feito é uma boa solução? Consegue pensar em uma solução melhor?
:::

::: {.callout-note title="Exercício" icon=false}
O que aconteceria se, no método `definirValor`, o operador `>=` fosse trocado por `>`?
:::

::: {.callout-note title="Exercício" icon=false}
O que aconteceria se, no método `definirValor`, o operador `&&` fosse trocado por `||`?
:::

##

::: {.callout-note title="Exercício" icon=false}
Estude a implementação dos métodos `obterValorVisor` e `incrementar`.
Caso tenha dúvidas, estude as páginas 56 a 59 do livro do Barnes e Kölling (4ª ed.).
:::

::: {.callout-note title="Exercício" icon=false}
O método `obterValorVisor` sempre funciona corretamente?
Quais premissas ele assume?
O que acontece, por exemplo, se você criar um objeto com limite 800?
:::

# A classe `VisorDeRelogio` {background-color="#40666e"}

## {.smaller}

Agora que já entendemos como criar uma clase que define um visor de números de dois dígitos, vamos estudar o projeto [visor-relogio](https://github.com/ufla-ipoo/visor-relogio).

- Ele possui a classe `VisorDeRelogio` que cria dois objetos visores de números para construir o visor completo do relógio.


##

::: {.callout-note title="Exercício" icon=false}
Crie um objeto `VisorDeRelogio`, selecionando este construtor:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  new VisorDeRelogio()
```
:::

Chame o método `obterHora` para descobrir a hora inicial que o relógio foi criado.
Você consegue imaginar porque ele começa nesse horário específico?
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Abra o inspetor para esse objeto.
Com o inspetor aberto, chame os métodos do objeto, observando o atributo `stringVisor` no inspetor.
No BlueJ, abra o arquivo `README.md` para entender melhor o funcionamento do projeto.
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Quantas vezes você precisa chamar o método `tiqueTaque` no objeto `VisorDeRelogio` para fazer sua hora chegar a `01:00`.
De que outra forma você poderia fazer o relógio mostrar esse mesmo horário?
:::

## {.smaller}

Vamos agora estudar a classe `VisorDeRelogio`.

- Abra a classe e avalie todo o código.

. . .

Veja que o atributo `stringVisor` simula um visor físico real do relógio.

- Se esse software rodasse em um relógio de verdade, nós mostraríamos a informação no visor físico.
- Aqui, o atributo `stringVisor` serve para simular o visor real do relógio.

. . .

A classe `VisorDeRelogio` tem mais dois atributos: `horas` e `minutos`.

- Eles guardam **referências** para objetos do tipo `VisorDeNumero`.
- O valor lógico do horário do relógio é guardado nesses dois atributos.

## {.smaller}

O digrama de objetos abaixo mostra de forma mais completa um objeto `VisorDeRelogio`.

- Veja que todos os atributos são referências para outros objetos.
- Inclusive `stringVisor`, já que uma string é um objeto em Java.
  - Obs.: por simplicidade, o diagrama não mostra a representação interna do objeto String.

![](imagens/visor_relogio_diagrama_objetos2.png){.r-stretch}

##

::: {.callout-tip title="Só para os curiosos" collapse="true"}
Você pode também abrir o projeto [visor-relogio-com-interface-grafica](https://github.com/ufla-ipoo/visor-relogio).
Veja que ele possui uma classe a mais que você pode experimentar e ver o que faz.
:::


# Objetos criando objetos {background-color="#40666e"}

## {.smaller}

Vimos que um visor de relógio possui dois visores de números, para horas e minutos.

- Mas de onde vêm esses objetos no código?

. . .

Veja que, **como usuários** do mostrador de relógio, nós criamos apenas o objeto da classe `VisorDeRelogio`.

- E esperamos que os **visores de números** sejam **criados implicitamente**.

. . .

Mas, **como programadores** da classe `VisorDeRelogio`, nós precisamos fazer isso acontecer.

- Para isso, basta **criarmos os objetos `VisorDeNumero` dentro do construtor** da classe `VisorDeRelogio`.
- Como o construtor é chamado quando um objeto `VisorDeRelogio` é criado, os visores de número serão criados automaticamente.

## {.smaller}

Vamos analisar como o construtor de `VisorDeRelogio` faz isso:

::: {.halfincfontsize}
```{.java}
public class VisorDeRelogio
{
    private VisorDeNumero horas;
    private VisorDeNumero minutos;

    // Atributos restantes omitidos

    public VisorDeRelogio()
    {
        horas = new VisorDeNumero(24);
        minutos = new VisorDeNumero(60);
        atualizarVisor();
    }

    // Métodos omitidos
}
```
:::

## {.smaller}

Vamos analisar como o construtor de `VisorDeRelogio` faz isso:

::: {.halfincfontsize}
```{.java code-line-numbers="10-11"}
public class VisorDeRelogio
{
    private VisorDeNumero horas;
    private VisorDeNumero minutos;

    // Atributos restantes omitidos

    public VisorDeRelogio()
    {
        horas = new VisorDeNumero(24);
        minutos = new VisorDeNumero(60);
        atualizarVisor();
    }

    // Métodos omitidos
}
```
:::

As duas primeiras linhas do construtor criam objetos `VisorDeNumero`

- E os atribuem a variáveis.

## {.smaller}

Repare a **sintaxe** do **comando** que **cria um novo objeto**:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  new NomeDaClasse(lista_de_parametros)
```
:::

. . .

O operador [`new`]{.alert} faz duas coisas:

1. Cria um novo objeto da classe nomeada (no nosso exemplo `VisorDeNumero`).
2. Executa o construtor daquela classe.

. . .

**Se** o construtor da classe **tiver parâmetros**, os valores deles devem ser passados.

## {.smaller}

Repare, por exemplo, que o construtor da classe `VisorDeNumero` espera um valor inteiro como parâmetro.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  public VisorDeNumero(int limiteParaZerar)
```
:::

. . .

Com isso, ao usarmos o operador `new` para criar um objeto `VisorDeNumero`, como ele chama o construtor da classe, precisaremos fornecer um argumento inteiro.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  new VisorDeNumero(24);
```
:::

- Note que a passagem de parâmetros funciona da mesma forma que já tínhamos visto para os métodos.

## {.smaller}

Veja que da forma que fizemos, ficou como gostaríamos:

- Como ***usuários*** do `VisorDeRelogio`:
  - Criamos apenas esse objeto, e os visores de números são criados implicitamente.
- Já como ***programadores*** da classe:
  - Precisamos explicitar a criação dos objetos, escrevendo código para isso.

. . .


Obs.: ao final do construtor, o método `atualizarVisor` é chamado. Conversaremos sobre ele mais adiante.

## 

::: {.callout-note title="Exercício" icon=false}
Escreva comandos em Java que declarem uma variável chamada `janela`, do tipo `Retangulo`, e então crie um objeto `Retangulo` e o atribua à variável.
Assuma que o construtor de `Retangulo` tem dois parâmetros do tipo `int`.
:::

## Quiz 3.3 {background-color="#f7fad1" .smaller}

::: {.nonincremental}
[Marque a alternativa correta:]{.alert}

a. Atributos de tipo objeto guardam referências (ponteiros) para objetos.
b. Atributos de tipo primitivo guardam referências (ponteiros) para objetos primitivos. 
c. Objetos só podem criar outros objetos dentro de construtores.
d. Objetos são criados usando o operador `create`.
:::


# Múltiplos construtores {background-color="#40666e"}

## {.smaller}

Ao criar objetos da classe `VisorDeRelogio`, usando o BlueJ, você deve ter notado que há duas opções no menu para criar o objeto.

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  new VisorDeRelogio()
  new VisorDeRelogio(int hora, int minuto)
```
:::

. . .

Isso acontece porque `VisorDeRelogio` tem [dois construtores]{.alert}.

- Eles servem para **fornecer formas alternativas de inicializar um objeto** `VisorDeRelogio`.
  - Com o construtor sem parâmetros, criamos um relógio com hora inicial 00:00.
  - Já usando o segundo construtor, podemos criar um relógio com hora inicial diferente.

. . .

É comum que classes tenham vários construtores para dar várias opções de criação dos seus objetos.

- Para isso funcionar, cada construtor deve ter um conjunto diferente de parâmetros.
- Damos a isso o nome de [sobrecarga]{.alert} de construtores.


## {.smaller}

![](imagens/sobrecarga_galvao.png)

## {.smaller}

![](imagens/sobrecarga_galvao_resposta.png)

. . .

Assim como os construtores, [métodos]{.alert} também [podem ser sobrecarregados]{.alert}.

## {.smaller}

![](imagens/duvida_metodos_sobrecarregados.png)

. . .

O que pode e o que não pode ser feito em termos de sobrecarga tem a ver com **o que o compilador consegue identificar**.

. . .

Imagine a chamada abaixo:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
	meuCarro.deslocar(68.5);
```
:::

. . .

Como o compilador conseguiria definir qual dos métodos está sendo chamado?

- O compilador não consegue!
- Portanto, não é possível criar dois métodos sobrecarregados dessa forma.


## {.smaller}

![](imagens/duvida_metodos_sobrecarregados_retorno.png)

. . .

Mais uma vez vamos pensar em um exemplo de chamada:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
	int a = meuCarro.acelerar();
```
:::

. . .

Nesse caso, parece que seria possível pois o compilador sabe que a variável `a` é do tipo `int`.

- Mas na verdade você não é obrigado a usar o valor retornado por uma chamada de método.
  ```{.java code-line-numbers="false"}
	meuCarro.acelerar();
  ```
- A chamada acima, por exemplo é válida, e, nesse caso, o compilador não consegue definir qual método será chamado.
- Portanto, não é possível declarar métodos sobrecarregados dessa forma.


## 

::: {.callout-tip title="Conceito" icon=false}
**Sobrecarga**: Uma classe pode ter mais de um construtor, ou mais de um método com o mesmo nome, desde que cada um tenha um conjunto diferente de tipos de parâmetros (ou seja, a quantidade ou a ordem dos tipos dos parâmetros precisa ser diferente).
:::

. . .

::: {.callout-note title="Exercício" icon=false}
Avalie o segundo construtor no código da classe `VisorDeRelogio`.
Explique o que ele faz e como ele faz isso.

Identifique as semelhanças e diferenças entre os dois construtores.
Porque o método `atualizarVisor` não é chamado no segundo construtor, por exemplo?
:::

# Chamadas de métodos {background-color="#40666e"}

## {.smaller}

A última linha do construtor de `VisorDeRelogio` tem o comando `atualizarVisor`.

::: {.halfincfontsize}
```{.java code-line-numbers="5"}
    public VisorDeRelogio()
    {
        horas = new VisorDeNumero(24);
        minutos = new VisorDeNumero(60);
        atualizarVisor();
    }
```
:::

. . .

Este comando é uma [chamada de método]{.alert}.

- Você já deve ter visto que a classe `VisorDeRelogio` tem um método com a seguinte assinatura:
  
  ::: {.halfincfontsize}
  ```{.java code-line-numbers="false"}
    private void atualizarVisor()
  ```
  :::

. . .

Portanto, o último comando no construtor, chama este método.

- Como o método está na mesma classe, a essa operação damos o nome de [chamada de método interno]{.alert}.

## {.smaller}

Uma chamada de método interno tem a seguinte **sintaxe**:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  nomeDoMetodo(lista_de_parametros)
```
:::

. . .

Repare que uma chamada de método interno não usa variável, nem ponto.

- Não é necessário usar variável porque o objeto chama o método dele mesmo.

. . .

Métodos podem ter parâmetros ou não.

- Nesse exemplo, como o método não tem parâmetros, não passamos nenhum valor na chamada do método.

## {.smaller}

Quando há uma chamada de método, o **método correspondente é executado**.

- E, então, a **execução retorna** para onde o método foi chamado e **continua depois dela**.
- O método correspondente precisa ter o mesmo nome e a mesma sequência de tipos de parâmetros.
  - Já que podem existir métodos **sobrecarregados**.

## {.smaller}

Vamos agora avaliar o código do método `tiqueTaque`:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
    public void tiqueTaque()
    {
        minutos.incrementar();
        if(minutos.obterValor() == 0) {  // minutos voltaram para zero
            horas.incrementar();
        }
        atualizarVisor();
    }
```
:::

. . .

Se este visor estivesse conectado a um relógio de verdade, este método seria chamado a cada 60 segundos por um temporizador eletrônico do relógio.

- Aqui, nós mesmos chamamos o método para testar o visor.

## {.smaller}

::: {.halfincfontsize}
```{.java code-line-numbers="3"}
    public void tiqueTaque()
    {
        minutos.incrementar();
        if(minutos.obterValor() == 0) {  // minutos voltaram para zero
            horas.incrementar();
        }
        atualizarVisor();
    }
```
:::

A primeira linha do método chama o comando `incrementar` do objeto `minutos`.

- Veja então que, dessa, quando um dos métodos do `VisorDeRelogio` é chamado, ele, por sua vez, chama um método de outro objeto como parte da tarefa.

. . .

Uma chamada a um método de outro objeto é uma [chamada de método externo]{.alert}.

## {.smaller}

Uma **chamada de método externo** tem a seguinte **sintaxe**:

. . .

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  objeto . nomeDoMetodo (lista_de_parametros)
```
:::

. . .

Essa sintaxe é conhecida como notação de ponto (*dot notation*).

- Usamos o nome do objeto, seguido de ponto, seguindo do nome do método, seguido dos parâmetros do método.
- Repare que usamos o nome do objeto e não da classe.


## {.smaller}

Veja que, quando usamos o nome de objeto, temos uma chamada de método externo.

- O que é bem diferente de uma chamada de método interno.
- Porque, ao chamar o método externo, estamos pedindo a um objeto `VisorDeNumero` para fazer parte da tarefa completa.

. . .

Podemos dizer que a tarefa de manter as horas é dividida entre as classe `VisorDeRelogio` e `VisorDeNumero`.

- Este é um exemplo prático do princípio de **dividir e conquistar** que vimos no início do capítulo ao discutirmos sobre **abstração**.


## {.smaller}

::: {.halfincfontsize}
```{.java code-line-numbers="4"}
    public void tiqueTaque()
    {
        minutos.incrementar();
        if(minutos.obterValor() == 0) {  // minutos voltaram para zero
            horas.incrementar();
        }
        atualizarVisor();
    }
```
:::

Repare que a linha seguinte do método `tiqueTaque` faz outra chamada de método externo.

- O método retorna o valor atual dos minutos.
- Se ele acabou de ir para zero, é hora de incrementar as horas, e isso é feito em seguida.

## {.smaller}

Podemos agora entender os demais métodos da classe.

- Identifique neles onde ocorrem chamadas de método interno e chamadas de método externo.

. . .

::: {.callout-tip title="Conceito" icon=false}
Métodos podem chamar outros métodos da mesma classe como parte de sua implementação.
Chamamos isso de **chamada de método interno**.
:::

. . .

::: {.callout-tip title="Conceito" icon=false}
Métodos podem chamar métodos de outros objetos usando notação de ponto.
Chamamos isso de **chamada de método externo**.
:::

##

::: {.callout-note title="Exercício" icon=false}
Suponha que exista uma variável chamada `imp1` do tipo `Impressora`, que referencia um objeto impressora, cuja classe tem métodos com as seguintes assinaturas:

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  public void imprimir(String nomeDoArquivo, boolean dosDoisLados)
  public int obterSituacao(int atraso)
```
:::

Escreva duas possíveis chamadas para cada um desses métodos. 
:::

::: {.callout-note title="Exercício" icon=false}
Abra o projeto [`casa`](https://github.com/ufla-ipoo/casa) e avalie a classe `Figura`.
Que tipos de objetos são criados no construtor de `Figura`?
:::

::: {.callout-note title="Exercício" icon=false}
Liste todas as chamadas de métodos externos que são feitas no método `desenhar` da classe `Figura` para o objeto `Triangulo` chamado `telhado`.
:::

##

::: {.callout-note title="Exercício" icon=false}
Remova as duas linhas abaixo do método `desenhar` da classe `Figura`, fazendo com que a definição das cores seja feita através de uma chamada de um método interno chamado `definirCor` (que você precisará criar).

::: {.halfincfontsize}
```{.java code-line-numbers="false"}
  janela.mudarCor("preta");
  sol.mudarCor("amarela");
```
:::

:::

## Quiz 3.4 {background-color="#f7fad1" .smaller}

::: {.nonincremental}
[Marque a alternativa incorreta:]{.alert}

a. Construtores e métodos podem ser sobrecarregados.
b. Métodos sobrecarregados são aqueles que têm muitos comandos.
c. Métodos sobrecarregados são métodos de uma mesma classe que possuem o mesmo nome.
d. Objetos podem chamar métodos de outros objetos através de chamadas de método externo.
:::


# Recapitulando o visor de relógio {background-color="#40666e"}

## {.smaller}

É importante reforçarmos como o projeto do visor de relógio usa o conceito de **abstração** para dividir o problema em problemas menores.

- Repare que, no código da classe `VisorDeRelogio`, criamos objetos `VisorDeNumero` sem nos preocupar sobre os detalhes internos desses objetos.
- Depois chamamos métodos (`incrementar` e `obterValor`) dos objetos para fazer o que precisamos.
  - Nesse ponto, assumimos que o método `incrementar` vai mudar corretamente o valor, **sem preocuparmos** com [como]{.alert} ele faz isso.

## {.smaller}

Em projetos reais, muitas vezes classes diferentes são feitas por pessoas diferentes.

- Se tivéssemos feito assim para o exemplo do visor de relógio, o que as duas pessoas precisariam entrar em acordo?
  - Precisariam concordar, apenas, sobre as **assinaturas de método** e [o que]{.alert} **os métodos fazem**.
  - Não seria necessário discutir **como** eles fazem.
- Feito isso, uma pessoa poderia implementar os métodos e a outra apenas os usaria.

. . .

O conjunto dos métodos (assinaturas) que um objeto disponibiliza para outros objetos é chamado de [interface]{.alert}.

- Esse conceito traz um poder enorme para a Orientação a Objetos.
- Você poderá conhecê-lo melhor e utilizar todo o seu poder na disciplina PPOO ;)

##

::: {.callout-note title="(Opcional) Exercício - [Desafio]{.alert}" icon=false}
Mude o relógio para que ele funcione como relógios americanos, mostrando 12 horas em vez de 24.

Repare que isso pode ser mais difícil do que parece, depois da meia-noite e do meio-dia, o relógio deve mostrar 12:30 e não 00:30.
Portanto, os minutos devem ir de 1 a 59, mas as horas devem ir de 1 a 12.
:::

::: {.callout-note title="(Opcional) Exercício - [Desafio]{.alert}" icon=false}
Há pelo menos duas formas de fazer o exercício anterior.
Você poderia armazenar as horas com valores entre 1 e 12.
Ou poderia deixar o relógio funcionando internamente com um relógio de 24 horas e tratar apenas a `stringVisor` para mostrar
horas no formato esperado de 12 horas.

Implemente as duas opções.

Qual opção é mais fácil? Qual é melhor? Por que?
:::

##

::: {.callout-note title="(Opcional) Exercício - [Desafio]{.alert}" icon=false}
Suponha que uma classe `Arvore` tenha um atributo do tipo `Triangulo` chamado `folhas` e um atributo do tipo `Quadrado` chamado `tronco`.
O construtor de `Arvores` não espera nenhum parâmetro, e seu construtor cria objetos `Triangulo` e `Quadrado` para seus atributos.

Usando o projeto [`figuras`](https://github.com/ufla-ipoo/casa), crie uma classe `Arvore` que corresponda a essa descrição.
Neste exercício, não é necessário definir nenhum método, e nem tratar a forma da árvore.
:::

::: {.callout-note title="(Opcional) Exercício - [Desafio]{.alert}" icon=false}
Agora complete a classe `Arvore` do exercício anterior.
O construtor deve mover o tronco para debaixo das folhas e fazer ambos serem exibidos.
Faça isso criando um método chamado `configurar` e incluindo uma chamada a este método no construtor.
Mude o tamanho do triângulo de forma que a árvore se pareça um pinheiro.
:::

# Entregas dessa Aula {background-color="#40666e"}

## {.smaller}

::: {.nonincremental}

Como você já sabe das aulas anteriores, para que você tenha a [presença]{.alert} 

- considerada nas aula em [formato ANP]{.alert} (Atividade Não-Presencial), 
- você precisa **demonstrar que** realmente **estudou** o conteúdo.

::: {.callout-important title="Entregas no Campus Virtual"}
Para ter presença nessa aula você deve:

- Responder, no Campus Virtual, aos quizes presentes nesses slides.
:::
:::