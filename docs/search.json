[
  {
    "objectID": "index.html#gac125---introdução-à-poo",
    "href": "index.html#gac125---introdução-à-poo",
    "title": "GAC125 - Introdução à Programação Orientada a Objetos",
    "section": "GAC125 - Introdução à POO",
    "text": "GAC125 - Introdução à POO\n\n\n\nVideoaulas: - Playlist no Youtube\nProjetos de exemplo: - Repositório no GitHub\nSlides\n\nPrimeira Aula\n\nApresentação da disciplina\n\nCapítulo 1\n\nAula 1.1 - Teórica\nAula 1.2 - Prática\n\nCapítulo 2\n\nAula 2.1 - Teórica\nAula 2.2 - Prática\nAula 2.3 - Teórica\nAula 2.4 - Prática\n\n\n\n\nCapítulo 3\n\nAula 3.1 - Teórica\nAula 3.2 - Prática\n\nCapítulo 4\n\nAula 4.1 - Teórica\nAula 4.2 - Prática (Tutorial do Greenfoot)\nAula 4.2 - Prática (exercício)\nAula 4.3 - Teórica\nAula 4.4 - Prática\n\n\n\n\nCapítulo 5\n\nAula 5.1 - Teórica\nAula 5.2 - Teórica\nAula 5.3 - Prática\n\nCapítulo 7\n\nAula 7.1 - Teórica\n\nCapítulo 6\n\nAula 6.1 - Teórica\nAula 6.1b - Teórica"
  },
  {
    "objectID": "clean-template/clean-template.html#example-slide",
    "href": "clean-template/clean-template.html#example-slide",
    "title": "Quarto reveal.js clean",
    "section": "Example slide",
    "text": "Example slide\nThis is a subtitle\nBefore we dive a bit deeper, here is a simple example of the clean theme in action.\n\nNo pictures or anything fancy. Just text for the moment.\n\nNext, we’ll take a brief tour of some theme components.\n\nWe’ll use the same basic structure as the original LaTeX slides.\nNote that the full suite of Reveal.js features are available for this Quarto implementation, even if we don’t cover everything here."
  },
  {
    "objectID": "clean-template/clean-template.html#before-you-proceed",
    "href": "clean-template/clean-template.html#before-you-proceed",
    "title": "Quarto reveal.js clean",
    "section": "Before you proceed…",
    "text": "Before you proceed…\nRequirements for the coding examples in this demo\n\n\n\n\n\n\nR libraries\n\n\nWhile the clean theme is language agnostic, we will use several R coding examples in this demo to highlight some advanced theme features.\nYou will need the following libraries if you’d like to render the template “as-is”:\ninstall.packages(c(\"modelsummary\", \"gt\", \"fixest\", \"pdftools\", \"tinytex\", \"threejs\"))\n\n\n\n\n\n\n\n\n\nTinyTex\n\n\nWhile reveal.js presentations are HTML format, we will show an example of how to embed LaTeX tables as images. This requires a working Tex distribution, of which TinyTex provides by far the easiest and lightest integration with Quarto. More details here.\nquarto install tinytex"
  },
  {
    "objectID": "clean-template/clean-template.html#components-1",
    "href": "clean-template/clean-template.html#components-1",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nOrdered and Unordered Lists\nHere we have an unordered list.\n\nfirst item\n\nsub-item\n\nsecond item\n\nAnd next we have an ordered one.\n\nfirst item\n\nsub-item\n\nsecond item"
  },
  {
    "objectID": "clean-template/clean-template.html#components-2",
    "href": "clean-template/clean-template.html#components-2",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nAlerts & Cross-refs\nTo emphasize specific words or text, you can:\n\nUse the default .alert class, e.g. important note.\nUse the .fg class for custom colour, e.g. important note.\nUse the .bg class for custom background, e.g. important note.\n\nTo cross-reference, you have several options, for example:\n\nBeamer-like .button class provided by this theme, e.g. Appendix\nQuarto’s native cross-ref syntax, e.g., “See Seção 4.3.”"
  },
  {
    "objectID": "clean-template/clean-template.html#components-3",
    "href": "clean-template/clean-template.html#components-3",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nCitations\nCitations follow the standard Quarto format and be sourced from BibLaTex, BibTeX, or CLS files. For example:\n\nTopic 1: Spatial Frictions (Fajgelbaum et al. 2018; Hsieh e Moretti 2019; Moretti 2011)\nTopic 2: Blah (Suárez Serrato e Zidar 2016)"
  },
  {
    "objectID": "clean-template/clean-template.html#components-4",
    "href": "clean-template/clean-template.html#components-4",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nBlocks\nQuarto provides dedicated environments for theorems, lemmas, and so forth.\nBut in presentation format, it’s arguably more effective just to use a Callout Block.\n\n\n\n\n\n\nRegression Specification\n\n\nThe main specification is as follows:\n\\[\ny_{it} = X_{it} \\beta + \\mu_i + \\varepsilon_{it}\n\\]"
  },
  {
    "objectID": "clean-template/clean-template.html#components-5",
    "href": "clean-template/clean-template.html#components-5",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nMulticolumn I: Text only\n\n\nColumn 1\nHere is a long sentence that will wrap onto the next line as it hits the column width, and continue this way until it stops.\n\nColumn 2\nSome other text in another column.\nA second paragraph.\n\nMulticolumn support is very flexible and we can continue with a single full span column in the same slide."
  },
  {
    "objectID": "clean-template/clean-template.html#components-6",
    "href": "clean-template/clean-template.html#components-6",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components\nMulticolumn II: Text and figures\n\n\n\n\n\nA point about the figure that is potentially important.\nAnother point about the figure that is also potentially important.\n\n\nNote that sub- and multi-panel figures are also natively supported by Quarto. See here."
  },
  {
    "objectID": "clean-template/clean-template.html#components-7",
    "href": "clean-template/clean-template.html#components-7",
    "title": "Quarto reveal.js clean",
    "section": "Components",
    "text": "Components"
  },
  {
    "objectID": "clean-template/clean-template.html#tables-1",
    "href": "clean-template/clean-template.html#tables-1",
    "title": "Quarto reveal.js clean",
    "section": "Tables",
    "text": "Tables\nRegression example\nQuarto offers excellent table support, with further customization via user libraries. Let’s illustrate with a regression example:"
  },
  {
    "objectID": "clean-template/clean-template.html#regression-table",
    "href": "clean-template/clean-template.html#regression-table",
    "title": "Quarto reveal.js clean",
    "section": "Regression table",
    "text": "Regression table\nmodelsummary\nIf you use modelsummary with this Quarto theme, we advise setting the gt backend for a cleaner aesthetic. More details here."
  },
  {
    "objectID": "clean-template/clean-template.html#regression-table-1",
    "href": "clean-template/clean-template.html#regression-table-1",
    "title": "Quarto reveal.js clean",
    "section": "Regression table",
    "text": "Regression table\netable\nfixest’s powerful native tabling functions were designed for LaTeX output. But we can use the markdown = TRUE option to make them work with this theme too. (Details here.) Quick notes:\n\nInstall the tinytex & pdftools packages first.\nSet the R chunk option output: asis."
  },
  {
    "objectID": "clean-template/clean-template.html#regression-table-2",
    "href": "clean-template/clean-template.html#regression-table-2",
    "title": "Quarto reveal.js clean",
    "section": "Regression table",
    "text": "Regression table\netable (cont.)"
  },
  {
    "objectID": "clean-template/clean-template.html#figure",
    "href": "clean-template/clean-template.html#figure",
    "title": "Quarto reveal.js clean",
    "section": "Figure",
    "text": "Figure"
  },
  {
    "objectID": "clean-template/clean-template.html#figure-1",
    "href": "clean-template/clean-template.html#figure-1",
    "title": "Quarto reveal.js clean",
    "section": "Figure",
    "text": "Figure\nFull-size Figures\nYou can use the {.background-image} container environment to completely fill the slide background with an image.\nIdeally, your figure will be the same aspect ratio as the screen that you’re presenting on.\n\nThis can be a bit tricky because of the dynamic nature of reveal.js / HTML. But it’s probably something close to 16:9.\nAspect ratio can also matter for a regular full-frame images (previous slide)."
  },
  {
    "objectID": "clean-template/clean-template.html#interactive-plots",
    "href": "clean-template/clean-template.html#interactive-plots",
    "title": "Quarto reveal.js clean",
    "section": "Interactive plots",
    "text": "Interactive plots\nNote: Simple flight data example using threejs. There are many interactive plotting options beyond this. (More details.)"
  },
  {
    "objectID": "clean-template/clean-template.html#summary-1",
    "href": "clean-template/clean-template.html#summary-1",
    "title": "Quarto reveal.js clean",
    "section": "Summary",
    "text": "Summary\nA minimal and elegant presentation theme\nThe Quarto reveal.js clean theme aims to be a minimal and elegant presention theme.\nWe have highlighted some theme-specific components. But all of the regular reveal.js functionality is supported (chalkboard, etc.)\nInstall the theme:\nquarto install extension grantmcdermott/quarto-revealjs-clean\nUse these demo slides as a template:\nquarto use template grantmcdermott/quarto-revealjs-clean-demo"
  },
  {
    "objectID": "clean-template/clean-template.html#references",
    "href": "clean-template/clean-template.html#references",
    "title": "Quarto reveal.js clean",
    "section": "References",
    "text": "References\n\n\nFajgelbaum, Pablo D, Eduardo Morales, Juan Carlos Suarez Serrato, e Owen Zidar. 2018. “State Taxes and Spatial Misallocation”, 90.\n\n\nHsieh, Chang-Tai, e Enrico Moretti. 2019. “Housing Constraints and Spatial Misallocation”. American Economic Journal: Macroeconomics 11 (2): 39.\n\n\nMoretti, Enrico. 2011. “Local Labor Markets”. Em Handbook of Labor Economics. Vol. 4. Elsevier.\n\n\nSuárez Serrato, Juan Carlos, e Owen Zidar. 2016. “Who Benefits from State Corporate Tax Cuts? A Local Labor Markets Approach with Heterogeneous Firms”. American Economic Review 106 (9)."
  },
  {
    "objectID": "clean-template/clean-template.html#sec-appendix",
    "href": "clean-template/clean-template.html#sec-appendix",
    "title": "Quarto reveal.js clean",
    "section": "Appendix",
    "text": "Appendix\nBack to main"
  },
  {
    "objectID": "cap5-3.html#section",
    "href": "cap5-3.html#section",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Na primeira parte desta aula, vamos usar o Greenfoot em vez do BlueJ.\n\nAproveitando o fato de que estamos usando o Greenfoot para o trabalho prático da disciplina.\n\n\nNós usaremos o projeto no Greenfoot para aprender conceitos que não foram vistos nas aulas teóricas anteriores:\n\nAtributos estáticos.\nMétodos estáticos.\nConstantes."
  },
  {
    "objectID": "cap5-3.html#section-1",
    "href": "cap5-3.html#section-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Para começar, baixe o projeto bolas-quicando.\n\nAbra o projeto no Greenfoot.\nExecute o programa e veja o que acontece.\n\n\nVamos aproveitar esse projeto para conhecer um pouco mais sobre o Greenfoot."
  },
  {
    "objectID": "cap5-3.html#section-3",
    "href": "cap5-3.html#section-3",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Vamos agora avaliar o código da classe Bola.\n\nVamos tentar entender como a classe funciona.\n\n\nPara isso, é útil conhecermos alguns métodos diponíveis do Greenfoot:\n\ngetImage: retorna a imagem usada para o objeto (definida na hora que criamos a classe).\ngetImage().scale: permite mudar a dimensão da imagem do objeto.\nsetLocation: muda a posição do ator no mundo (coordenadas X e Y).\nisTouching: indica se o ator está colidindo com algum objeto da classe passada.\n\n\n\nLeia o código da classe Bola e tente entender como ela funciona."
  },
  {
    "objectID": "cap5-3.html#section-4",
    "href": "cap5-3.html#section-4",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Ao avaliar o código da classe Bola você viu alguma palavra-chave nova do Java?\n\nRepare a declaração do atributo GRAVIDADE.\n\n\n\n\n\n\nExercício\n\n\nExperimente alterar o valor do atributo GRAVIDADE (aumentando e diminuindo seu valor).\nExecute o programa e veja o que acontece de diferente.\n\n\n\n\n\n\nO atributo GRAVIDADE é declarado da seguinte forma:\n\n    private static final double GRAVIDADE = 0.7;\n\n\n\nHá duas palavras-chave novas nessa declaração: static e final"
  },
  {
    "objectID": "cap5-3.html#atributos-estáticos",
    "href": "cap5-3.html#atributos-estáticos",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos estáticos",
    "text": "Atributos estáticos\nA palalavra-chave static do Java serve para declarar atributos estáticos.\n\nAtributos desse tipo são guardados na própria classe, não nos objetos.\n\nEle são também chamados de variáveis de classe.\n\nIsso torna esses atributos muito diferentes dos atributos comuns que vimos até agora.\n\nLembrando que os atributos comuns são também chamados de variáveis de instância."
  },
  {
    "objectID": "cap5-3.html#section-5",
    "href": "cap5-3.html#section-5",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O diagrama abaixo ilustra bem a diferença entre os atributos comuns e estáticos."
  },
  {
    "objectID": "cap5-3.html#section-6",
    "href": "cap5-3.html#section-6",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Os atributos comuns (velocidadeVertical, posY e amortecimento) são guardados nos objetos:\n\nComo criamos três objetos, há três espaços na memória para cada um desses atributos.\n\n\nJá o atributo estático GRAVIDADE é guardado na classe:\n\nCom isso, existe sempre um único espaço na memória para ele, independente da quantidade de objetos criados."
  },
  {
    "objectID": "cap5-3.html#section-7",
    "href": "cap5-3.html#section-7",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Os atributos estáticos podem ser acessados normalmente dentro de qualquer método da classe.\n\nIsso significa que todos os objetos compartilham o mesmo atributo.\nSe um objeto alterar o valor do atributo estático, esse valor será usado para todos os objetos.\n\nJá que existe um único valor na memória.\n\n\n\nGeralmente usamos atributos estáticos quando todos os objetos da classe devem ter o mesmo valor para o atributo.\n\nCom isso, evitamos desperdiçar memória guardando o mesmo valor repetidas vezes para cada objeto."
  },
  {
    "objectID": "cap5-3.html#section-9",
    "href": "cap5-3.html#section-9",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "É mais comum usarmos constantes quando elas têm o mesmo valor para todos os objetos.\n\nPortanto, é mais comum ter constantes estáticas, do que como atributos comuns.\nComo é o caso do atributo GRAVIDADE da classe Bola."
  },
  {
    "objectID": "cap5-3.html#métodos-estáticos",
    "href": "cap5-3.html#métodos-estáticos",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Métodos estáticos",
    "text": "Métodos estáticos\nTodos os métodos que vimos até agora são métodos de instância (de objetos).\n\nPois eles são chamados usando objetos.\n\n\nMas nós podemos também ter métodos que são chamados usando a classe, em vez de objetos.\n\nSão os métodos estáticos.\nAssim como os atributos estáticos, os métodos estáticos pertencem à classe e não aos objetos."
  },
  {
    "objectID": "cap5-3.html#métodos-estáticos-1",
    "href": "cap5-3.html#métodos-estáticos-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Métodos estáticos",
    "text": "Métodos estáticos\nNós podemos definir métodos estáticos usando a palavra-chave static na assinatura do método.\n\nSuponha, por exemplo, que uma classe Calendario tenha o método estático abaixo:\n\n    public static int obterNumeroDeDiasDoMesAtual() {\n        . . .\n    }\n\n\n\nNós poderíamos chamar esse método usando o comando abaixo:\n\nRepare que usamos o nome da classe antes do . para chamar o método, em vez de usar um objeto.\n\n\n    int dias = Calendario.obterNumeroDeDiasDoMesAtual();"
  },
  {
    "objectID": "cap5-3.html#métodos-estáticos-2",
    "href": "cap5-3.html#métodos-estáticos-2",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Métodos estáticos",
    "text": "Métodos estáticos\nPodemos encontrar vários exemplos de métodos estáticos na classe Math do Java.\n\nEla possui métodos, por exemplo, para encontrar o máximo ou o mínimo entre dois números.\n\nOu ainda calcular seno e cosseno, por exemplo.\n\n\n\n\n    int maximo = Math.max(numeroA, numeroB);\n    double valor = Math.cos(angulo);\n\n\n\nRepare que esses métodos dependem apenas dos parâmetros passados.\n\nEles não dependem de atributos de um possível objeto Math, ou seja, não dependem do estado de um objeto.\nGeralmente é nesses casos que usamos métodos estáticos."
  },
  {
    "objectID": "cap5-3.html#section-11",
    "href": "cap5-3.html#section-11",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Todos os métodos que implementamos até agora são métodos de instância (de objetos).\n\nPois eles são chamados usando objetos.\n\n\nMas nós podemos também ter métodos que são chamados usando a classe, em vez de objetos.\n\nSão os métodos estáticos.\nAssim como os atributos estáticos, os métodos estáticos pertencem à classe e não aos objetos."
  },
  {
    "objectID": "cap5-3.html#limitações-dos-métodos-estáticos",
    "href": "cap5-3.html#limitações-dos-métodos-estáticos",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Limitações dos métodos estáticos",
    "text": "Limitações dos métodos estáticos\nÉ importante sabermos que os métodos estáticos (métodos de classe) têm limitações.\n\nComo eles pertencem à classe e não aos objetos, eles não podem acessar atributos comuns (variáveis de instância).\nEles podem acessar apenas atributos estáticos (variáveis de classe).\n\n\nDa mesma forma, métodos estáticos não podem chamar métodos de instância da mesma classe.\n\nPodem chamar apenas outros métodos estáticos."
  },
  {
    "objectID": "cap5-3.html#limitações-dos-métodos-estáticos-1",
    "href": "cap5-3.html#limitações-dos-métodos-estáticos-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Limitações dos métodos estáticos",
    "text": "Limitações dos métodos estáticos\nPor que você acha que essas limitações existem?\n\nImagine que um método estático qualquer (vamos chamar de metodoA), de uma classe ClasseX acessasse um atributo comum.\nTente imaginar o que aconteceria se você fizesse uma chamada ClasseX.metodoA() sem ter criado nenhum objeto da classe.\n\nE se existissem vários objetos da classe?\n\n\n\nE o que isso tem a ver com um método estático não poder chamar um método de instância?"
  },
  {
    "objectID": "cap5-1.html#section",
    "href": "cap5-1.html#section",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Os tópicos abaixo te lembram alguma coisa? :)\n\nPraticar enquanto estuda.\nLer o capítulo do livro.\nAnotar conceitos e dúvidas."
  },
  {
    "objectID": "cap5-1.html#principais-conceitos-do-capítulo",
    "href": "cap5-1.html#principais-conceitos-do-capítulo",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Principais Conceitos do Capítulo",
    "text": "Principais Conceitos do Capítulo\n\n\nEncapsulamento\nAtributos e métodos estáticos\nConstantes\nUso de classes de biblioteca\nDocumentação de classes\n\n\n\nConstruções Java do capítulo\n\n\nString, Random, static, final, autoboxing, classes empacotadoras."
  },
  {
    "objectID": "cap5-1.html#section-2",
    "href": "cap5-1.html#section-2",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O conceito de encapsulamento é fundamental na Programação Orientada a Objetos.\n\nE será apresentado no final do capítulo.\nNão deixe de estudar esse conteúdo!!!"
  },
  {
    "objectID": "cap5-1.html#section-3",
    "href": "cap5-1.html#section-3",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "No capítulo anterior conhecemos a classe ArrayList da biblioteca de classes do Java.\n\nCom ela, ficou mais fácil fazer programas para guardar uma quantidade qualquer de objetos.\nO que sem ela seria bem mais complicado.\n\n\nMas ela é apenas um exemplo de classe da biblioteca.\n\nExistem muitas que serão muito úteis em nossos softwares.\nE outras que, possivelmente, nunca usaremos.\n\n\n\nUm bom programador Java precisa conseguir trabalhar com as classes da biblioteca.\n\nE saber quando utilizar cada uma.\nDe forma a tornar a implementação de um programa mais fácil."
  },
  {
    "objectID": "cap5-1.html#section-4",
    "href": "cap5-1.html#section-4",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Muitas classes da biblioteca têm certas características comuns entre si.\n\nEspecialmente as coleções, são classes que compartilham muitos atributos.\nE, usando a abstração, podemos tratar de classes de coleções de uma maneira mais geral.\n\n\nNeste capítulo, vamos trabalhar com um sistema de Suporte Técnico.\n\nComeçaremos com uma versão rudimentar.\nE ela será melhorado, incrementalmente, utilizando diferentes classes da biblioteca Java."
  },
  {
    "objectID": "cap5-1.html#section-6",
    "href": "cap5-1.html#section-6",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A biblioteca de classes do Java tem centenas de classes, com muitas opções de métodos.\n\nSerá que um bom programador precisa conhecer todas elas de cor?\n\n\nNa verdade, um bom programador deveria:\n\nConhecer pelo nome as classes mais importantes e seus métodos (ArrayList é uma delas).\nSaber como encontrar informações das demais classes (tais como métodos e parâmetros)."
  },
  {
    "objectID": "cap5-1.html#section-7",
    "href": "cap5-1.html#section-7",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O livro da disciplina recomenda que um programador conheça a documentação do Java para essas classes.\n\nA documentação é formada por páginas HTML bem detalhadas sobre todas as classes da biblioteca.\nMas para quem não é fluente em inglês, isso pode gerar uma barreira inicial.\n\nPortanto, uma sugestão é usar também outras fontes para saber como usar as classes (como buscas no Google ou o ChatGPT).\n\n\n\nDe toda forma, à medida que você fique mais experiente, saber usar a documentação pode ser muito útil.\n\nEssa é uma das coisas que separam o programador juninho do bom programador."
  },
  {
    "objectID": "cap5-1.html#section-8",
    "href": "cap5-1.html#section-8",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Um ponto importante sobre o uso da classe ArrayList é que nós já a utilizamos sem nunca termos visto o código da classe.\n\nNós não conferimos como ela foi implementada.\nE isso não foi necessário para utilizarmos suas funcionalidades.\n\n\nTudo o que precisamos saber é:\n\nO nome da classe.\nAs assinaturas dos seus métodos (nomes, parâmetros e tipos de retorno).\nE o que exatamente esses métodos fazem."
  },
  {
    "objectID": "cap5-1.html#section-9",
    "href": "cap5-1.html#section-9",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A mesma coisa acontece em projetos de software grandes de uma empresa.\n\nGeralmente, várias pessoas trabalham em diferentes partes do sistema.\nCada programador deveria se concentrar em sua parte, sem ter que entender detalhes das outras partes.\n\nComo discutimos ao falar sobre abstração e modularização.\n\n\n\nNa verdade, cada programador deveria:\n\nConseguir usar as classes das outras equipes como se elas fossem classes de biblioteca.\nSabendo o que elas fazem, mas sem precisar saber como elas funcionam internamente.\n\n\n\nMas, para isso funcionar, cada membro de equipe deveria documentar sua classe assim como é feito para as classes da biblioteca\n\nPermitindo que outros programadores usem a classe sem precisar ler o código.\nVeremos como fazer isso na próxima aula."
  },
  {
    "objectID": "cap5-1.html#section-10",
    "href": "cap5-1.html#section-10",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A ideia do sistema de Suporte Técnico é que ele seja um chat de atendimento aos clientes.\n\nde uma empresa fictícia, chamada DesonestosSistemas.\n\n\nAntigamente a empresa tinha funcionários que faziam atendimento por telefone.\n\nMas ela passou por problemas financeiros e demitiu a equipe.\n\nE não tem dinheiro para criar um chatbot de verdade.\n\nE agora ela quer criar um sistema de suporte para dar a impressão que ela atende os clientes.\nA ideia é que o sistema imite o atendimento que uma pessoa faria ao telefone."
  },
  {
    "objectID": "cap5-1.html#section-11",
    "href": "cap5-1.html#section-11",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Vamos começar com uma versão bem rudimentar do sistema, disponível no projeto suporte-tecnico1.\n\nA ideia é que, ao longo da aula, possamos melhorar o sistema.\nE, ao longo do processo, vamos aprender diversos conceitos."
  },
  {
    "objectID": "cap5-1.html#section-12",
    "href": "cap5-1.html#section-12",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nExperimente a versão rudimentar do sistema de suporte técnico.\nCrie um objeto da classe SistemaDeSuporte e chame o método iniciar. Experimente conversar com o sistema pelo terminal e repare como é atendido.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nPara conhecermos melhor o projeto, crie um objeto da classe LeitorDeEntrada e experimente seu(s) método(s).\nFaça o mesmo com um objeto da classe Respondedor.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAgora leia o código da classe SistemaDeSuporte e tente entender como ela funciona."
  },
  {
    "objectID": "cap5-1.html#section-13",
    "href": "cap5-1.html#section-13",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Você deve ter notado que o sistema é realmente muito rudimentar.\n\nA classe LeitorDeEntrada basicamente retorna uma string digitada pelo usuário no terminal.\nA classe Respondedor tem um método que sempre retorna a mesma resposta.\nJá a classe SistemaDeSuporte tem um objeto de cada uma das duas classes anteriores.\n\nE um loop while que, repetidamente, obtém um texto do usuário e exibe uma resposta.\nIsso é repetido até que o usuário digite qualquer string que comece com tchau."
  },
  {
    "objectID": "cap5-1.html#section-14",
    "href": "cap5-1.html#section-14",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Experimente usar o sistema de suporte técnico e digitar \"Tchau\" ou \" tchau\" (com espaço) para sair.\n\nO que acontece?\nPara o usuário isso é muito chato, certo?\n\nMas nós podemos usar a documentação da classe String para melhorar isso.\n\n\n\nA classe String é uma das classes da biblioteca padrão do Java.\n\nNós podemos acessar a documentação da classe, no BlueJ, no menu Ajuda → Biblioteca de classes do Java.\nSerá aberta a documentação online do Java no seu navegador web.\n\nNa parte superior direita há uma caixa de busca.\nDigite string e escolha primeira opção (java.lang.String)."
  },
  {
    "objectID": "cap5-1.html#section-15",
    "href": "cap5-1.html#section-15",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nAbra a documentação de alguma outra classe do Java e compare a estrutura da documentação das duas classes. O que as páginas têm em comum?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nProcure pelo método startsWith na documentação da classe String. Veja que o método é sobrecarregado, há duas versões.\nEscreva com suas palavras o que as duas versões fazem e a diferença entre eles.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nHá algum método na classe String que retorna quantos caracteres ela tem? Como o método se chama e quais são seus parâmetros?"
  },
  {
    "objectID": "cap5-1.html#section-16",
    "href": "cap5-1.html#section-16",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nProcure se existe algum método na classe String que verifica se uma string termina com um dado sufixo. Se existir, como o método se chama, e quais são seus parâmetros e tipo de retorno?"
  },
  {
    "objectID": "cap5-1.html#interface-vs.-implementação",
    "href": "cap5-1.html#interface-vs.-implementação",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Interface vs. Implementação",
    "text": "Interface vs. Implementação\nVocê deve ter notado que a documentação tem diferentes tipos de informação:\n\no nome da classe;\numa descrição geral do objetivo da classe;\numa lista dos construtores e métodos da classe;\nos parâmetros e tipos de retorno de cada construtor e cada método;\ne uma descrição do objetivo de cada construtor e cada método.\n\n\nTodas essas informações formam o que chamamos de interface de uma classe.\n\nRepare que que a interface não mostra o código que implementa a classe.\nSe uma classe é bem descrita (ou seja, sua interface é bem escrita),\n\num programador não precisa ver o código da classe para conseguir utilizá-la.\n\nA interface já tem toda a informação que ele precisa.\n\n(olha a abstração aí de novo!)"
  },
  {
    "objectID": "cap5-1.html#section-17",
    "href": "cap5-1.html#section-17",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O código que não vemos, que é o que faz a classe funcionar, é chamado de implementação da classe.\n\nGeralmente um programador trabalha na implementação de uma classe de cada vez,\n\ne, para isso, usa várias outras classes através de suas interfaces.\n\n\n\nEssa diferenciação entre interface e implementação é um conceito muito importante.\n\nE vamos ver isso repetidamente nessa disciplina (e em disciplinas avançadas de POO).\n\n\n\n\n\n\n\nNota\n\n\nA palavra interface tem diferentes significados em POO. Pode se referir a parte pública visível de uma classe (que é o que acabamos de aprender). Mas pode também se referir a interface gráfica de usuário ou a um tipo especial de classe que você conhecerá se puxar PPOO como eletiva :)"
  },
  {
    "objectID": "cap5-1.html#section-18",
    "href": "cap5-1.html#section-18",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós também podemos falar de interface de um método específico.\n\nVeja, por exemplo, a documentação do método length da classe String."
  },
  {
    "objectID": "cap5-1.html#section-19",
    "href": "cap5-1.html#section-19",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A interface de um método consiste em sua assinatura e um comentário. E a assinatura de um método contém:\n\nUm modificador de acesso (public, nesse caso).\nO tipo de retorno do método (int, nesse caso).\nO nome do método.\nUma lista de parâmetros (vazia, nesse caso).\n\n\nRepare que a interface do método tem tudo que precisamos saber para conseguirmos usá-lo."
  },
  {
    "objectID": "cap5-1.html#section-20",
    "href": "cap5-1.html#section-20",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Conceito\n\n\nA interface de uma classe descreve o que a classe faz e como ela pode ser usada sem mostrar a implementação.\n\n\n\n\n\n\n\n\nConceito\n\n\nO código-fonte completo que define uma classe é chamado de implementação da classe."
  },
  {
    "objectID": "cap5-1.html#usando-métodos-de-classes-da-biblioteca",
    "href": "cap5-1.html#usando-métodos-de-classes-da-biblioteca",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Usando métodos de classes da biblioteca",
    "text": "Usando métodos de classes da biblioteca\nEm nosso sistema de suporte, já vimos que o sistema não aceita que o usuário digite \"Tchau\" ou \" tchau\".\n\nVamos melhorar isso de forma que todas essas variações sejam reconhecidas como \"tchau\".\n\n\n\n\n\n\nExercício\n\n\nEncontre o método trim na documentação da classe String. Escreva com suas palavras o que ele faz, e como ele poderia ser chamado usando uma variável String chamada texto."
  },
  {
    "objectID": "cap5-1.html#section-21",
    "href": "cap5-1.html#section-21",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Um importante detalhe sobre objetos String em Java, é que eles são imutáveis.\n\nIsso significa que esses objetos não podem ser alterados depois de criados.\nRepare que o método trim, por exemplo, retorna uma nova String.\n\nEle não modifica a String original.\n\n\n\n\n\n\n\nÉ um erro comum em Java, tentar alterar uma String usando chamadas como:\ntexto.toUpperCase();\nEssa chamada não provoca nenhum erro, mas também não causa nenhum efeito. Isso porque o método retorna uma nova String, ele não altera a original.\nPortanto, se queremos alterar a variável texto, precisamos descartar o objeto String original, atribuindo à variável texto a nova String gerada:\ntexto = texto.toUpperCase();"
  },
  {
    "objectID": "cap5-1.html#section-22",
    "href": "cap5-1.html#section-22",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Pelo que você leu sobre o método trim na documentação, como podemos usá-lo no sistema de suporte?\n\nVocê deve ter visto que podemos usá-lo para remover espaços no início e no final da string.\n\n\nO código da classe SistemaDeSuporte poderia ser então alterado da seguinte forma:\n\n    String entrada = leitor.obterEntrada();\n    entrada = entrada.trim();\n    if(entrada.startsWith(\"tchau\")) {\n        terminou = true;\n    }\n    else {\n        String resposta = respondedor.generateResponse();\n        System.out.println(resposta);\n    }"
  },
  {
    "objectID": "cap5-1.html#section-23",
    "href": "cap5-1.html#section-23",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Você acha que haveria diferença entre escrever essas duas linhas de código:\n\n    String entrada = leitor.obterEntrada();\n    entrada = entrada.trim();\n\nou escrever assim?\n\n    String entrada = leitor.obterEntrada().trim();\n\n\nO efeito é exatamente o mesmo.\n\nVocê pode escolher a forma que acha mais fácil de entender.\nVeja que na segunda opção, a ordem de execução é como se existissem os parênteses como mostrado abaixo.\n\n\n\n\n  String entrada = (leitor.obterEntrada()).trim();"
  },
  {
    "objectID": "cap5-1.html#section-24",
    "href": "cap5-1.html#section-24",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Conceito\n\n\nUm objeto é chamado imutável se seu conteúdo ou estado não pode ser alterado depois que ele foi criado. Strings são exemplos de objetos imutáveis.\n\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nImplemente a alteração na classe SistemaDeSuporte usando o método trim da classe String. Teste a alteração digitando espaço antes da palavra tchau."
  },
  {
    "objectID": "cap5-1.html#section-25",
    "href": "cap5-1.html#section-25",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\nO exercício anterior ainda não resolveu o problema do usuário digitar \"Tchau\" com letra maiúscula.\nVeja na documentação da classe String como funciona o método toLowerCase e o utilize de forma que o programa saia independente do usuário digitar tchau com letras maiúsculas ou minúsculas.\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nEncontre o método equals na documentação da classe String. Utilize o método equals em vez do método startsWith na implementação da classe SuporteTecnico"
  },
  {
    "objectID": "cap5-1.html#section-26",
    "href": "cap5-1.html#section-26",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Lembre-se que, como já foi dito em aulas práticas anteriores, não podemos comparar objetos String em Java utilizando o operador ==.\n\nUsando o operador estamos verificando se é o mesmo objeto, e não se os dois objetos têm o mesmo conteúdo.\nPara comparar se dois objetos String têm o mesmo conteúdo, devemos utilizar o método equals."
  },
  {
    "objectID": "cap5-1.html#section-27",
    "href": "cap5-1.html#section-27",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "No início da disciplina, nós utilizamos um objeto da classe Random no exercício da Nave para acrescentar aleatoriedade em nosso jogo.\n\nNós podemos agora utilizar a mesma classe para mudar o comportamento do Respondedor do nosso sistema de suporte.\nA ideia é que o sistema exiba respostas aleatórias, em vez de sempre responder a mesma coisa.\n\n\nNós podemos fazer isso, alterando a classe Respondedor seguindo os passos abaixo:\n\ndeclarando um atributo do tipo Random para guardar um gerador de números aleatórios;\ndeclarando um atributo do tipo ArrayList para guardar nossas possíveis respostas;\ncriando os objetos Random e ArrayList no construtor da classe Respondedor;\npreenchendo a lista com algumas frases de resposta;\nselecionando e retornando uma frase aleatória quando o método gerarResposta é chamado."
  },
  {
    "objectID": "cap5-1.html#section-28",
    "href": "cap5-1.html#section-28",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\nMelhore a classe Respondedor de forma que ela gere respostas aleatórias como descrito no slide anterior.\nVeja que, para gerar respostas aleatórias, basta sortearmos uma posição do ArrayList e usarmos essa posição para obter uma mensagem. Podemos sortear uma posição usando o método nextInt da classe Random, e o método size da classe ArrayList.\n\nDicas:\n\nVeja no próximo slide alguns exemplos de frase de resposta (mas não precisam ser exatamente essas, use sua criatividade!).\nReveja o exercício da Nave para se lembrar como usar a classe Random.\nLeia a seção 5.4 do livro da disciplina."
  },
  {
    "objectID": "cap5-1.html#section-29",
    "href": "cap5-1.html#section-29",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exemplos de frases de resposta do sistema de suporte técnico:\n\n\"Isso parece estranho. Você poderia descrever com mais detalhes?\"\n\"Nenhum outro cliente reclamou disso antes. Qual é a configuração do seu sistema?\"\n\"Poderia me dar mais informações sobre o problema?\"\n\"Isso é abordado no manual. Você já leu o manual?\"\n\"Sua descrição é um pouco ruim. Você tem um especialista com você que poderia descrever isso melhor?\"\n\"Isso não é um bug, é uma funcionalidade!\"\n\"Você poderia detalhar melhor isso?\"\n\"Você já tentou executar o aplicativo no seu telefone?\"\n\"Já verifiquei no StatckOverflow e ChatGPT e nem eles sabem como responder :(\""
  },
  {
    "objectID": "cap5-1.html#section-30",
    "href": "cap5-1.html#section-30",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nosso sistema ficou mais dinâmico, mas ainda é muito ruim, pois as respostas são independentes do que o usuário escreve.\n\nNós podemos melhorar um pouco isso, fazendo algo pelo menos próximo do que o usuário perguntou.\nO livro apresenta uma solução usando a classe HashMap já aqui.\n\nMas vamos tratar essa classe na próxima aula teórica.\nEntão vamos implementar aqui primeiro uma solução com blocos if e else para ter um resultado similar.\n\n\n\nA ideia é identificar alguma palavra-chave na pergunta feita pelo usuário.\n\ne fornecer uma resposta que tenha algo a ver com essa palavra-chave."
  },
  {
    "objectID": "cap5-1.html#section-31",
    "href": "cap5-1.html#section-31",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Por exemplo, suponha que na pergunta do usuário apareça a palavra \"lento\".\n\nA resposta poderia ser então algo como:\n\n\n\n\"Acredito que isso tem a ver com o seu hardware. \" +\n\"Atualizar seu processador deve resolver todos os problemas de desempenho. \" + \n\"Você tem algum problema com nosso software?\"\"\n\n\n\nJá se na pergunta do usuário aparecer a palava \"bug\", a resposta poderia ser:\n\n\n\n\"Bem, você sabe, todo software tem alguns bugs. \" +\n\"Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. \" +\n\"Você pode descrever o problema com mais detalhes?\"\n\n\n\nComo podemos implementar isso?"
  },
  {
    "objectID": "cap5-1.html#section-32",
    "href": "cap5-1.html#section-32",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Atenção:\n\nO próximo exercício pede para alterar o método gerarResposta da classe Respondedor.\nMas para que o professor consiga corrigir seu exercício anterior (de respostas aleatórias) você não pode apagar o código que tinha feito antes.\n\nPortanto, ao fazer o próximo exercício deixe o código anterior comentado em vez de apagá-lo."
  },
  {
    "objectID": "cap5-1.html#section-33",
    "href": "cap5-1.html#section-33",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\n\nVamos implementar a ideia discutida nos slides anteriores. Neste exercício, faça o seguinte:\n\nAltere o método gerarResposta da classe Respondedor para que ele receba por parâmetro a pergunta feita pelo usuário.\n\nVocê precisará, claro, alterar a chamada do método na classe SistemaDeSuporte para passar a entrada do usuário.\n\nNo método gerarResposta, faça uma sequência de if/else if para verificar se as palavras-chave existem na pergunta do usuário.\n\nPara isso, você pode usar o método contains da classe String.\nE no bloco de cada if, retornar um texto correspondente àquela palavra-chave (veja sugestões no próximo slide).\nExemplo:\n\n\n    if (entrada.contains(\"lento\")) {\n        return \"Acredito que isso tem a ver com o seu hardware. \" +\n               \"Atualizar seu processador deve resolver todos os \" +\n               \"problemas de desempenho. Você tem algum problema \" + \n               \"com nosso software?\"\n    }\n    else if (entrada.contains(\"bug\")) {\n        ..."
  },
  {
    "objectID": "cap5-1.html#section-34",
    "href": "cap5-1.html#section-34",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Palavra-chave\nSugestão de resposta\n\n\n\n\n“travou”\n“Bem, nunca trava em nosso sistema. Deve ter algo a ver com o seu sistema. Conte mais sobre sua configuração.”\n\n\n“travando”\n“Bem, nunca trava em nosso sistema. Deve ter algo a ver com o seu sistema. Conte mais sobre sua configuração.”\n\n\n“lento”\n“Acredito que isso tem a ver com o seu hardware. Atualizar seu processador deve resolver todos os problemas de desempenho. Você tem algum problema com nosso software?”\n\n\n“desempenho”\n“O desempenho foi bastante adequado em todos os nossos testes. Você está executando outros processos em segundo plano?”\n\n\n“bug”\n“Bem, você sabe, todo software tem alguns bugs. Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. Você pode descrever o problema com mais detalhes?”\n\n\n“erro”\n“Bem, você sabe, todo software tem alguns bugs. Mas nossos engenheiros de software estão trabalhando muito para corrigi-los. Você pode descrever o problema com mais detalhes?”\n\n\n“windows”\n“Este é um bug conhecido relacionado ao sistema operacional Windows. Por favor, informe à Microsoft. Não há nada que possamos fazer a respeito.”\n\n\n“mac”\n“Este é um bug conhecido relacionado ao sistema operacional Mac. Por favor, informe à Apple. Não há nada que possamos fazer a respeito.”\n\n\n“caro”\n“O custo de nosso produto é bastante competitivo. Você deu uma olhada e realmente comparou nossos recursos?”\n\n\n“instalação”\n“A instalação é realmente bastante simples. Temos muitos assistentes que fazem todo o trabalho para você. Você leu as instruções de instalação?”\n\n\n“memória”\n“Se você ler atentamente os requisitos do sistema, verá que os requisitos de memória especificados são de 6 gigabytes. Você realmente deve atualizar sua memória. Mais alguma coisa que você gostaria de saber?”\n\n\n“linux”\n“Levamos o suporte ao Linux muito a sério. Mas há alguns problemas. A maioria está relacionada a versões incompatíveis do glibc. Você pode ser um pouco mais preciso?”\n\n\n“bluej”\n“Ah, o BlueJ, sim. Tentamos comprá-los há muito tempo, mas eles simplesmente não vendem… São pessoas teimosas. Não há nada que possamos fazer a respeito, desculpe.”"
  },
  {
    "objectID": "cap5-1.html#section-35",
    "href": "cap5-1.html#section-35",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós vimos que um ArrayList consegue guardar qualquer tipo de objeto.\n\nMas como int não é um objeto, não é possível usar um ArrayList para guardar uma lista de números inteiros?\n\n\nIsso é possível através das classes empacotadoras (wrapper classes).\n\nCada tipo primitivo em Java tem uma classe empacotadora que representa o mesmo tipo,\n\nMas que é um objeto de verdade.\n\nA classe empacotadora para int, por exemplo, se chama Integer."
  },
  {
    "objectID": "cap5-1.html#section-36",
    "href": "cap5-1.html#section-36",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós poderíamos criar explicitamente um objeto do tipo Integer:\n\n    int n = 10;\n    Integer objetoInt = new Integer(n);\n\n\nE poderíamos então declarar um ArrayList&lt;Integer&gt; e guardar nele o objetoInt.\n\nMas, na verdade, nós nunca fazemos isso, pois podemos guardar valores de tipo primitivo no ArrayList!\nIsso porque sempre que um valor de tipo primitivo é usado em um contexto que requer um tipo empacotador (wrapper),\n\no compilador converte o valor automaticamente em um objeto empacotador correspondente.\nEssa funcionalidade se chama autoboxing (algo como, auto-empacotamento)."
  },
  {
    "objectID": "cap5-1.html#section-37",
    "href": "cap5-1.html#section-37",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Portanto, na prática, podemos escrever código como mostrado abaixo:\n\n    private ArrayList&lt;Integer&gt; notas;\n    ...\n    public void guardarNotasNaLista(int nota) {\n        notas.add(nota);\n    }\n\n\nRepare que estamos guardando o valor da variável nota, do tipo int, em um ArrayList&lt;Integer&gt;."
  },
  {
    "objectID": "cap5-1.html#section-38",
    "href": "cap5-1.html#section-38",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Seguindo a mesma ideia, o compilador realiza o unboxing quando obtemos um valor da coleção:\n\n    int primeiraNota = notas.get(0);\n\n\nVeja portanto que, em termos práticos, a única coisa que precisamos lembrar é de declarar o ArrayList usando a classe empacotadora (como a Integer).\n\nMas na hora de usar o ArrayList podemos tratar todos os dados como se fossem do tipo int."
  },
  {
    "objectID": "cap5-1.html#section-39",
    "href": "cap5-1.html#section-39",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Veja no Apêndice B do livro uma lista completa dos tipos primitivos e suas classes empacotadoras.\n\nVale ressaltar também que o mesmo conceito é aplicado para as demais coleções, como a classe HashMap.\n\n\n\n\n\n\nConceito\n\n\nAutoboxing é realizado automaticamente quando um valor de tipo primitivo é usado em um contexto que requer um tipo empacotador (wrapper)."
  },
  {
    "objectID": "cap5-1.html#público-vs.-privado",
    "href": "cap5-1.html#público-vs.-privado",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Público vs. Privado",
    "text": "Público vs. Privado\nVocês já notaram que usamos a todo momento as palavras-chave public e private em nossos programas em Java, como mostrado no exemplo abaixo:\n\n    // declaração de atributos\n    private int numeroDeAssentos;\n\n    // métodos\n    public void definirIdade(int novaIdade) {\n      ...\n    }\n    \n    private int calcularMedia() {\n      ...\n    }\n\n\nChegou a hora de entendermos para que essas palavras-chaves servem."
  },
  {
    "objectID": "cap5-1.html#section-40",
    "href": "cap5-1.html#section-40",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós chamamos essas palavras-chave de modificadores de acesso.\n\nelas definem a visibilidade de atributos, construtores e métodos.\n\n\nSe um método, por exemplo, é público:\n\nEle pode ser chamado de dentro da mesma classe e também a partir de outra classe.\n\n\n\nJá métodos privados, por outro lado,\n\nSó podem ser chamados de dentro da mesma classe onde foram declarados.\nEles não são visíveis para as outras classes."
  },
  {
    "objectID": "cap5-1.html#section-41",
    "href": "cap5-1.html#section-41",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Como agora já conhecemos os conceitos de interface e implementação fica mais fácil entendermos o objetivo dessas palavras-chave.\n\nLembre-se que a interface de uma classe é o conjunto de detalhes que um programador que vai usar a classe precisa ver.\n\nEla fornece informações sobre como usar a classe.\n\nE inclui assinaturas e comentários de construtores e métodos.\n\nNós também dizemos que a interface é a parte pública da classe.\nSeu objetivo é definir o que a classe faz."
  },
  {
    "objectID": "cap5-1.html#section-42",
    "href": "cap5-1.html#section-42",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Já a implementação é a parte da classe que define precisamente como a classe funciona.\n\nOs corpos dos métodos, contendo comandos Java, e muitos atributos são parte da implementação.\nNós também podemos dizer que ela é a parte privada da classe.\nQuem usa a classe não precisa conhecer a implementação.\nInclusive, há boas razões para que o programador não possa fazer uso desse conhecimento (como veremos mais adiante)."
  },
  {
    "objectID": "cap5-1.html#section-43",
    "href": "cap5-1.html#section-43",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Portanto, podemos dizer que:\n\nA palavra-chave public declara que um elemento de uma classe (atributo ou método) faz parte de sua interface.\n\nOu seja, é visível publicamente.\n\nJá a palavra-chave private declara que um elemento é parte da implementação.\n\nOu seja, está escondida de acesso externo.\n\n\n\n\n\n\n\nConceito\n\n\nModificadores de acesso definem a visibilidade de um atributo, construtor ou método. Elementos públicos são acessíveis de dentro da classe e a partir de outras classes; já elementos privados são acessíveis somente de dentro da mesma classe."
  },
  {
    "objectID": "cap5-1.html#encapsulamento-1",
    "href": "cap5-1.html#encapsulamento-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Encapsulamento",
    "text": "Encapsulamento\nEm muitas linguagens OO, a implementação de uma classe (seus detalhes internos) é ocultada de outras classes.\n\nIsso tem a ver com duas questões.\n\nAo usar uma classe um programador não deveria precisar conhecer seus detalhes internos.\n\n\nIsso tem a ver com a modularização e abstração que já discutimos antes.\nSe fosse necessário saber os detalhes de todas as classes, seria impossível desenvolver grandes sistemas.\n\n\nOutra questão é que, ao usar uma classe, um programador não deveria ter permissão de conhecer seus detalhes internos.\n\n\nApesar de também ter a ver com modularização, a ideia aqui é que a linguagem não deveria permitir o acesso à parte privada de uma classe a partir de comandos em outras classes.\nIsso garante que uma classe não dependa de como exatamente uma outra classe está implementada."
  },
  {
    "objectID": "cap5-1.html#section-44",
    "href": "cap5-1.html#section-44",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Esta última questão é muito importante para a manutenção de sistemas.\n\nQuando precisamos incluir novas funcionalidades ou corrigir bugs é muito comum precisarmos alterar ou aumentar uma classe.\nO ideal é que a alteração de uma classe não provoque alterações em outras classes.\n\nIsso tem a ver com o que chamamos de acoplamento.\nSe a alteração em uma classe não provoca alterações em outras classes, temos um baixo acoplamento.\nE isso é muito bom, porque torna o trabalho de manutenção muito mais fácil.\nJá que em vez de entender e alterar várias classes, o programador precisa trabalhar em apenas em uma."
  },
  {
    "objectID": "cap5-1.html#section-45",
    "href": "cap5-1.html#section-45",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Suponha, por exemplo, que a equipe que mantém a linguagem Java faça uma melhoria na implementação da classe ArrayList.\n\nO ideal é que essa melhoria não afete os nossos códigos que usam a classe ArrayList.\nRepare que isso só é possível porque nosso código não faz referência à implementação da classe ArrayList.\n\n\nPara ficar mais claro, quando uma classe A utiliza um objeto de uma classe B.\n\nNão é bem o programador que não pode conhecer a parte interna (implementação) da classe B.\nNa verdade é a classe A que não pode conhecer (ou seja, depender) dos detalhes internos da classe B.\nRepare que pode acontecer do mesmo programador implementar tanto a classe A quanto a classe B.\n\nMas de toda forma, as classes ainda deveriam ter baixo acoplamento."
  },
  {
    "objectID": "cap5-1.html#section-46",
    "href": "cap5-1.html#section-46",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Esta questão de acoplamento é tão importante que vamos discuti-la, em detalhes, no Capítulo 7.\n\nPor enquanto, o mais importante é entender que a palavra-chave private garante o princípio da ocultação de informações\n\nao impedir que outras classes acessem a parte privada da classe.\n\nIsso garante o baixo acoplamento, tornando a aplicação mais modular e facilitando a manutenção.\n\n\nNós também podemos chamar o princípio da ocultação de informações de encapsulamento.\n\nEsse conceito é fundamental na Programação Orientada a Objetos.\nE talvez seja a única parte do livro que não gosto muito, pois acho que ele não dá a ênfase necessária a esse conceito."
  },
  {
    "objectID": "cap5-1.html#section-47",
    "href": "cap5-1.html#section-47",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O termo encapsulamento vem da palavra cápsula, que é definida no dicionário como:\n\n\nA ideia é que a implementação da classe (seus detalhes internos) sejam encapsulados (protegidos).\n\nE a classe exponha apenas sua interface."
  },
  {
    "objectID": "cap5-1.html#section-48",
    "href": "cap5-1.html#section-48",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Um bom exemplo que ilustra o encapsulamento é um telefone fixo comum.\n\nVocê usa o telefone através de sua interface (os botões) e não precisa saber como é o funcionamento interno.\n\n\n\n\n\n\n\n\n\nA mesma analogia pode ser feita com um caixa eletrônico.\n\nVocê usa as opções que aparecem pra você (interface) mas não precisa saber como isso funciona internamente.\nE você só tem acesso aos dados que a interface disponibiliza."
  },
  {
    "objectID": "cap5-1.html#métodos-privados",
    "href": "cap5-1.html#métodos-privados",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Métodos privados",
    "text": "Métodos privados\nMuitos dos métodos que vimos até agora eram públicos.\n\nIsso garante que eles podem ser chamados a partir de outras classes.\nMas podemos também ter métodos privados.\n\nComo os métodos imprimirBoasVindas e imprimirDespedida da classe SistemaDeSuporte.\n\n\n\nNós declaramos um método como público para fornecer operações para quem usa a classe.\n\nE declaramos como privado para dividir o código em trechos menores, facilitando o entendimento e a leitura.\n\nVeja que não faria sentido chamar o método imprimirBoasVindas de fora da classe SistemaDeSuporte.\nMas o código do método iniciar fica mais claro quando separamos sua tarefa em subtarefas."
  },
  {
    "objectID": "cap5-1.html#métodos-privados-1",
    "href": "cap5-1.html#métodos-privados-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Métodos privados",
    "text": "Métodos privados\nNós também usamos métodos privados quando um trecho de código é usado em mais de um lugar na classe.\n\nPois, dessa forma, evitamos escrever o mesmo trecho de código mais de uma vez.\nE, em vez disso, chamamos o método privado em mais de um lugar."
  },
  {
    "objectID": "cap5-1.html#atributos-privados",
    "href": "cap5-1.html#atributos-privados",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos privados!",
    "text": "Atributos privados!\nA linguagem Java permite que atributos sejam declarados como privados ou públicos.\n\nMas você deve ter notado que nos exemplos sempre declaramos os atributos como privados.\nIsso é fundamental para respeitar o conceito de encapsulamento.\n\n\nDeclarar atributos públicos quebra o princípio da ocultação das informações.\n\nPortanto, mesmo que a linguagem Java permita atributos públicos, isso é considerado um estilo ruim de programação.\nHá linguagens que nem permitem a existência de atributos públicos.\n\nEnquanto outras não implementam completamente o conceito de encapsulamento, o que viola a teoria de POO.\nEsse é o principal motivo para eu não adotar a linguagem Python na disciplina :)"
  },
  {
    "objectID": "cap5-1.html#atributos-privados-1",
    "href": "cap5-1.html#atributos-privados-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos privados!",
    "text": "Atributos privados!\nOutro motivo para manter os atributos privados é permitir que a classe tenha um maior controle sobre o estado dos seus objetos.\n\nSe o atributo é encapsulado e só é acessível através de métodos de acesso (obter/get) e modificadores (definir/set),\na classe pode garantir que o atributo nunca tenha um valor inválido ou inconsistente.\n\n\nPara deixar o conceito mais claro, suponha que uma classe Circulo tenha um atributo chamado diametro.\n\nE, como o programador faltou às aulas de POO, ele definiu o atributo como público.\nCom isso, qualquer classe consegue acessar e alterar o valor do diâmetro de um círculo.\n\nFazendo, por exemplo:\n\n\n\n\n\nCirculo circulo = new Circulo(10);\ncirculo.diametro = 30;"
  },
  {
    "objectID": "cap5-1.html#atributos-privados-2",
    "href": "cap5-1.html#atributos-privados-2",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos privados!",
    "text": "Atributos privados!\nMas repare que isso abre brecha para a seguinte situação:\n\nint d = calcularNovoDiametro();\ncirculo.diametro = d;\n\n\nO que aconteceria se, por algum erro, o método calcularNovoDiametro retornasse um valor negativo?\n\nO círculo acabaria ficando com um diâmetro negativo, mas isso não faz sentido.\n\n\n\nE como isso poderia ser corrigido?"
  },
  {
    "objectID": "cap5-1.html#atributos-privados-3",
    "href": "cap5-1.html#atributos-privados-3",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos privados!",
    "text": "Atributos privados!\nAlém, é claro, de corrigir o método de cálculo, seria uma boa ideia colocar um if antes de alterar o diâmetro:\n\nPara garantir que o círculo nunca ficasse com valor negativo por algum outro erro.\n\n\n\nint d = calcularNovoDiametro();\nif (d &gt; 0) {\n    circulo.diametro = d;\n}\n\nMas repare que podem existir diversos trechos de código no programa que alteram o valor do diâmetro.\n\nE seria necessário colocar essa verificação em todos esses lugares.\nOutro problema é que tudo isso está acontecendo sem o conhecimento da classe Circulo.\n\nMas é ela quem deveria ser responsável por garantir que o estado dos seus objetos é sempre válido."
  },
  {
    "objectID": "cap5-1.html#atributos-privados-4",
    "href": "cap5-1.html#atributos-privados-4",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "Atributos privados!",
    "text": "Atributos privados!\nVamos comparar com uma versão bem implementada da classe Circulo:\n\nela teria o atributo diametro privado;\ne um método modificador para alterar o diâmetro.\n\n\n\npublic class Circulo {\n    private int diametro;\n    ...\n    public void definirDiametro(int diametro) {\n        this.diametro = diametro;\n    }\n}\n\n\n\nRepare que, com isso, o diâmetro só pode ser alterado através da chamada do método mudarDiametro.\n\nE agora fica mais fácil evitar o problema anterior.\nPois basta colocarmos a verificação (if) no método definirDiametro.\nNão é necessário tratar todos os lugares que chamam o método mudarDiametro."
  },
  {
    "objectID": "cap5-1.html#section-49",
    "href": "cap5-1.html#section-49",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Em resumo:\n\nAtributos deveriam ser sempre privados!\n\n\n\n\n\n\nConceito\n\n\nEncapsulamento (ou ocultamento de informações) é um princípio que define que os detalhes internos da implementação de uma classe deveriam ser ocultados das outras classes. Isso permite uma melhor modularização de uma aplicação."
  },
  {
    "objectID": "cap5-1.html#section-50",
    "href": "cap5-1.html#section-50",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Para ter presença nessa aula teórica ANP, demostrando que você estudou o conteúdo, você deve fazer a atividade abaixo.\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nResponda a tarefa no Campus Virtual enviando o seu projeto suporte-tecnico1 com as alterações dos 5 exercícios solicitados ao longo dos slides.\nAtenção: não se esqueça do aviso dado nos slides sobre o professor ter como corrigir a geração de reposta aleatória!"
  },
  {
    "objectID": "cap4-1.html#section",
    "href": "cap4-1.html#section",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Algumas perguntas para refletir antes de começar a aula:\n\nQuantas anotações vocês fez no caderno ao estudar os três primeiros capítulos da disciplina?\nVocê estudou todo o conteúdo de todas as aulas teóricas ANP anteriores?\nVocê leu alguma parte do livro da disciplina?\n\n\n\n\n\n\nLembre-se que você precisa ser a pessoa mais interessada no seu próprio sucesso!"
  },
  {
    "objectID": "cap4-1.html#section-1",
    "href": "cap4-1.html#section-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nNesta aula não há quizes a responder.\nVocê deverá entregar a versão final de um projeto que contenha todos os 7 exercícios marcados para a entrega. Eles estão identificados como: Exercício (entrega)."
  },
  {
    "objectID": "cap4-1.html#principais-conceitos-do-capítulo",
    "href": "cap4-1.html#principais-conceitos-do-capítulo",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Principais Conceitos do Capítulo",
    "text": "Principais Conceitos do Capítulo\n\n\nColeções\nLaços (loops)\nIteradores\nVetores (arrays)\n\n\n\nConstruções Java do capítulo\n\n\nArrayList, Iterator, for-each, while, for, null, objetos anônimos, vetor, ++."
  },
  {
    "objectID": "cap4-1.html#section-2",
    "href": "cap4-1.html#section-2",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "O principal objetivo deste capítulo é mostrar algumas formas que temos de agrupar objetos em coleções.\n\nNesta aula vamos aprender sobre a classe ArrayList, que é um exempo de coleção de tamanho flexível.\nNa aula seguinte, veremos como usar vetores em Java.\n\n\nAo usar coleções, precisamos percorrer (ou iterar) sobre seus elementos.\n\nPara isso, utilizaremos estruturas de repetição: for-each, while e for.\n\n\n\nEste capítulo tem mais conteúdo que os anteriores.\n\nE, portanto, demandará maior dedicação e esforço.\nMas os conceitos aqui são fundamentais para que se torne um bom programador.\nE para que entenda os conceitos dos capítulos seguintes."
  },
  {
    "objectID": "cap4-1.html#section-3",
    "href": "cap4-1.html#section-3",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Além de conhecermos os novos conceitos de coleção e iteradores,\n\nvamos revisitar os conceitos de abstração e interação entre objetos vistos anteriormente.\n\n\nVimos que abstração nos permite simplificar um problema:\n\nidentificando componentes como unidades completas, sem nos preocuparmos com seus detalhes.\n\n\n\nVeremos esse princípio, na prática, ao utilizarmos uma classe da Biblioteca de Classes do Java.\n\nAo implementar um programa, um bom desenvolvedor deve sempre procurar por classes disponíveis na biblioteca de classes da linguagem.\nCom isso, evitamos “reinventar a roda”, evitando retrabalho com coisas que já estão prontas e testadas.\nE, assim, podemos focar no que é a essência do problema que queremos resolver."
  },
  {
    "objectID": "cap4-1.html#section-4",
    "href": "cap4-1.html#section-4",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Portanto, vale muito a pena, se familizarizar com as classes mais comuns da biblioteca do Java.\n\nO poder da abstração nos permite usar essas classes sem precisarmos saber praticamente nada sobre como elas são implementadas internamente.\n\n\nUsar essas classes se refere basicamente a:\n\nCriar objetos delas e chamar os métodos desses objetos.\nPortanto, teremos uma interação entre os nossos objetos e os objetos das classes da biblioteca."
  },
  {
    "objectID": "cap4-1.html#section-5",
    "href": "cap4-1.html#section-5",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Como foi citado no início da disciplina, esse material tem uma abordagem iterativa.\n\nO que significa que os conceitos são revisitados o tempo todo,\ncom o objetivo de aprofundarmos nosso entendimento sobre eles.\n\n\nNeste capítulo veremos também que abstração não se refere apenas a ignorar detalhes.\n\nMas também a identificar padrões que aparecem repetidamente no código.\nO que nos permite reutilizar em uma nova situação métodos e classes que já havíamos implementado e usado antes."
  },
  {
    "objectID": "cap4-1.html#section-6",
    "href": "cap4-1.html#section-6",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "O que é uma coleção?\n\nSegundo o dicionário Priberam, um dos significados é:\n“Reunião de objetos da mesma natureza.”\n\n\nUma coleção pode ser:\n\nGrande.\n\nEx.: todos os alunos da universidade.\n\nPequena.\n\nEx.: as disciplinas que um aluno está matriculado em um semestre.\n\nOu até mesmo vazia.\n\nEx.: os prêmios Nobel que eu já ganhei."
  },
  {
    "objectID": "cap4-1.html#section-7",
    "href": "cap4-1.html#section-7",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Se você tem uma coleção de alguma coisa (moedas, autógrafos, o que seja),\n\nhá algumas operações que você pode fazer com a sua coleção de tempos em tempos, como por ex.:\n\nAdicionar um novo item à coleção.\nRemover um item da coleção (por ter vendido, ou ser repetido, por ex.).\nOrganizar os itens de alguma forma (por tamanho ou valor, por ex.).\nListar um subconjunto dos itens para algum propósito (moedas do império romano, por ex.).\n\n\n\nRepare que essas são operações comuns em coleções.\n\nIndependente dos objetos que elas guardam."
  },
  {
    "objectID": "cap4-1.html#section-8",
    "href": "cap4-1.html#section-8",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "No contexto de POO, uma coleção pode ser representada por uma classe.\n\nE as operações sobre a coleção por métodos desta classe.\nUma coleção particular (minha coleção de músicas, por ex.) seria uma instância da classe, ou seja, um objeto da classe.\n\nNote que os itens da coleção (as moedas, por ex.) seriam objetos de outra classe.\n\n\n\nAlguns exemplos de coleção comuns no contexto de programação seriam:\n\nO conjunto de estudantes da universidade no SIG:\n\nA cada semestre novos estudantes são adicionados, e alunos formados são removidos.\n\nFilmes e séries no catálogo da Netflix:\n\nO catálogo é continuamente atualizado, acrescentando novos filmes e séries e retirando outros.\n\nOs comentários de uma publicação em uma rede social:\n\nNovos comentários são postados e comentários também podem ser removidos."
  },
  {
    "objectID": "cap4-1.html#section-9",
    "href": "cap4-1.html#section-9",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Veja que a quantidade de itens armazenada em uma coleção pode variar com o tempo.\n\nUma solução ingênua para tratar isso em um código Java seria criar um atributo para cada objeto da coleção.\nMas veja que precisaríamos adivinhar quantos objetos a coleção precisaria.\nOu acabar declarando vários atributos que não seriam usados.\n\n\nPortanto, é muito mais prático se não precisarmos saber, antecipadamente, quantos objetos a coleção precisará ter.\n\nPara isso, vamos utilizar a forma mais simples possível de agrupar objetos em Java: a classe ArrayList.\nVamos usar como exemplo um projeto que nos permite organizar uma playlist de músicas.\n\n\n\n\n\n\n\nConceito\n\n\nUm objeto coleção pode guardar um número arbitário de outros objetos."
  },
  {
    "objectID": "cap4-1.html#section-10",
    "href": "cap4-1.html#section-10",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Vamos criar uma classe para nos ajudar a organizar arquivos de músicas guardados no computador.\n\nNossa classe não vai guardar os detalhes das músicas.\nEm vez disso, vamos usar a classe ArrayList da biblioteca de classes para nos poupar trabalho.\n\n\n\n\n\n\n\nA questão é que as classes da biblioteca de classes foram criadas para uso geral.\nE não para necessidades específicas.\nUm ArrayList pode ser usado para guardar dados de estudantes, ou de lembretes de eventos, por exemplo.\nA nossa classe específica é que precisará tratar de operações específicas relacionadas a arquivos de músicas."
  },
  {
    "objectID": "cap4-1.html#section-11",
    "href": "cap4-1.html#section-11",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Por razões didáticas, ou seja, para ficar mais fácil assimilarmos os conceitos:\n\nvamos começar com uma versão bem simples da classe,\nque lida apenas com os nomes dos arquivos de música.\n\nSem detalhes como título, artista, duração, etc.\n\n\n\nNesse cenário, precisaremos que o ArrayList guarde objetos String que representem os nomes dos arquivos.\n\nA ideia é começar simples, para focarmos no conceito que vamos aprender agora: criação e uso de coleções.\nDepois vamos incrementar o projeto para que ele pareça com um organizador e tocador de músicas de verdade."
  },
  {
    "objectID": "cap4-1.html#section-12",
    "href": "cap4-1.html#section-12",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "A classe vai assumir que cada arquivo tem uma única música.\n\nE o nome do arquivo tem o nome do artista e da música (usaremos isso mais adiante).\n\n\nAs operações básicas que queremos na primeira versão da classe são:\n\nAdicionar músicas na coleção.\nA coleção não deve ter limite de tamanho, exceto a memória do computador.\nRetornar a quantidade de músicas na coleção.\nListar todas as músicas.\n\n\n\nVeremos que a classe ArrayList torna bem fácil tratar essas operações."
  },
  {
    "objectID": "cap4-1.html#section-13",
    "href": "cap4-1.html#section-13",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Estamos adotando uma abordagem incremental.\n\nComeçamos com uma versão básica que mostra como criar e usar um ArrayList.\nE depois vamos melhorá-la até chegar ao ponto de nosso programa tocar a música de verdade.\n\n\n\n\n\n\n\nLembre-se que adotar uma abordagem incremental tem uma probabilidade de sucesso muito maior do que querer implementar tudo de uma vez."
  },
  {
    "objectID": "cap4-1.html#section-14",
    "href": "cap4-1.html#section-14",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nAntes de analisarmos o código-fonte, vamos entender o funcionamento do organizador de músicas.\nAbra o probjeto organizador-musicas-v1 no BlueJ e crie um objeto OrganizadorDeMusicas. Guarde nomes de alguns arquivos de música nele (são simplesmente strings). Como não vamos tocar as músicas agora, qualquer nome de arquivo serve. Mas há um repositório com arquivos de músicas de verdade que você pode querer baixar e usar.\nConfira se o número de arquivos retornado pelo método obterQuantidadeDeArquivos bate com a quantidade que você armazenou. Ao usar o método listarArquivo você deve notar que você precisa passar o valor 0 para imprimir o primeiro nome de arquivo, 1 para o segundo, e assim por diante. Você imagina, por que?"
  },
  {
    "objectID": "cap4-1.html#section-15",
    "href": "cap4-1.html#section-15",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nO que acontece se você criar um objeto OrganizadorDeMusicas e chamar removerArquivo(0) antes de ter adicionado qualquer música?\nOcorre algum erro? Você esperava que ocorresse algum erro?\n\n\n\n\n\n\n\n\nExercício\n\n\nCrie um OrganizadorDeMusicas e adicione dois nomes de arquivos a ele. Chame listarArquivo(0) e listarArquivo(1) para mostrar os dois arquivos. Agora chame removerArquivo(0) e depois listarArquivo(0).\nO que aconteceu? Era o que você esperava?\nVocê imagina alguma explicação para o que deve ter acontecido quando você removeu o primeiro arquivo da coleção?"
  },
  {
    "objectID": "cap4-1.html#section-16",
    "href": "cap4-1.html#section-16",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Leia o código da classe OrganizadorDeMusicas.\n\nRepare que ela usa a classe ArrayList.\nMas a classe ArrayList não aparece no diagrama de classes do BlueJ.\n\n\n\n\n\n\nBibliotecas de classes\n\n\nUma das coisas que torna as linguagens OO (Orientadas a Objetos) poderosas, é que elas geralmente trazem junto bibliotecas de classes.\n\nEssas bibliotecas geralmente têm centenas ou milhares de classes que são muito úteis para os desenvolvedores em diversos projetos.\nJava chama essas bibliotecas de pacotes.\nNós usamos as classes das bibliotecas exatamente do mesmo jeito que usamos nossas próprias classes.\nCriamos objetos usando new, e as classes têm atributos, construtores e métodos."
  },
  {
    "objectID": "cap4-1.html#importando-uma-classe-da-biblioteca",
    "href": "cap4-1.html#importando-uma-classe-da-biblioteca",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Importando uma classe da biblioteca",
    "text": "Importando uma classe da biblioteca\nA primeira linha da classe OrganizadorDeMusicas mostra como acessar uma classe de biblioteca em Java.\n\n  import java.util.ArrayList;\n\n\nEste comando disponibiliza a classe ArrayList do pacote java.util para ser usada em nossa classe.\n\nCom isso, nós podemos usar a classe ArrayList como se fosse uma classe do nosso projeto.\nNós a usamos então para declarar o atributo arquivos.\n\n\n\n\n  private ArrayList&lt;String&gt; arquivos;"
  },
  {
    "objectID": "cap4-1.html#section-17",
    "href": "cap4-1.html#section-17",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que a declaração do atributo arquivos traz algo de diferente:\n\n&lt;String&gt;\n\n\nIsso é necessário porque, como vimos antes, a classe ArrayList foi criada para uso geral.\n\nOu seja, ela não restringe que objetos ela guarda.\nMas, quando criamos um objeto ArrayList, precisamos dizer qual o tipo dos objetos que serão guardados nele.\nClasses que são parametrizadas com um segundo tipo (como a ArrayList) são chamadas classes genéricas em Java.\n\nVeremos mais sobre isso mais adiante.\n\n\n\n\nPortanto, sempre que usamos uma coleção precisamos especificar dois tipos:\n\nO tipo da coleção em si (nesse caso, ArrayList).\nE o tipo dos elementos que queremos guardar na coleção (nesse caso, String).\nAssim, uma declaração ArrayList&lt;String&gt; costuma ser lida como ArrayList de strings."
  },
  {
    "objectID": "cap4-1.html#notação-diamante",
    "href": "cap4-1.html#notação-diamante",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Notação diamante",
    "text": "Notação diamante\nDa mesma forma que vimos antes que o construtor da classe VisorDeRelogio criava objetos da classe VisorDeNumero,\n\na classe OrganizadorDeMusicas cria um objeto do tipo ArrayList e o guarda no atributo arquivos.\n\n\nFazemos isso com o comando:\n\n  arquivos = new ArrayList&lt;&gt;();\n\n\nNós chamamos essa sintaxe de notação diamante (por causa do sinais &lt;&gt; consecutivos).\nRepare que poderíamos escrever new ArrayList&lt;String&gt;()\n\nMas podemos omitir o tipo dos objetos, porque o compilador usa a declaração da variável arquivos para saber qual tipo deve ser usado.\n\nPortanto, usar &lt;&gt; é só um atalho para escrever código mais rápido."
  },
  {
    "objectID": "cap4-1.html#principais-métodos-da-classe-arraylist",
    "href": "cap4-1.html#principais-métodos-da-classe-arraylist",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Principais métodos da classe ArrayList",
    "text": "Principais métodos da classe ArrayList\nA classe ArrayList possui muitos métodos, mas, por enquanto, usaremos apenas quatro:\n\nadd: adiciona um elemento ao final da lista.\nsize: retorna a quantidade de elementos na coleção.\nget e remove: veremos mais adiante, mas já dá para ter uma ideia vendo como são utilizados no código."
  },
  {
    "objectID": "cap4-1.html#section-18",
    "href": "cap4-1.html#section-18",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para entendermos como uma coleção como a ArrayList funciona, é interessante analisarmos um diagrama de objetos.\n\nCompare a figura abaixo que mostra um OrganizadorDeMusicas com duas strings de nomes de arquivos, com a próxima que mostra com três."
  },
  {
    "objectID": "cap4-1.html#section-19",
    "href": "cap4-1.html#section-19",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para entendermos como uma coleção como a ArrayList funciona, é interessante analisarmos um diagrama de objetos.\n\nCompare a figura abaixo que mostra um OrganizadorDeMusicas com duas strings de nomes de arquivos, com a próxima que mostra com três."
  },
  {
    "objectID": "cap4-1.html#section-20",
    "href": "cap4-1.html#section-20",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Há três características importantes sobre o ArrayList que precisamos saber:\n\nPodemos aumentar sua capacidade conforme a necessidade.\nEle mantém uma contagem privada da quantidade de itens armazenados (e o método size retorna essa informação).\nEle mantém a ordem dos elementos inseridos (e podemos obter os objetos na mesma ordem).\n\n\nVeja que, ao utilizar um ArrayList, a classe OrganizadorDeMusica fica muito simples.\n\nTodo trabalho “pesado” é tratado na ArrayList.\n\nEssa é a grande vantagem de usar uma classe da biblioteca de classes.\nPoupamos trabalho aproveitando algo que alguém já teve o trabalho de fazer e testar."
  },
  {
    "objectID": "cap4-1.html#section-21",
    "href": "cap4-1.html#section-21",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Veja que nós usamos a classe ArrayList sem nos preocuparmos exatamente como a classe funciona.\n\nBasta sabermos o que ela faz e como utilizar seus métodos.\nVeja que estamos mais uma vez usando o conceito de abstração.\n\nSem precisar conhecer os detalhes da classe, podemos usá-las em diversas situações diferentes.\n\n\n\nOutra coisa importante é que o fato do ArrayList guardar o número de objetos que ele armazena, traz consequências importantes.\n\nA classe OrganizadorDeMusicas não precisa guardar essa informação.\n\nMesmo tendo um método obterQuantidadeDeArquivos.\n\nRepare que o organizador de músicas delega a responsabilidade de manter essa informação para o objeto ArrayList.\n\nIsso significa que o organizador não duplica essa informação no programa."
  },
  {
    "objectID": "cap4-1.html#section-22",
    "href": "cap4-1.html#section-22",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Duplicação de informações é algo que devemos nos esforçar para evitar.\n\nAlém de dar mais trabalho, por estarmos fazendo algo duas vezes,\n\ncorremos o risco de, por algum erro, as duas informações (que deveriam ser iguais) estarem diferentes.\n\n\n\nFalaremos bastante de duplicação nos próximos capítulos."
  },
  {
    "objectID": "cap4-1.html#section-23",
    "href": "cap4-1.html#section-23",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Vamos aprofundar um pouco a notação utilizada para declarar o tipo do atributo arquivos:\n\nArrayList&lt;String&gt;\n\n\nComo já comentamos, classes que dependem de um segundo tipo são chamadas de classes genéricas.\n\nUma classe genérica não define um único tipo, mas, na verdade, potencialmente, vários tipos.\nPodemos ter: ArrayList de Strings, ArrayList de Pessoas, ArrayList de Retângulos, enfim, de quaisquer objetos que precisarmos.\n\nCada um deles é um tipo diferente.\n\n\n\n\nPor enquanto, vamos usar apenas a classe ArrayList,\n\nmas existem diversas outras coleções também implementadas como classes genéricas."
  },
  {
    "objectID": "cap4-1.html#section-24",
    "href": "cap4-1.html#section-24",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Veja as declarações abaixo, por exemplo:\n\n  private ArrayList&lt;Pessoa&gt; equipe;\n  private ArrayList&lt;MaquinaIngressos&gt; maquinas;  \n\n\nO atributo equipe pode armazenar objetos Pessoa.\n\nJá o atributo maquinas guarda objetos MaquinaIngressos.\nPortanto, ArrayList&lt;Pessoa&gt; e ArrayList&lt;MaquinaIngressos&gt; são tipos diferentes.\n\n\n\nVocê acha que a linha de código abaixo seria válida?\n\n  equipe = maquinas;  \n\n\nNão!\n\nJustamente porque as variáveis são de tipos diferentes."
  },
  {
    "objectID": "cap4-1.html#section-25",
    "href": "cap4-1.html#section-25",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nEscreva a declaração de um atributo privado chamado biblioteca que guarda um ArrayList. Os elementos do ArrayList são do tipo Livro.\n\n\n\n\n\n\n\n\nExercício\n\n\nEscreva a declaração de uma variável local chamada ipoo que guarda um ArrayList de Estudante."
  },
  {
    "objectID": "cap4-1.html#section-26",
    "href": "cap4-1.html#section-26",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nEscreva a declaração de um atributo privado chamado musicas para guardar uma coleção de objetos Musica.\n\n\n\n\n\n\n\n\nExercício\n\n\nEscreva comandos para criar objetos ArrayList e atribuir às variáveis declaradas nos três exercícios anteriores."
  },
  {
    "objectID": "cap4-1.html#section-27",
    "href": "cap4-1.html#section-27",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Ao usar o projeto organizador-musicas-v1 você notou que, para listar e remover músicas, foi necessário passar parâmetros começando em zero.\n\nIsso porque objetos armazenados em um ArrayList têm uma numeração implícita que começa em zero.\nGeralmente chamamos a posição do objeto na coleção de índice.\n\n\nPortanto, se um ArrayList tiver 20 objetos, qual é a posição do último elemento?\n\n19, certo?\n\nJá que o primeiro objeto fica na posição 0, o segundo na posição 1, e assim por diante."
  },
  {
    "objectID": "cap4-1.html#section-28",
    "href": "cap4-1.html#section-28",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que os métodos listarArquivo e removerArquivo verificam o valor do índice antes de passá-lo para os métodos do ArrayList.\n\nEles conferem se o índice está no intervalo válido, entre 0 e size()-1.\nÉ um bom hábito fazer isso para evitar erros nas chamadas de métodos de classes da biblioteca.\n\n\n\n\n\n\nCuidado\n\n\nSe você não tomar cuidado, pode acabar tentando acessar uma posição inválida de um ArrayList.\nSe fizer isso, o programa exibirá uma mensagem de índice fora da faixa (IndexOutOfBoundsException) e o programa será terminado."
  },
  {
    "objectID": "cap4-1.html#section-29",
    "href": "cap4-1.html#section-29",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "É importante lembrar que, ao remover um objeto de um ArrayList, os objetos que estavam depois dele mudam de posição.\n\nSuponha, por exemplo, um ArrayList com 5 elementos.\n\nSe você remover o terceiro elemento (ou seja, o elemento da posição 2),\n\nO próximo elemento vai passar da posição 3 para a posição 2.\nE o último vai passar da posição 4 para a posição 3.\n\n\n\n\nÉ importante nos acostumarmos a utilizar os índices de uma coleção.\n\nPois várias coleções têm essa mesma característica de começar em zero, e seguir sequencialmente, até size()-1."
  },
  {
    "objectID": "cap4-1.html#section-30",
    "href": "cap4-1.html#section-30",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Suponha, por exemplo, que uma variável p guarda a posição de um objeto na coleção.\n\nComo podemos acessar o próximo objeto?\n\nPela posição p+1.\n\nE o objeto anterior?\n\nPela posição p-1.\n\nE como podemos acessar os três primeiros objetos?\n\nPelas posições: 0, 1 e 2.\n\nE os quatro últimos?\n\nPelas posições: size()-4, size()-3, size()-2 e size()-1."
  },
  {
    "objectID": "cap4-1.html#section-31",
    "href": "cap4-1.html#section-31",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nCrie um novo método na classe OrganizadorDeMusicas chamado verificarIndice. O método deve receber um parâmetro inteiro e verificar se ele é um índice válido para o estado atual da coleção.\nSe o parâmetro não for válido, uma mensagem de erro deve ser exibida no terminal, informando qual é a faixa válida de índices (ex.: de 0 a 3). Teste o método usando um objeto da bancada de objetos, experimentando situações com índice válidos e inválidos.\nO que acontece se o método for chamado para uma coleção vazia?\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nCrie um método similar ao anterior, chamado indiceEhValido. O método deve receber um parâmetro inteiro e retornar um boolean. O método não deve exibir nada no terminal, apenas retornar true se o índice for válido e false em caso contrário.\nTeste o método usando a bancada de objetos para índices válidos e inválidos (incluindo coleção vazia)."
  },
  {
    "objectID": "cap4-1.html#section-32",
    "href": "cap4-1.html#section-32",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nModifique os métodos listarArquivo e removerArquivo da classe OrganizadorDeMusicas de forma que eles usem o método indiceEhValido para verificar seus parâmetros, em vez da expressão booleana atual.\nOs métodos get ou remove do ArrayList só devem ser chamados se o método indiceEhValido retornar true."
  },
  {
    "objectID": "cap4-1.html#section-33",
    "href": "cap4-1.html#section-33",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Seria interessante se nosso organizador não só guardasse uma lista de arquivos de música,\n\nMas se também tocasse realmente as músicas.\n\n\nSe tivermos uma classe implementada para tocar arquivos de aúdio, nossa classe organizadora não precisa saber nada sobre como fazer isso.\n\nPoderia apenas lidar com o nome do arquivo e deixar a outra classe cuidar do resto.\nInfelizmente, a biblioteca padrão do Java não tem uma classe para tocar arquivos MP3.\nMas muitos programadores e empesas criam classes úteis o tempo todo.\n\nE as disponibilizam para outras pessoas usarem.\nÉ o que chamamos de classes de terceiros (third-party libraries).\nElas podem ser importadas e usadas da mesma forma que as classes da biblioteca padrão Java.\n\nPrecisamos apenas ter o arquivo da biblioteca em nosso projeto (veremos mais sobre isso no futuro)."
  },
  {
    "objectID": "cap4-1.html#section-34",
    "href": "cap4-1.html#section-34",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Em uma nova versão do projeto, usaremos classes da biblioteca javazoom.net para escrever a nossa própria classe tocadora de música.\n\nNós usaremos três métodos da nova classe TocadorDeMusica.\n\ntocarAmostra, comecarATocar e parar.\nOs dois primeiros métodos recebem o nome do arquivo de música por parâmetro.\n\nO primeiro toca alguns segundos do início do arquivo e retorna quando termina de tocar.\nJá o segundo começa a tocar a música em segundo plano (background) e já retorna para o organizador.\nE, nesse caso, precisamos usar o método parar se quisermos parar de tocar a música.\n\n\n\n\nAvalie as modificações na classe OrganizadorDeMusica no projeto organizador-musicas-v2."
  },
  {
    "objectID": "cap4-1.html#section-35",
    "href": "cap4-1.html#section-35",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nCrie um objeto OrganizadorDeMusica da segunda versão do projeto. Experimente adicionar alguns arquivos de música a ele e tocá-los.\nSe quiser, você pode usar as músicas do repositório amostras-musicas. Baixe o repositório, descompacte o arquivo e copie os arquivos de extensão .mp3 para a pasta do projeto organizador-musicas-v2. Ao adicionar os arquivos no organizador de músicas, use exatamente o mesmo nome do arquivo, incluindo a extensão .mp3 (ex.: Mactonite-MorningMysteries.mp3)\nVocê pode usar seus próprios arquivos MP3 também se preferir. Lembre-se apenas de colocar na pasta do projeto e digitar corretamente o nome do arquivo.\nExperimente também com arquivos que não existem. O que acontece quando você tenta utilizá-los?"
  },
  {
    "objectID": "cap4-1.html#resumo-do-organizador-de-músicas",
    "href": "cap4-1.html#resumo-do-organizador-de-músicas",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Resumo do organizador de músicas",
    "text": "Resumo do organizador de músicas\n\nAgora nós sabemos como usar o básico de uma coleção em Java.\n\nFizemos isso com pouco esforço, porque estamos aproveitando o que está implementado na classe ArrayList.\nDa mesma forma, nosso programa é capaz de tocar músicas, com pouco esforço.\n\nAproveitando o que já está implementado em uma classe de biblioteca de terceiros.\n\n\n\n\nVeja que, em ambos os casos, precisamos saber muito pouco sobre o funcionamento interno das classes.\n\nPrecisamos saber apenas informações sobre alguns métodos importantes.\n\nBasicamente seus nomes, tipos de parâmetro e tipo de retorno.\n\n\n\n\nAinda faltam algumas coisas para nosso organizador ficar mais útil.\n\nEspecialmente, poder listar os nomes de todos os arquivos da coleção.\nÉ o que veremos a seguir."
  },
  {
    "objectID": "cap4-1.html#section-36",
    "href": "cap4-1.html#section-36",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "A ideia agora é ter um método na classe OrganizadorDeMusicas que exiba no terminal todos os nomes de arquivos guardados na coleção.\n\nPodemos pensar em um método listarTodosOsArquivos para fazer isso.\n\nQual deve ser o tipo de retorno do método?\nEle precisa ter algum parâmetro?\nQuantas chamadas ao método System.out.println precisamos para mostrar todos os nomes de arquivo?\n\n\n\nVeja que, claramente, precisamos de uma estrutura de repetição para implementar o método.\n\nVamos começar utilizando o loop for-each.\n\n\n\n\n\n\n\nConceito\n\n\nUm loop (ou laço) pode ser usado para executar repetidamente um bloco de comandos sem precisarmos escrevê-los várias vezes."
  },
  {
    "objectID": "cap4-1.html#o-loop-for-each",
    "href": "cap4-1.html#o-loop-for-each",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop for-each",
    "text": "O loop for-each\nUm loop for-each (para cada) é uma forma de realizar ações repetidamente nos itens de uma coleção.\n\nSem precisar escrevê-las mais de uma vez.\n\n\nA sintaxe do for-each é mostrada no pseudo-código a seguir:\n\n  for (TipoDoElemento elemento : coleção) {\n    corpo do loop\n  }\n\n\n\nEsse código fica mais fácil de entender se o lermos assim:\n\n  Para cada elemento na coleção faça: {\n    corpo do loop\n  }"
  },
  {
    "objectID": "cap4-1.html#section-37",
    "href": "cap4-1.html#section-37",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "for (TipoDoElemento elemento : coleção) {\n    corpo do loop\n  }\n\nRepare que a variável elemento está sendo declarada no cabeçalho do loop.\n\nPor isso, precisamos informar o tipo da variável.\nNós chamamos essa variável de variável do loop.\n\nE podemos usar o nome que quisermos para a variável."
  },
  {
    "objectID": "cap4-1.html#section-38",
    "href": "cap4-1.html#section-38",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Abaixo está uma implementação do método listarTodosOsArquivos:\n\n  public void listarTodosOsArquivos() {\n      for(String nomeDoArquivo : arquivos) {\n          System.out.println(nomeDoArquivo);  \n      }\n  }\n\n\nRepare que o método println é chamado para cada objeto presente no ArrayList arquivos.\n\nSe houver quatro músicas na coleção, ele será executado quatro vezes.\nEm cada execução, a variável nomeDoArquivo guarda um dos elementos da lista.\n\nNa primeira vez o elemento da posição 0, depois da posição 1, e assim por diante."
  },
  {
    "objectID": "cap4-1.html#section-39",
    "href": "cap4-1.html#section-39",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nImplemente o método listarTodosOsArquivos no seu projeto.\nCrie um objeto OrganizadorDeMusicas, adicione alguns arquivos a ele e teste o método que você implementou.\nDica: use o depurador do BlueJ para reforçar o entendimento de como o loop for-each funciona."
  },
  {
    "objectID": "cap4-1.html#section-40",
    "href": "cap4-1.html#section-40",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício\n\n\nCrie um ArrayList de Strings no bloco de códigos do BlueJ, digitando as duas linhas abaixo.\n\nimport java.util.ArrayList;\nnew ArrayList&lt;String&gt;()\n\nRepare que a segunda linha não tem ponto-e-vírgula e, por isso, aparecerá um ícone vermelho no bloco de códigos. Use-o para jogar o objeto ArrayList criado na bancada de objetos.\nClique no objeto e verifique os métodos disponíveis. Tente usar alguns dos métodos: add, remove, size e isEmpty. Tente chamar os mesmos métodos também pelo Bloco de Códigos."
  },
  {
    "objectID": "cap4-1.html#processamento-seletivo-de-uma-coleção",
    "href": "cap4-1.html#processamento-seletivo-de-uma-coleção",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Processamento seletivo de uma coleção",
    "text": "Processamento seletivo de uma coleção\n\nNós vimos que podemos usar um loop for-each para percorrer todos os elementos de uma coleção.\n\nMas nós não somos obrigados a fazer a mesma coisa com todos os objetos.\nPodemos, por exemplo, querer listar apenas as músicas de um determinado cantor.\nOu buscarmos todas as músicas que têm uma certa palavra no título.\n\n\n\nO que você acha que precisamos acrescentar no corpo do loop para fazer esse tipo de coisa?\n\nBasta usarmos um comando condicional (if) para selecionar os arquivos que queremos."
  },
  {
    "objectID": "cap4-1.html#section-41",
    "href": "cap4-1.html#section-41",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "O código abaixo mostra um exemplo de processamento seletivo.\n\n/**\n * Lista os nomes dos arquivos que batem com a string de busca passada\n * @param stringDeBusca A string a ser procurada.\n */\npublic void buscarMusicas(String stringDeBusca)\n{\n    for (String nomeDoArquivo : arquivos) {\n        // Se a string de busca existe no nome do arquivo\n        if (nomeDoArquivo.contains(stringDeBusca)) {\n            System.out.println(nomeDoArquivo);\n        }\n    }\n}\n\n\nUsando o método contains da classe String, podemos filtrar os arquivos.\n\nE exibir apenas aqueles que têm a string de busca passada.\n\nSe o nome do arquivo não tem a string de busca, nós simplesmente o ignoramos.\n\nE, por isso, não há um bloco else no código."
  },
  {
    "objectID": "cap4-1.html#section-42",
    "href": "cap4-1.html#section-42",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nAdicione o método buscarMusicas à sua última versão da classe OrganizadorDeMusicas.\nConfira se o método exibe apenas os nomes de arquivo que possuem a string de busca. Experimente também usar uma string de busca que não exista em nenhum arquivo.\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nAltere o método buscarMusicas de forma que seja exibida uma mensagem caso nenhum arquivo tenha a string de busca passada.\nDica: você precisará declarar uma variável local do tipo boolean."
  },
  {
    "objectID": "cap4-1.html#section-43",
    "href": "cap4-1.html#section-43",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nCrie um novo método buscarETocarMusicas que toque uma amostra das músicas de um determinado artista. Para isso, os nomes dos arquivos precisam conter o nome do artista.\nO método é similar ao do exercício anterior mas, ao encontrar um arquivo que possui a string de busca (nome do artista, no caso), em vez de exibir o nome do arquivo, ele deve tocar uma amostra da música. Você precisará utilizar o método tocarAmostra do atributo tocador para fazer isso."
  },
  {
    "objectID": "cap4-1.html#limitação-do-uso-de-strings",
    "href": "cap4-1.html#limitação-do-uso-de-strings",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Limitação do uso de strings",
    "text": "Limitação do uso de strings\nQuando começamos a fazer buscas nos nomes dos arquivos, começamos a perceber que tratar tudo como string não é ideal.\n\nEx.: podemos querer buscar todas as músicas que tenham a palavra renda no título.\n\nMas isso pode retornar músicas de uma cantora chamada Brenda.\n\nVeja que, pensando em termos de orientação a objetos, o ideal era que tivéssemos uma classe para representar músicas.\n\nE essa classe poderia, por exemplo, guardar separadamente o nome do artista e o nome da música.\nE, assim, seria mais fácil buscar músicas por artista ou pelo nome.\n\n\n\nSupondo então que fosse criada uma classe Musica, qual deveria ser o tipo do nosso atributo arquivos?\n\nEm vez de ArrayList&lt;String&gt;, ele passaria a ser ArrayList&lt;Musica&gt;.\n\n\n\nFaremos essa melhoria na próxima aula!"
  },
  {
    "objectID": "cap4-1.html#section-44",
    "href": "cap4-1.html#section-44",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para ter presença nessa aula teórica ANP, demostrando que você estudou o conteúdo, você deve fazer a atividade abaixo.\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nResponda a tarefa no Campus Virtual enviando o seu projeto organizador-musicas-v2 com o arquivo OrganizadorDeMusicas.java contendo as 7 alterações solicitadas nos exercícios ao longo dos slides.\nObs.: copie os métodos dos primeiros exercícios feitos no projeto organizador-musicas-v1 para o projeto organizador-musicas-v2 e faça a entrega apenas do segundo projeto."
  },
  {
    "objectID": "cap3-1.html#como-estudar",
    "href": "cap3-1.html#como-estudar",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Como estudar?",
    "text": "Como estudar?\nSerá que preciso dizer de novo as dicas? :)\n\n\n\nÉ essencial praticar enquanto estuda, usando o BlueJ.\nAjuda muito se você ler o capítulo do livro da disciplina para tirar dúvidas e complementar o que está sendo estudado.\nUse um caderno e caneta para anotar os principais conceitos e eventuais dúvidas que surgirem."
  },
  {
    "objectID": "cap3-1.html#principais-conceitos-do-capítulo",
    "href": "cap3-1.html#principais-conceitos-do-capítulo",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Principais Conceitos do Capítulo",
    "text": "Principais Conceitos do Capítulo\n\n\nAbstração\nModularização\nCriação de objetos\nChamadas de métodos\nDepuradores\n\n\n\nConstruções Java do capítulo\n\n\nTipos de classe, operadores lógicos (&& e ||), concatenação de strings, construção de objetos (operador new), chamadas de métodos, this.\n\n\n\n\nNós já temos uma boa noção do que são objetos, como são implementados através de classes e como são utilizados individualmente.\n\nNós agora vamos ver que, para criar aplicações interessantes, precisamos usar objetos que cooperam entre si para realizar alguma tarefa."
  },
  {
    "objectID": "cap3-1.html#section",
    "href": "cap3-1.html#section",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Para entender como podemos criar aplicações com objetos que cooperam entre si, vamos começar com um exemplo bem simples.\n\n\n\nUm visor de um relógio digital que mostra horas e minutos, separados por dois-pontos.\n\n\n\n\n\nEm um primeiro momento poderíamos pensar em criar uma única classe para representar o visor do relógio.\n\nMas vamos usar uma abordagem diferente.\nO objetivo é usar esse exemplo bem simples para demonstrar como podemos tratar um problema, dividindo-o em subproblemas menores, que são mais fáceis de resolver."
  },
  {
    "objectID": "cap3-1.html#section-1",
    "href": "cap3-1.html#section-1",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O motivo para criarmos mais de uma classe em vez de fazer tudo em uma só é a complexidade.\n\nÀ medida que avançarmos na disciplina, vamos criar programas cada vez mais complexos.\nProblemas simples como o da máquina de ingressos podem ser resolvidos com uma única classe.\nMas para projetos maiores é muito difícil conseguir tratar todos os detalhes ao mesmo tempo.\nO que fazemos então é identificar subcomponentes do problema que possam ser tratados em classes separadas."
  },
  {
    "objectID": "cap3-1.html#section-2",
    "href": "cap3-1.html#section-2",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Para lidar com a complexidade, usamos a abstração."
  },
  {
    "objectID": "cap3-1.html#section-3",
    "href": "cap3-1.html#section-3",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande."
  },
  {
    "objectID": "cap3-1.html#section-4",
    "href": "cap3-1.html#section-4",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas."
  },
  {
    "objectID": "cap3-1.html#section-5",
    "href": "cap3-1.html#section-5",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas.\n\nE dividimos novamente em problemas ainda menores."
  },
  {
    "objectID": "cap3-1.html#section-6",
    "href": "cap3-1.html#section-6",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas.\n\nE dividimos novamente em problemas ainda menores.\nFazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles."
  },
  {
    "objectID": "cap3-1.html#section-7",
    "href": "cap3-1.html#section-7",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas.\n\nE dividimos novamente em problemas ainda menores.\nFazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.\n\nDepois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles."
  },
  {
    "objectID": "cap3-1.html#section-8",
    "href": "cap3-1.html#section-8",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas.\n\nE dividimos novamente em problemas ainda menores.\nFazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.\n\nDepois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles.\n\nE os utilizamos como blocos (caixa-preta) para resolver os problemas maiores."
  },
  {
    "objectID": "cap3-1.html#section-9",
    "href": "cap3-1.html#section-9",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O problema a ser resolvido, às vezes é muito grande.\n\nNós então dividimos o problema subproblemas.\n\nE dividimos novamente em problemas ainda menores.\nFazemos isso até que eles sejam pequenos o suficiente para que consigamos lidar com eles.\n\nDepois dos subproblemas estarem resolvidos, não pensamos mais nos detalhes deles.\n\nE os utilizamos como blocos (caixa-preta) para resolver os problemas maiores.\nAté termos todo o problema resolvido."
  },
  {
    "objectID": "cap3-1.html#section-10",
    "href": "cap3-1.html#section-10",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Essa técnica de dividir o problema em problemas menores é chamada de dividir para conquistar.\n\nPodemos entender isso melhor com um exemplo."
  },
  {
    "objectID": "cap3-1.html#section-11",
    "href": "cap3-1.html#section-11",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos pensar em uma equipe de engenheiros projetando um carro.\n\nEles pensam nas partes do carro: design, tamanho, local do motor, quantidade de assentos, espaçamento entre rodas, etc.\n\n1\nImagem de vectorjuice no Freepik"
  },
  {
    "objectID": "cap3-1.html#section-12",
    "href": "cap3-1.html#section-12",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Outra equipe de engenheiros projeta o motor.\n\nEles pensam em cada parte do motor: as cilindradas, o mecanismo de injeção, a eletrônica, etc.\nPara eles o motor não é uma peça única, e sim um sistema complexo de várias partes \nUma delas pode ser a vela de ignição."
  },
  {
    "objectID": "cap3-1.html#section-13",
    "href": "cap3-1.html#section-13",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Há então uma terceira equipe de engenheiros (muitas vezes de outra empresa) que projeta a vela de ignição.\n\nEles pensam na vela como um sistema com várias partes. \nEles podem ter feito estudos complexos para saber o metal certo a ser usado, e como é o processo detalhado de fabricação e instalação."
  },
  {
    "objectID": "cap3-1.html#section-18",
    "href": "cap3-1.html#section-18",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "A mesma ideia de modularização e abstração do exemplo do carro é aplicada no desenvolvimento de software.\n\nPara conseguirmos implementar um sistema complexo, nós tentamos dividi-lo em subcomponentes que possamos programar de forma independente.\nDepois tentamos usar esses componentes, como se eles fossem partes simples, sem nos preocuparmos com seus detalhes internos.\n\n\nEm POO, os componentes e subcomponentes são objetos.\n\nPara criar um carro completo em um sistema OO, faríamos como no exemplo da fábrica.\nCriaríamos objetos separados para motor, roda, caixa de marcha, etc.\nE usaríamos esses objetos para construir um objeto carro."
  },
  {
    "objectID": "cap3-1.html#section-19",
    "href": "cap3-1.html#section-19",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Não é simples pensar nos tipos de objetos (e, consequentemente, nas classes) que precisamos ter em um software.\n\nPor isso, vamos começar com o exemplo simples do mostrador do relógio."
  },
  {
    "objectID": "cap3-1.html#quiz-3.1",
    "href": "cap3-1.html#quiz-3.1",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Quiz 3.1",
    "text": "Quiz 3.1\n\nO conceito de abstração tem relação com:\n\nPrestar muita atenção aos detalhes de um problema.\nIgnorar completamente os detalhes de um problema.\nDividir um problema em problemas menores de forma a ter diferentes níveis de atenção aos seus detalhes.\nCriar atributos abstratos."
  },
  {
    "objectID": "cap3-1.html#section-20",
    "href": "cap3-1.html#section-20",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Voltando ao exemplo do visor de relógio digital, qual seria a maneira mais direta de implementá-lo?\n\nPoderíamos pensar em uma única classe que representasse os quatro dígitos do relógio, certo?\n\n\n\nMas vamos tentar usar modularização.\n\nComo você poderia dividir o “problema” de representar o visor, em subproblemas?"
  },
  {
    "objectID": "cap3-1.html#section-21",
    "href": "cap3-1.html#section-21",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Repare como funcionam os dígitos das horas.\n\nEles começam em 0, incrementam de 1 em 1, até chegar a 23, e depois voltam para zero.\n\n\nE como funcionam os dígitos dos minutos?\n\nEles começam em 0, incrementam de 1 em 1, até chegar a 59, e depois voltam para zero.\n\n\n\nRepare que o comportamento dos dígitos das horas e dos minutos é exatamente o mesmo.\n\nO que muda é apenas o valor limite que faz o valor voltar para zero.\nPodemos pensar então em um objeto capaz de representar um visor de dois dígitos. \nE poderíamos usar dois objetos desse tipo, um para as horas e outro para os minutos, para representar o relógio."
  },
  {
    "objectID": "cap3-1.html#section-22",
    "href": "cap3-1.html#section-22",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Precisamos então definir uma classe para representar um visor de número de dois dígitos.\n\nEla poderia ter um método de acesso para retornar seus valores.\nE dois métodos modificadores:\n\nPara definir o valor.\nE para incrementá-lo (adicionar 1), zerando ao chegar no limite.\n\n\n\nCom a classe pronta, podemos criar dois objetos dela com limites diferentes para representar o relógio."
  },
  {
    "objectID": "cap3-1.html#section-23",
    "href": "cap3-1.html#section-23",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Quais atributos são necessários na classe que representa números de dois dígitos?\n\nVeja que precisamos guardar o valor propriamente dito.\nE o limite que faz o valor voltar para zero.\n\n\nEsses valores devem ser de que tipo?\n\n\n\npublic class VisorDeNumero\n{\n    private int limite;\n    private int valor;\n\n    // construtor e métodos omitidos.\n}"
  },
  {
    "objectID": "cap3-1.html#section-24",
    "href": "cap3-1.html#section-24",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Antes de pensar nos detalhes da classe VisorDeNumero, imagine que já temos a classe pronta.\n\nComo poderíamos construir um visor de relógio completo, usando essa classe?\nPrecisamos de dois objetos visor de números (um para as horas e outro para os minutos).\n\nPortanto, cada um desses objetos deve ser um atributo na classe que representa o visor do relógio.\n\n\n\n\npublic class VisorDeRelogio\n{\n    private VisorDeNumero horas;\n    private VisorDeNumero minutos;\n\n    // construtor e métodos omitidos.\n}\n\n\n\nRepare que classes definem tipos."
  },
  {
    "objectID": "cap3-1.html#section-25",
    "href": "cap3-1.html#section-25",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O tipo de um atributo determina o tipo dos valores que ele pode guardar.\n\nSe o tipo é uma classe, o atributo pode guardar objetos daquela classe.\n\n\n\n\n\n\n\n\n\nDeclaração não cria objetos\n\n\nUma declaração de um atributo ou uma variável do tipo de uma classe não cria automaticamente um objeto daquela classe.\n\nA princípio o atributo ou variável fica vazio.\nPortanto, no construtor da classe VisorDeRelogio precisaremos criar os objetos a serem guardados pelos atributos.\n\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nClasses definem tipos. Um nome de classe pode ser usado como tipo de uma variável. Variáveis de tipo de uma classe podem guardar objetos daquela classe."
  },
  {
    "objectID": "cap3-1.html#section-26",
    "href": "cap3-1.html#section-26",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Compare as duas figuras abaixo:\n\nÀ esquerda temos o diagrama de objetos do visor de relógio.\nÀ direita temos o diagrama de classes para a mesma situação."
  },
  {
    "objectID": "cap3-1.html#section-27",
    "href": "cap3-1.html#section-27",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Repare que nós criamos dois objetos da mesma classe VisorDeNumero.\n\nOs dois diagramas mostram diferentes visões do mesmo programa.\n\nO diagrama de classes mostra uma visão estática.\n\nOu seja, representa o momento da programação, quando estamos escrevendo o código.\nDizemos que VisorDeRelogio usa (ou depende) de VisorDeNumero.\n\n\n\n\nQuando o programa é iniciado, vamos criar um objeto VisorDeRelogio.\n\nE vamos implementar a classe de forma que ela crie automaticamente dois objetos VisorDeNumero.\nPortanto, o diagrama de objetos mostra uma visão dinâmica.\nEle representa o tempo de execução, quando o programa está rodando."
  },
  {
    "objectID": "cap3-1.html#section-28",
    "href": "cap3-1.html#section-28",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos avaliar o diagrama de objetos novamente, pois ele traz um detalhe importante.\n\nRepare que quando uma variável guarda um objeto, ela não o guarda diretamente.\nNa verdade a variável guarda uma referência (um ponteiro) para o objeto .\n\n\nNo diagrama a variável é representada pela caixa branca.\n\nE a referência do objeto pela seta.\nPortanto, repare que o objeto VisorDeNumero é armazenado fora do objeto VisorDeRelogio.\n\nE a referência (o ponteiro) é que liga os dois."
  },
  {
    "objectID": "cap3-1.html#section-29",
    "href": "cap3-1.html#section-29",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nPense no projeto de exemplo disciplina que vimos antes. Suponha que criamos um objeto Disciplina e três objetos Estudante, e matriculamos os estudantes na disciplina. Tente desenhar um diagrama de classes e um diagrama de objetos para essa situação. Explique a diferença entre os diagramas."
  },
  {
    "objectID": "cap3-1.html#section-30",
    "href": "cap3-1.html#section-30",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nQuando um diagrama de classes é alterado? E como ele é alterado?\n\n\n\n\n\n\n\n\nExercício\n\n\nQuando um diagrama de objetos é alterado? E como ele é alterado?\n\n\n\n\n\n\n\n\nExercício\n\n\nEscreva a declaração de um atributo orientador que guarde uma referência para um objeto Professor."
  },
  {
    "objectID": "cap3-1.html#quiz-3.2",
    "href": "cap3-1.html#quiz-3.2",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Quiz 3.2",
    "text": "Quiz 3.2\n\nMarque a alternativa incorreta:\n\nClasses definem tipos.\nDiagramas de classes dão uma visão estática do programa.\nDiagramas de objetos dão uma visão dinâmica do programa.\nVisão estática se refere ao tempo de execução do programa."
  },
  {
    "objectID": "cap3-1.html#section-31",
    "href": "cap3-1.html#section-31",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Java tem dois tipos diferentes de tipos :)\n\n\n\nTipos primitivos\n \n\n\n\nTipos objeto (ou tipos por referência)\n\n\n\n\nTipos primitivos são predefinidos na linguagem Java\n\nEx.: int, boolean, double.\n\n\n\nJá os tipos objeto são definidos por classes.\n\nAlgumas classes fazem parte do Java padrão (como a String).\nE podemos criar nossas próprias classes."
  },
  {
    "objectID": "cap3-1.html#section-32",
    "href": "cap3-1.html#section-32",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Tipos objeto e tipos primitivos têm semelhanças:\n\nAmbos podem ser usados como tipos.\n\n\nMas se comportam de forma diferente:\n\nTipos primitivos são guardados diretamente nas variáveis.\n\nNo diagrama de objetos mostramos os valores diretamente nas caixas das variáveis.\n\nJá tipos objeto guardam apenas uma referência (ponteiro) para o objeto.\n\nNo diagrama representamos com uma seta.\n\n\n\n\n\n\n\n\nConceito\n\n\nOs tipos primitivos em Java não definem objetos. Tipos como int, boolean e double são os tipos primitivos mais comuns. Tipos primitos não possuem métodos."
  },
  {
    "objectID": "cap3-1.html#section-33",
    "href": "cap3-1.html#section-33",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Antes de vermos o exemplo do relógio, é importante entendermos a classe VisorDeNumero.\n\nE assim sabermos como ela pode ser usada para construir o relógio.\n\n\nVamos avaliar o código da classe, baixando o projeto visor-numero."
  },
  {
    "objectID": "cap3-1.html#section-34",
    "href": "cap3-1.html#section-34",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nNo BlueJ acesse a opção: Exibir → Exibir terminal, e no terminal acesse Opcoes → Anotar chamadas de métodos.\nCrie um objeto VisorDeNumero com limite 24 e dê o nome horas para a variável.\n\nAbra o inspetor e, com ele aberto, chame o método incrementar do objeto criado.\nRepare, no terminal, como é a chamada do método.\nChame repetidamente o método incrementar até que ele volte para zero. Obs.: use um limite menor se estiver impaciente :)"
  },
  {
    "objectID": "cap3-1.html#section-35",
    "href": "cap3-1.html#section-35",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nCrie outro objeto VisorDeNumero, com limite 60 , e dê o nome minutos.\n\nChame o método incrementar do objeto e repare como é a chamada no terminal.\nRepare que você está fazendo o papel do relógio já que tem um visor de horas e um de minutos.\nO que você deveria fazer a cada chamada do método incrementar para o objeto minutos para saber se é hora de incrementar o objeto de horas?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nUsando o bloco de códigos do BlueJ, crie um objeto VisorDeNumero, chamado vn, com limite 6, e experimente todos os seus métodos."
  },
  {
    "objectID": "cap3-1.html#section-36",
    "href": "cap3-1.html#section-36",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nExperimente digitar o código abaixo no Bloco de Códigos:\n\nVisorDeNumero.obterValor();\n\nO que a mensagem de erro indica?\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente agora a linha abaixo:\n\nvn.definirValor(int 5);\n\nA mensagem de erro, nesse caso, te ajuda a identificar o problema?\nTente corrigir o código e memorizar essa situação que é muito comum para quem está começando."
  },
  {
    "objectID": "cap3-1.html#section-37",
    "href": "cap3-1.html#section-37",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Repare que o método definirValor utiliza uma expressão booleana\n\npublic void definirValor(int novoValor)\n{\n    if((novoValor &gt;= 0) && (novoValor &lt; limite)) {\n        valor = novoValor;\n    }\n}\n\n\nEm Java, os operadores lógicos são:\n\n&&\n\ne lógico (and em C++).\n\n||\n\nou lógico (or em C++).\n\n!\n\nnegação (not em C++)."
  },
  {
    "objectID": "cap3-1.html#section-38",
    "href": "cap3-1.html#section-38",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nO que acontece quando o método definirValor é chamado com um valor inválido (experimente!).\nVocê acha que da forma que foi feito é uma boa solução? Consegue pensar em uma solução melhor?\n\n\n\n\n\n\n\n\nExercício\n\n\nO que aconteceria se, no método definirValor, o operador &gt;= fosse trocado por &gt;?\n\n\n\n\n\n\n\n\nExercício\n\n\nO que aconteceria se, no método definirValor, o operador && fosse trocado por ||?"
  },
  {
    "objectID": "cap3-1.html#section-39",
    "href": "cap3-1.html#section-39",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nEstude a implementação dos métodos obterValorVisor e incrementar. Caso tenha dúvidas, estude as páginas 56 a 59 do livro do Barnes e Kölling (4ª ed.).\n\n\n\n\n\n\n\n\nExercício\n\n\nO método obterValorVisor sempre funciona corretamente? Quais premissas ele assume? O que acontece, por exemplo, se você criar um objeto com limite 800?"
  },
  {
    "objectID": "cap3-1.html#section-40",
    "href": "cap3-1.html#section-40",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Agora que já entendemos como criar uma classe que define um visor de números de dois dígitos, vamos estudar o projeto visor-relogio.\n\nEle possui a classe VisorDeRelogio que cria dois objetos visores de números para construir o visor completo do relógio."
  },
  {
    "objectID": "cap3-1.html#section-41",
    "href": "cap3-1.html#section-41",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nCrie um objeto VisorDeRelogio, selecionando este construtor:\n\n  new VisorDeRelogio()\n\nChame o método obterHora para descobrir a hora inicial que o relógio foi criado. Você consegue imaginar porque ele começa nesse horário específico?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAbra o inspetor para esse objeto. Com o inspetor aberto, chame os métodos do objeto, observando o atributo stringVisor no inspetor. No BlueJ, abra o arquivo README.md para entender melhor o funcionamento do projeto.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nQuantas vezes você precisa chamar o método tiqueTaque no objeto VisorDeRelogio para fazer sua hora chegar a 01:00. De que outra forma você poderia fazer o relógio mostrar esse mesmo horário?"
  },
  {
    "objectID": "cap3-1.html#section-42",
    "href": "cap3-1.html#section-42",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos agora estudar a classe VisorDeRelogio.\n\nAbra a classe e avalie todo o código.\n\n\nVeja que o atributo stringVisor simula um visor físico real do relógio.\n\nSe esse software rodasse em um relógio de verdade, nós mostraríamos a informação no visor físico.\nAqui, o atributo stringVisor serve para simular o visor real do relógio.\n\n\n\nA classe VisorDeRelogio tem mais dois atributos: horas e minutos.\n\nEles guardam referências para objetos do tipo VisorDeNumero.\nO valor lógico do horário do relógio é guardado nesses dois atributos."
  },
  {
    "objectID": "cap3-1.html#section-43",
    "href": "cap3-1.html#section-43",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O digrama de objetos abaixo mostra de forma mais completa um objeto VisorDeRelogio.\n\nVeja que todos os atributos são referências para outros objetos.\nInclusive stringVisor, já que uma string é um objeto em Java.\n\nObs.: por simplicidade, o diagrama não mostra a representação interna do objeto String."
  },
  {
    "objectID": "cap3-1.html#section-44",
    "href": "cap3-1.html#section-44",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Só para os curiosos\n\n\nVocê pode também abrir o projeto visor-relogio-com-interface-grafica. Veja que ele possui uma classe a mais que você pode experimentar e ver o que faz."
  },
  {
    "objectID": "cap3-1.html#section-45",
    "href": "cap3-1.html#section-45",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vimos que um visor de relógio possui dois visores de números, para horas e minutos.\n\nMas de onde vêm esses objetos no código?\n\n\nVeja que, como usuários do mostrador de relógio, nós criamos apenas o objeto da classe VisorDeRelogio.\n\nE esperamos que os visores de números sejam criados implicitamente.\n\n\n\nMas, como programadores da classe VisorDeRelogio, nós precisamos fazer isso acontecer.\n\nPara isso, basta criarmos os objetos VisorDeNumero dentro do construtor da classe VisorDeRelogio.\nComo o construtor é chamado quando um objeto VisorDeRelogio é criado, os visores de número serão criados automaticamente."
  },
  {
    "objectID": "cap3-1.html#section-46",
    "href": "cap3-1.html#section-46",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos analisar como o construtor de VisorDeRelogio faz isso:\n\npublic class VisorDeRelogio\n{\n    private VisorDeNumero horas;\n    private VisorDeNumero minutos;\n\n    // Atributos restantes omitidos\n\n    public VisorDeRelogio()\n    {\n        horas = new VisorDeNumero(24);\n        minutos = new VisorDeNumero(60);\n        atualizarVisor();\n    }\n\n    // Métodos omitidos\n}"
  },
  {
    "objectID": "cap3-1.html#section-47",
    "href": "cap3-1.html#section-47",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos analisar como o construtor de VisorDeRelogio faz isso:\n\npublic class VisorDeRelogio\n{\n    private VisorDeNumero horas;\n    private VisorDeNumero minutos;\n\n    // Atributos restantes omitidos\n\n    public VisorDeRelogio()\n    {\n        horas = new VisorDeNumero(24);\n        minutos = new VisorDeNumero(60);\n        atualizarVisor();\n    }\n\n    // Métodos omitidos\n}\n\nAs duas primeiras linhas do construtor criam objetos VisorDeNumero\n\nE os atribuem a variáveis."
  },
  {
    "objectID": "cap3-1.html#section-48",
    "href": "cap3-1.html#section-48",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Repare a sintaxe do comando que cria um novo objeto:\n\n\n  new NomeDaClasse(lista_de_parametros)\n\n\n\nO operador new faz duas coisas:\n\nCria um novo objeto da classe nomeada (no nosso exemplo VisorDeNumero).\nExecuta o construtor daquela classe.\n\n\n\nSe o construtor da classe tiver parâmetros, os valores deles devem ser passados."
  },
  {
    "objectID": "cap3-1.html#section-49",
    "href": "cap3-1.html#section-49",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Repare, por exemplo, que o construtor da classe VisorDeNumero espera um valor inteiro como parâmetro.\n\n  public VisorDeNumero(int limiteParaZerar)\n\n\nCom isso, ao usarmos o operador new para criar um objeto VisorDeNumero, como ele chama o construtor da classe, precisaremos fornecer um argumento inteiro.\n\n  new VisorDeNumero(24);\n\n\nNote que a passagem de parâmetros funciona da mesma forma que já tínhamos visto para os métodos."
  },
  {
    "objectID": "cap3-1.html#section-50",
    "href": "cap3-1.html#section-50",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Veja que da forma que fizemos, ficou como gostaríamos:\n\nComo usuários do VisorDeRelogio:\n\nCriamos apenas esse objeto, e os visores de números são criados implicitamente.\n\nJá como programadores da classe:\n\nPrecisamos explicitar a criação dos objetos, escrevendo código para isso.\n\n\n\nObs.: ao final do construtor, o método atualizarVisor é chamado. Conversaremos sobre ele mais adiante."
  },
  {
    "objectID": "cap3-1.html#section-51",
    "href": "cap3-1.html#section-51",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nEscreva comandos em Java que declarem uma variável chamada janela, do tipo Retangulo, e então crie um objeto Retangulo e o atribua à variável. Assuma que o construtor de Retangulo tem dois parâmetros do tipo int."
  },
  {
    "objectID": "cap3-1.html#quiz-3.3",
    "href": "cap3-1.html#quiz-3.3",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Quiz 3.3",
    "text": "Quiz 3.3\n\nMarque a alternativa correta:\n\nAtributos de tipo objeto guardam referências (ponteiros) para objetos.\nAtributos de tipo primitivo guardam referências (ponteiros) para objetos primitivos.\nObjetos só podem criar outros objetos dentro de construtores.\nObjetos são criados usando o operador create."
  },
  {
    "objectID": "cap3-1.html#section-52",
    "href": "cap3-1.html#section-52",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Ao criar objetos da classe VisorDeRelogio, usando o BlueJ, você deve ter notado que há duas opções no menu para criar o objeto.\n\n  new VisorDeRelogio()\n  new VisorDeRelogio(int hora, int minuto)\n\n\nIsso acontece porque VisorDeRelogio tem dois construtores.\n\nEles servem para fornecer formas alternativas de inicializar um objeto VisorDeRelogio.\n\nCom o construtor sem parâmetros, criamos um relógio com hora inicial 00:00.\nJá usando o segundo construtor, podemos criar um relógio com hora inicial diferente.\n\n\n\n\nÉ comum que classes tenham vários construtores para dar várias opções de criação dos seus objetos.\n\nPara isso funcionar, cada construtor deve ter um conjunto diferente de parâmetros.\nDamos a isso o nome de sobrecarga de construtores."
  },
  {
    "objectID": "cap3-1.html#section-54",
    "href": "cap3-1.html#section-54",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Assim como os construtores, métodos também podem ser sobrecarregados."
  },
  {
    "objectID": "cap3-1.html#section-55",
    "href": "cap3-1.html#section-55",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O que pode e o que não pode ser feito em termos de sobrecarga tem a ver com o que o compilador consegue identificar.\n\n\nImagine a chamada abaixo:\n\n    meuCarro.deslocar(68.5);\n\n\n\nComo o compilador conseguiria definir qual dos métodos está sendo chamado?\n\nO compilador não consegue!\nPortanto, não é possível criar dois métodos sobrecarregados dessa forma."
  },
  {
    "objectID": "cap3-1.html#section-56",
    "href": "cap3-1.html#section-56",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Mais uma vez vamos pensar em um exemplo de chamada:\n\n\n\n    int a = meuCarro.acelerar();\n\n\n\nNesse caso, parece que seria possível pois o compilador sabe que a variável a é do tipo int.\n\nMas na verdade você não é obrigado a usar o valor retornado por uma chamada de método.\n  meuCarro.acelerar();\nA chamada acima, por exemplo é válida, e, nesse caso, o compilador não consegue definir qual método será chamado.\nPortanto, não é possível declarar métodos sobrecarregados dessa forma."
  },
  {
    "objectID": "cap3-1.html#section-57",
    "href": "cap3-1.html#section-57",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Conceito\n\n\nSobrecarga: Uma classe pode ter mais de um construtor, ou mais de um método com o mesmo nome, desde que cada um tenha um conjunto diferente de tipos de parâmetros (ou seja, a quantidade ou a ordem dos tipos dos parâmetros precisa ser diferente).\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAvalie o segundo construtor no código da classe VisorDeRelogio. Explique o que ele faz e como ele o faz.\nIdentifique as semelhanças e diferenças entre os dois construtores. Porque o método atualizarVisor não é chamado no segundo construtor, por exemplo?"
  },
  {
    "objectID": "cap3-1.html#section-58",
    "href": "cap3-1.html#section-58",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "A última linha do construtor de VisorDeRelogio tem o comando atualizarVisor.\n\n    public VisorDeRelogio()\n    {\n        horas = new VisorDeNumero(24);\n        minutos = new VisorDeNumero(60);\n        atualizarVisor();\n    }\n\n\nEste comando é uma chamada de método.\n\nVocê já deve ter visto que a classe VisorDeRelogio tem um método com a seguinte assinatura:\n\n  private void atualizarVisor()\n\n\n\n\nPortanto, o último comando no construtor, chama este método.\n\nComo o método está na mesma classe, a essa operação damos o nome de chamada de método interno."
  },
  {
    "objectID": "cap3-1.html#section-59",
    "href": "cap3-1.html#section-59",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Uma chamada de método interno tem a seguinte sintaxe:\n\n\n  nomeDoMetodo(lista_de_parametros)\n\n\n\nRepare que uma chamada de método interno não usa variável, nem ponto.\n\nNão é necessário usar variável porque o objeto chama o método dele mesmo.\n\n\n\nMétodos podem ter parâmetros ou não.\n\nNesse exemplo, como o método não tem parâmetros, não passamos nenhum valor na chamada do método."
  },
  {
    "objectID": "cap3-1.html#section-60",
    "href": "cap3-1.html#section-60",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Quando há uma chamada de método, o método correspondente é executado.\n\nE, então, a execução retorna para onde o método foi chamado e continua depois dela.\nO método correspondente precisa ter o mesmo nome e a mesma sequência de tipos de parâmetros.\n\nJá que podem existir métodos sobrecarregados."
  },
  {
    "objectID": "cap3-1.html#section-61",
    "href": "cap3-1.html#section-61",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Vamos agora avaliar o código do método tiqueTaque:\n\n\n    public void tiqueTaque()\n    {\n        minutos.incrementar();\n        if(minutos.obterValor() == 0) {  // minutos voltaram para zero\n            horas.incrementar();\n        }\n        atualizarVisor();\n    }\n\n\n\nSe este visor estivesse conectado a um relógio de verdade, este método seria chamado a cada 60 segundos por um temporizador eletrônico do relógio.\n\nAqui, nós mesmos chamamos o método para testar o visor."
  },
  {
    "objectID": "cap3-1.html#section-62",
    "href": "cap3-1.html#section-62",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "public void tiqueTaque()\n    {\n        minutos.incrementar();\n        if(minutos.obterValor() == 0) {  // minutos voltaram para zero\n            horas.incrementar();\n        }\n        atualizarVisor();\n    }\n\nA primeira linha do método chama o comando incrementar do objeto minutos.\n\nVeja então que, dessa forma, quando um dos métodos do VisorDeRelogio é chamado, ele, por sua vez, chama um método de outro objeto como parte da tarefa.\n\n\nUma chamada a um método de outro objeto é uma chamada de método externo."
  },
  {
    "objectID": "cap3-1.html#section-63",
    "href": "cap3-1.html#section-63",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Uma chamada de método externo tem a seguinte sintaxe:\n\n\n  objeto . nomeDoMetodo (lista_de_parametros)\n\n\n\nEssa sintaxe é conhecida como notação de ponto (dot notation).\n\nUsamos o nome do objeto, seguido de ponto, seguindo do nome do método, seguido dos parâmetros do método.\nRepare que usamos o nome do objeto e não da classe."
  },
  {
    "objectID": "cap3-1.html#section-64",
    "href": "cap3-1.html#section-64",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Veja que, quando usamos o nome de objeto, temos uma chamada de método externo.\n\nO que é bem diferente de uma chamada de método interno.\nPorque, ao chamar o método externo, estamos pedindo a um objeto VisorDeNumero para fazer parte da tarefa completa.\n\n\nPodemos dizer que a tarefa de manter as horas é dividida entre as classe VisorDeRelogio e VisorDeNumero.\n\nEste é um exemplo prático do princípio de dividir e conquistar que vimos no início do capítulo ao discutirmos sobre abstração."
  },
  {
    "objectID": "cap3-1.html#section-65",
    "href": "cap3-1.html#section-65",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "public void tiqueTaque()\n    {\n        minutos.incrementar();\n        if(minutos.obterValor() == 0) {  // minutos voltaram para zero\n            horas.incrementar();\n        }\n        atualizarVisor();\n    }\n\nRepare que a linha seguinte do método tiqueTaque faz outra chamada de método externo.\n\nO método retorna o valor atual dos minutos.\nSe ele acabou de ir para zero, é hora de incrementar as horas, e isso é feito em seguida."
  },
  {
    "objectID": "cap3-1.html#section-66",
    "href": "cap3-1.html#section-66",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Podemos agora entender os demais métodos da classe.\n\nIdentifique neles onde ocorrem chamadas de método interno e chamadas de método externo.\n\n\n\n\n\n\nConceito\n\n\nMétodos podem chamar outros métodos da mesma classe como parte de sua implementação. Chamamos isso de chamada de método interno.\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nMétodos podem chamar métodos de outros objetos usando notação de ponto. Chamamos isso de chamada de método externo."
  },
  {
    "objectID": "cap3-1.html#section-67",
    "href": "cap3-1.html#section-67",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nSuponha que exista uma variável chamada imp1 do tipo Impressora, que referencia um objeto impressora, cuja classe tem métodos com as seguintes assinaturas:\n\n  public void imprimir(String nomeDoArquivo, boolean dosDoisLados)\n  public int obterSituacao(int atraso)\n\nEscreva duas possíveis chamadas para cada um desses métodos.\n\n\n\n\n\n\n\n\nExercício\n\n\nAbra o projeto casa e avalie a classe Figura. Que tipos de objetos são criados no construtor de Figura?\n\n\n\n\n\n\n\n\nExercício\n\n\nListe todas as chamadas de métodos externos que são feitas no método desenhar da classe Figura para o objeto Triangulo chamado telhado."
  },
  {
    "objectID": "cap3-1.html#section-68",
    "href": "cap3-1.html#section-68",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nRemova as duas linhas abaixo do método desenhar da classe Figura, fazendo com que a definição das cores seja feita através de uma chamada de um método interno chamado definirCor (que você precisará criar).\n\n  janela.mudarCor(\"preta\");\n  sol.mudarCor(\"amarela\");"
  },
  {
    "objectID": "cap3-1.html#quiz-3.4",
    "href": "cap3-1.html#quiz-3.4",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Quiz 3.4",
    "text": "Quiz 3.4\n\nMarque a alternativa incorreta:\n\nConstrutores e métodos podem ser sobrecarregados.\nMétodos sobrecarregados são aqueles que têm muitos comandos.\nMétodos sobrecarregados são métodos de uma mesma classe que possuem o mesmo nome.\nObjetos podem chamar métodos de outros objetos através de chamadas de método externo."
  },
  {
    "objectID": "cap3-1.html#section-69",
    "href": "cap3-1.html#section-69",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "É importante reforçarmos como o projeto do visor de relógio usa o conceito de abstração para dividir o problema em problemas menores.\n\nRepare que, no código da classe VisorDeRelogio, criamos objetos VisorDeNumero sem nos preocupar sobre os detalhes internos desses objetos.\nDepois chamamos métodos (incrementar e obterValor) dos objetos para fazer o que precisamos.\n\nNesse ponto, assumimos que o método incrementar vai mudar corretamente o valor, sem preocuparmos com como ele faz isso."
  },
  {
    "objectID": "cap3-1.html#section-70",
    "href": "cap3-1.html#section-70",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Em projetos reais, muitas vezes classes diferentes são feitas por pessoas diferentes.\n\nSe tivéssemos feito assim para o exemplo do visor de relógio, o que as duas pessoas precisariam entrar em acordo?\n\nPrecisariam concordar, apenas, sobre as assinaturas de método e o que os métodos fazem.\nNão seria necessário discutir como eles fazem.\n\nFeito isso, uma pessoa poderia implementar os métodos e a outra apenas os usaria.\n\n\nO conjunto dos métodos (assinaturas) que um objeto disponibiliza para outros objetos é chamado de interface.\n\nEsse conceito traz um poder enorme para a Orientação a Objetos.\nVocê poderá conhecê-lo melhor e utilizar todo o seu poder na disciplina PPOO ;)"
  },
  {
    "objectID": "cap3-1.html#section-71",
    "href": "cap3-1.html#section-71",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício de Implementação 1\n\n\nMude o relógio para que ele funcione como relógios americanos, mostrando 12 horas em vez de 24.\nRepare que isso pode ser mais difícil do que parece, depois da meia-noite e do meio-dia, o relógio deve mostrar 12:30 e não 00:30. Portanto, os minutos devem ir de 1 a 59, mas as horas devem ir de 1 a 12.\n\n\n\n\n\n\n\n\n(Opcional) Exercício de Implementação 2\n\n\nHá pelo menos duas formas de fazer o exercício anterior. Você poderia armazenar as horas com valores entre 1 e 12. Ou poderia deixar o relógio funcionando internamente com um relógio de 24 horas e tratar apenas a stringVisor para mostrar horas no formato esperado de 12 horas.\nImplemente as duas opções (você deve ter dois projetos separados no BlueJ, um com cada implementação).\nQual opção é mais fácil? Qual é melhor? Por que?"
  },
  {
    "objectID": "cap3-1.html#section-72",
    "href": "cap3-1.html#section-72",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "(Opcional) Exercício - Desafio\n\n\nSuponha que uma classe Arvore tenha um atributo do tipo Triangulo chamado folhas e um atributo do tipo Quadrado chamado tronco. O construtor de Arvores não espera nenhum parâmetro, e seu construtor cria objetos Triangulo e Quadrado para seus atributos.\nUsando o projeto figuras, crie uma classe Arvore que corresponda a essa descrição. Neste exercício, não é necessário definir nenhum método, e nem tratar a forma da árvore.\n\n\n\n\n\n\n\n\n(Opcional) Exercício - Desafio\n\n\nAgora complete a classe Arvore do exercício anterior. O construtor deve mover o tronco para debaixo das folhas e fazer ambos serem exibidos. Faça isso criando um método chamado configurar e incluindo uma chamada a este método no construtor. Mude o tamanho do triângulo de forma que a árvore se pareça um pinheiro."
  },
  {
    "objectID": "cap3-1.html#section-73",
    "href": "cap3-1.html#section-73",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Como você já sabe das aulas anteriores, para que você tenha a presença\n\nconsiderada nas aula em formato ANP (Atividade Não-Presencial),\nvocê precisa demonstrar que realmente estudou o conteúdo.\n\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nPara ter presença nessa aula você deve:\n\nResponder, no Campus Virtual, aos quizes presentes nesses slides e enviar o projeto dos exercício de implementação 1."
  },
  {
    "objectID": "cap2-3.html#como-estudar-precisa-repetir",
    "href": "cap2-3.html#como-estudar-precisa-repetir",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Como estudar? Precisa repetir? :)",
    "text": "Como estudar? Precisa repetir? :)\nComo diz o ditado: água mole em pedra dura tanto bate até que fura.\nEntão vamos relembrar as dicas:\n\n\n\nÉ essencial praticar enquanto estuda, usando o BlueJ.\nAjuda muito se você ler o capítulo do livro da disciplina para tirar dúvidas e complementar o que está sendo estudado.\nUse um caderno e caneta para anotar os principais conceitos e eventuais dúvidas que surgirem."
  },
  {
    "objectID": "cap2-3.html#section",
    "href": "cap2-3.html#section",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nas aulas anteriores você deve ter percebido que a classe MaquinaIngressos não serviria muito no mundo real, já que ela tem vários problemas.\n\nNão verifica se o cliente colocou dinheiro suficiente para comprar o ingresso.\nNão retorna troco se o cliente colocou mais dinheiro que o necessário.\nNão verifica se a quantidade de dinheiro faz sentido (aceita valor negativo, por exemplo).\n\nE o mesmo para o preço do ingresso (passado para o construtor).\n\n\n\nCorrigindo isso, teríamos um software que realmente poderia servir de base para uma máquina de ingressos real.\n\nVamos então avaliar o projeto maquina-ingressos-melhor, que tenta resolver os problemas apontados.\n\n\n\nAntes de analisarmos o código, experimente criar uma máquina de ingressos e chamar seus métodos e verifique o que funciona de forma diferente.\n\nVeja que há um novo método retornarTroco. Veja o que acontece quando ele é chamado."
  },
  {
    "objectID": "cap2-3.html#section-1",
    "href": "cap2-3.html#section-1",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Dê uma olhada no código da classe MaquinaIngressos do novo projeto.\n\nVeja que o nome da classe, os atributos, o construtor e os métodos de acesso são os mesmos da versão anterior.\nA primeira mudança está no método inserirDinheiro.\n\nVeja que o método possui um tratamento para evitar que o usuário insira quantidades negativas de dinheiro.\n\n\n\nNa disciplina anterior de algoritmos você já aprendeu a usar comandos condicionais (if/ else).\n\nNote que a sintaxe do comando if em Java é a mesma do C++.\nComo você deve se lembrar, colocamos no comando if uma expressão booleana que pode ser verdadeira (true) ou falsa (false).\n\nSe a expressão for verdadeira, o bloco de código (trecho entre chaves) logo após o if é executado.\nSe for falsa, o bloco de código executado é aquele logo após o else."
  },
  {
    "objectID": "cap2-3.html#section-2",
    "href": "cap2-3.html#section-2",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nCompare a implementação do método imprimirIngresso no projeto maquina-ingressos-melhor com o projeto anterior. Experimente com o BlueJ situações iguais nos dois projetos e compare o que acontece. Repare que, além de ter um comando condicional, o total e o saldo são atualizados de forma diferente.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nSeria possível remover o bloco else do método imprimirIngresso? Qual seria o efeito para o usuário, quando ele tentasse imprimir um ingresso sem inserir quantidade suficiente de dinheiro.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAvalie a implementação do método retornarTroco. Experimente colocar mais dinheiro que o necessário para um ingresso, imprima um ingresso e então chame o método retornarTroco. Tente também chamar o método quando não há saldo de dinheiro disponível."
  },
  {
    "objectID": "cap2-3.html#section-3",
    "href": "cap2-3.html#section-3",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Ao avaliar o código de uma classe no BlueJ, você deve ter notado que ele mostra caixas coloridas ao redor de alguns elementos.\n\nComo ao redor dos blocos e comandos condicionais, por exemplo.\n\n\nEsses destaques coloridos são chamados de scope highlighting (ou destaque de escopo).\n\nEles nos ajudam a atender as unidades lógicas do programa.\nUm escopo, ou bloco, é o código que existe entre um par de chaves.\n\nO corpo de uma classe é um escopo.\nO corpo de cada método também é um escopo.\nE mesmo a parte do if de um comando condicional também é um escopo.\nPortanto, podemos ter escopos aninhados (ou seja, um dentro do outro)."
  },
  {
    "objectID": "cap2-3.html#section-4",
    "href": "cap2-3.html#section-4",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O BlueJ nos ajuda a identificar os escopos usando cores diferentes para cada um.\n\nNa imagem vemos com fundo branco os escopos de cada bloco do if e else.\nCom fundo roxo, o escopo do comando condicional.\nCom fundo amarelo o escopo do método.\nE com fundo verde o escopo da classe."
  },
  {
    "objectID": "cap2-3.html#section-5",
    "href": "cap2-3.html#section-5",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Um erro muito comum para quem está começando é esquecer de fechar as chaves, ou colocar uma chave em um lugar errado.\n\nAs cores do BlueJ nos ajudam a identificar esse tipo de problema.\nAlém disso, é muito importante indentar o código, usando tabulação para cada bloco de código (cada trecho entre chaves).\n\n\n\n\n\n\n\n\n\n\nConvenção\n\n\nSe a sua indentação estiver ficando uma bagunça, o BlueJ pode te ajudar. Experimente alterar o código e forma que a indentação fique errada e depois a corriga automaticamente, acessando o menu Editar → Auto-indentação do editor de código do BlueJ."
  },
  {
    "objectID": "cap2-3.html#section-6",
    "href": "cap2-3.html#section-6",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nExperimente remover uma chave do código da classe MaquinaIngressos e repare o que é alterado nas cores de fundo do editor de código. Experimente também inserir uma chave onde ela não seria esperada.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nEscreva um trecho de código em Java que compara o valor das variáveis preco e estimativa. Se o preço for maior que a estimativa, deve ser exibida a mensagem Muito caro.. Se o preço estiver abaixo da estimativa, a mensagem exibida deve ser Bora comprar, tá barato.. Por fim, se o preço for exatamente igual à estimativa, exiba a mensagem Na mosca!.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nLeia o anexo D.2 do livro do Barnes e Kölling para saber mais sobre os comandos condicionais da linguagem Java. Você verá mais detalhes sobre o comando if e também conhecerá o comando switch."
  },
  {
    "objectID": "cap2-3.html#section-7",
    "href": "cap2-3.html#section-7",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Até agora usamos dois tipos de variáveis: atributos (variáveis de instância) e parâmetros.\n\nVamos agora conhecer um terceiro tipo.\nO que os três tipos têm em comum?\n\nTodas eles servem para armazenar dados, mas cada um tem um objetivo diferente.\n\n\n\nRepare o código do método retornarTroco.\n\nEle possui três comandos e uma declaração (da variável troco).\n\n\npublic int retornarTroco()\n{\n    int troco;\n    troco = saldo;\n    saldo = 0;\n    return troco;\n}"
  },
  {
    "objectID": "cap2-3.html#section-8",
    "href": "cap2-3.html#section-8",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Como podemos saber que a variável troco não é um atributo?\n\nPor que atributos são declarados fora dos métodos (diretamente no escopo da classe).\n\n\nE como sabemos que ela não é um parâmetro?\n\nPor que parâmetros são declarados na assinatura dos métodos e construtores.\n\n\n\nA variável troco é de um terceiro tipo: ela é uma variável local.\n\nTem esse nome porque ela é declarada dentro do corpo de um método.\nE, portanto, tem um escopo local (do método).\n\n\n\nVariáveis locais são declaradas como os atributos (mas sem os modificadores public e private).\n\nE a principal diferença é o tempo de vida.\nVariáves locais existem somente durante a execução do método.\n\nDiferente dos atributos que existem na memória enquanto o objeto existir."
  },
  {
    "objectID": "cap2-3.html#section-9",
    "href": "cap2-3.html#section-9",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nós evitamos declarar como atributos variáveis que não precisam ser mantidas em memória depois que o método é chamado.\n\nRepare que atributos são características dos objetos.\nJá variáveis locais são apenas informações temporárias usadas para fazer algo durante a execução de um método.\nPortanto, se algo só precisa existir durante a execução do método, declará-lo como atributo desperdiçaria memória e feriria o conceito de objetos."
  },
  {
    "objectID": "cap2-3.html#section-10",
    "href": "cap2-3.html#section-10",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nós usamos variáveis locais mesmo quando dois métodos na mesma classe têm variáveis locais com o mesmo objetivo (muitas vezes com o mesmo nome).\n\nÉ tentador declarar como atributo para “reaproveitar” a mesma declaração.\nMas, não devemos usar atributos para valores que não precisam existir depois da chamada dos métodos.\n\n\nPor exemplo:\n\nNo método retornarTroco, a variável troco é usada, temporariamente, apenas para guardar o valor do saldo antes dele ser zerado.\nDepois que o método é finalizado, não faz mais sentido guardar o valor do troco.\n\n\n\n\n\n\n\nCuidado\n\n\nSe você declarar uma variável local (ou um parâmetro) com o mesmo nome de um atributo, você não conseguirá acessar o atributo diretamente. No capítulo 3 aprenderemos um jeito de lidar com isso, se necessário."
  },
  {
    "objectID": "cap2-3.html#section-11",
    "href": "cap2-3.html#section-11",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nPorque a implementação alternativa do método retornarTroco abaixo não dá o mesmo resultado da original? Faça testes que mostrem como o funcionamento é diferente.\n\npublic int retornarTroco()\n{\n    saldo = 0;\n    return saldo;\n}\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAltere o método retornarTroco usando a implementação abaixo. O código compila? Se não, explique porque não compila.\n\npublic int retornarTroco()\n{    \n    return saldo;\n    saldo = 0;\n}"
  },
  {
    "objectID": "cap2-3.html#section-12",
    "href": "cap2-3.html#section-12",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nO que há de errado com a implementação alternativa abaixo do construtor da classe MaquinaIngressos?\n\npublic MaquinaIngressos(int custoIngresso)\n{    \n    int preco = custoIngresso;\n    saldo = 0;\n    total = 0;\n}\n\nTente usar essa versão. O código compila?\nCrie um objeto e inspecione o valor dos atributos.\nHá algo de errado com o atributo preco?\nConsegue explicar o que aconteceu?"
  },
  {
    "objectID": "cap2-3.html#quiz-2.5",
    "href": "cap2-3.html#quiz-2.5",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.5",
    "text": "Quiz 2.5\n\nO tempo de vida de uma variável local é:\n\nO mesmo do programa.\nO mesmo da classe.\nO mesmo do objeto.\nO mesmo do método ou construtor."
  },
  {
    "objectID": "cap2-3.html#quiz-2.6",
    "href": "cap2-3.html#quiz-2.6",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.6",
    "text": "Quiz 2.6\n\nEscolha a melhor opção para completar a frase: Uma variável local é acessível ________:\n\nem qualquer classe do programa.\nna classe onde é declarada.\nno método ou construtor onde é declarada.\nno bloco de código onde é declarada."
  },
  {
    "objectID": "cap2-3.html#section-13",
    "href": "cap2-3.html#section-13",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "É importante entender as semelhanças e diferenças entre atributos, parâmetros e variáveis locais.\n\nOs três servem para armazenar valores de acordo com seu tipo.\n\n\nMas possuem diferenças importantes:\n\n\n\n\n\n\n\n\n\n\n\n\nAtributos\nParâmetros\nVariáveis locais\n\n\n\n\nDeclaração\nfora dos métodos e construtores\nna assinatura de métodos/construtores\nno corpo dos métodos/construtores\n\n\nTempo de vida\ndo objeto\ndo método/construtor\ndo método/construtor\n\n\nEscopo\nacessível em qualquer lugar da classe\nacessível no método/construtor\nacessível no bloco onde é declarado\n\n\nValor padrão\nSim\nNão (valor é passado de fora do objeto)\nNão (precisa ser inicializada antes de usada)"
  },
  {
    "objectID": "cap2-3.html#section-14",
    "href": "cap2-3.html#section-14",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Dica\n\n\nSe estiver em dúvida se uma variável deve ser declarada como atributo ou variável local:\n\nDê preferência sempre a declará-la como variável local.\nSó declare como atributo se tiver certeza que:\n\nÉ uma informação que precisa ser mantida mesmo depois da chamada do método.\nÉ uma característica do objeto (algo que o descreve/representa)."
  },
  {
    "objectID": "cap2-3.html#section-15",
    "href": "cap2-3.html#section-15",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nAdicione um novo método esvaziar à classe MaquinaIngressos. Você já tinha feito isso na aula passada no projeto anterior, mas, agora, além zerar o valor do atributo total, o método deve retornar o valor do total antes dele ser zerado.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAltere o método imprimirIngresso criando uma variável local chamada valorQueFalta. A variável deve receber a diferença entre o preço e o saldo, ou seja, o valor que falta para completar o preço de um ingresso. Altere o comando condicional para que o teste seja feito verificando o valor da variável valorQueFalta, e utilize a variável também na mensagem dada quando não há dinheiro suficiente para comprar um ingresso.\nTeste as alterações criando situações que caiam tanto no bloco if quanto no bloco else, para garantir que tudo está funcionando como deveria."
  },
  {
    "objectID": "cap2-3.html#section-16",
    "href": "cap2-3.html#section-16",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nTire um print da implementação do método imprimirIngresso pedida no exercício anterior para enviar no Campus Virtual.\nImportante: para tirar o print, inclua, na primeira linha do método, um comentário com o seu nome completo."
  },
  {
    "objectID": "cap2-3.html#section-17",
    "href": "cap2-3.html#section-17",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "(Opcional) Exercício - Desafio\n\n\nSalve o projeto da máquina de ingressos com um novo nome (ex.: maquina-ingressos-varios-precos).\nAltere a classe MaquinaIngressos do novo projeto de forma que ela possa emitir ingressos de preços diferentes. Imagine que a máquina real tenha um botão que permite ao usuário escolher uma opção de ingresso com desconto, antes de solicitar a impressão do ingresso.\nQuais atributos e métodos precisariam ser adicionados à classe para tratar isso?\nVocê acha que seria necessário alterar muitos dos métodos que já existiam?"
  },
  {
    "objectID": "cap2-3.html#section-20",
    "href": "cap2-3.html#section-20",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O método obterLogin da classe Estudante tem algo diferente que é interessante analisarmos.\n\n  public String obterLogin()\n  {\n    return nome.substring(0,4) + matricula.substring(0,3);\n  }\n\nRepare em dois pontos interessantes:\n\nMétodos de outros objetos são chamados, e eles retornam um resultado.\nO resultado retornado é usado como parte de uma expressão."
  },
  {
    "objectID": "cap2-3.html#section-21",
    "href": "cap2-3.html#section-21",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Os atributos nome e matricula são objetos String.\n\nE a classe String possui um método chamado substring.\n\n\nO método substring tem o seguinte comentário e assinatura.\n\n/*\n* Returns a string that is a substring of this string. \n* The substring begins at the specified beginIndex \n* and extends to the character at index endIndex - 1. \n* Thus the length of the substring is endIndex-beginIndex.\n*/\npublic String substring(int beginIndex, int endIndex)\n\n\n\nPelo comentário vemos que o método retorna uma string que é parte da string original.\n\nA string retornada inclui os caracteres que estão da posição beginIndex (primeiro parâmetro) até a posição anterior a endIndex (segundo parâmetro).\n\n\n\nSabendo disso, vamos entender como o método obterLogin funciona."
  },
  {
    "objectID": "cap2-3.html#section-22",
    "href": "cap2-3.html#section-22",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "A primeira parte da expressão implementada é nome.substring(0,4).\n\nPelo que vimos do método substring, isso significa que são retornados os quatro primeiros caracteres do nome do estudante (da posição 0 até a posição 3).\n\n\nJá a segunda parte da expressão é matricula.substring(0,3). O que ela retorna?\n\nOs três primeiros caracteres da matrícula.\n\n\n\nPortanto, para um aluno de nome “Sebastião da Silva” e matrícula 435221, qual seria o valor retornado pelo método obterLogin?\n\nPense primeiro na resposta e depois valide criando um objeto no BlueJ.\nVeja que o retorno seria “Seba435”."
  },
  {
    "objectID": "cap2-3.html#section-23",
    "href": "cap2-3.html#section-23",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nQual seria o login retornado para uma estudante chamada “Maria Pereira”, com matrícula 332211?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nCrie um Estudante com o nome \"Teo\" e matrícula \"748392\". O que acontece quando o método obterLogin é chamado para este estudante? Por que você acha que isso acontece?"
  },
  {
    "objectID": "cap2-3.html#section-24",
    "href": "cap2-3.html#section-24",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nA classe String possui um método de acesso chamado length, com o seguinte cabeçalho:\n\n/**\n * Return the number of characters in this string.\n */\npublic int length()\n\nAdicione um comando condicional ao construtor da classe Estudante e imprima um erro na tela caso o parâmetro nomeCompleto tenha menos que quatro caracteres, ou o parâmetro matriculaEstudante tenha menos de três caracteres.\nObs.: mesmo que a mensagem seja exibida, o objeto deve ser criado normalmente com os valores passados."
  },
  {
    "objectID": "cap2-3.html#section-25",
    "href": "cap2-3.html#section-25",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nTire um print da implementação do construtor da classe Estudante pedida no exercício anterior para enviar no Campus Virtual.\nImportante: para tirar o print, inclua, na primeira linha do construtor, um comentário com o seu nome completo."
  },
  {
    "objectID": "cap2-3.html#section-26",
    "href": "cap2-3.html#section-26",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "(Opcional) Exercício - Desafio\n\n\nAltere o método obterLogin da classe Estudante de forma que ele sempre retorne um login, mesmo que os atributos nome e matricula não tenham os tamanhos mínimos esperados. Caso algum atributo tenha tamanho insuficiente, use todos os caracteres do atributo."
  },
  {
    "objectID": "cap2-3.html#section-27",
    "href": "cap2-3.html#section-27",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Como você já sabe das aulas anteriores, para que você tenha a presença\n\nconsiderada nas aula em formato ANP (Atividade Não-Presencial),\nvocê precisa demonstrar que realmente estudou o conteúdo.\n\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nPara ter presença nessa aula você deve:\n\nResponder, no Campus Virtual, aos quizes presentes nesses slides.\nEnviar os prints solicitados referentes aos exercícios da aula."
  },
  {
    "objectID": "cap2-1.html#como-estudar-esse-conteúdo",
    "href": "cap2-1.html#como-estudar-esse-conteúdo",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Como estudar esse conteúdo?",
    "text": "Como estudar esse conteúdo?\nRelembrando as dicas:\n\n\n\nÉ essencial praticar enquanto estuda, usando o BlueJ.\nAjuda muito se você ler o capítulo do livro da disciplina para tirar dúvidas e complementar o que está sendo estudado.\nUse um caderno e caneta para anotar os principais conceitos e eventuais dúvidas que surgirem."
  },
  {
    "objectID": "cap2-1.html#observações-sobre-o-livro",
    "href": "cap2-1.html#observações-sobre-o-livro",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Observações sobre o livro",
    "text": "Observações sobre o livro\nGostaria de ressaltar algumas observações sobre o livro:\n\n\n\n\n\n\n\n\n\nPara construir os slides usei também a 6ª edição do livro (que só tem em inglês).\n\nPortanto, os slides podem ter coisas a mais ou ligeiramente diferentes que o livro.\n\nApesar do livro ser em português, todo o código nele é em inglês.\n\nNos slides vocês podem notar que traduzi todos os códigos para ficar mais fácil entender.\n\nOs exercícios no slide nem sempre são iguais aos do livro.\n\nPortanto, sigam o enunciado dos slides.\n\nNem sempre uso a mesma tradução do livro\n\nEm alguns casos por simples preferência pessoal (ex: prefiro atributo que campo).\nEm outros casos porque tentei fazer uma tradução melhor."
  },
  {
    "objectID": "cap2-1.html#principais-conceitos-do-capítulo",
    "href": "cap2-1.html#principais-conceitos-do-capítulo",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Principais Conceitos do Capítulo",
    "text": "Principais Conceitos do Capítulo\n\n\nAtributos\nConstrutores\nParâmetros\nMétodos (de acesso e modificadores)\n\n\n\nConstruções Java do capítulo\n\n\nAtributo, construtor, comentário, parâmetro, atribuição (=), bloco, comando de retorno, void, operadores de atribuição compostos (+=, -=), comando if.\n\n\n\n\nNeste capítulo vamos começar a examinar em mais detalhes o código-fonte de uma classe.\n\nVamos discutir os elementos básicos de uma classe: atributos, construtores e métodos."
  },
  {
    "objectID": "cap2-1.html#section",
    "href": "cap2-1.html#section",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Para ilustrar os conceitos desse capítulo, vamos usar um novo projeto: uma máquina de ingressos ingênua\n\n\n\n\n\n\nUma máquina de ingressos permite que o cliente coloque quantias de dinheiro e imprima seu ingresso.\nVamos começar com uma simulação bem básica que nos permitirá avaliar os conceitos do capítulo.\n\nNa próxima aula vamos melhorar nossa máquina.\n\n\n\n\n\nO funcionamento básico da máquina é o seguinte:\n\nO cliente coloca dinheiro na máquina (pode fazer isso várias vezes).\nA todo momento a máquina guarda quanto dinheiro o cliente já inseriu e o total inserido por todos os clientes.\nO cliente pode então solicitar a impressão do ingresso.\nNossa máquina inicial trata apenas um tipo de ingresso.\nMas, criando várias instâncias (objetos) da máquina, podemos ter máquinas com ingressos diferentes."
  },
  {
    "objectID": "cap2-1.html#section-1",
    "href": "cap2-1.html#section-1",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Abra então o projeto maquina-ingressos-ingenua e vamos explorá-lo como fizemos para outros exemplos.\n\nO projeto tem uma única classe MaquinaIngressos.\nAo criar um objeto da classe, você precisa informar o preço do ingresso.\n\nO preço do ingresso é dado em centavos.\nEx.: se o ingresso custa R$ 12,00, o valor informado deve ser 1200.\n\n\n\n\n\n\n\nConceito\n\n\nCriação de objetos: alguns objetos não podem ser criados se você não fornecer informação adicional para ele."
  },
  {
    "objectID": "cap2-1.html#section-2",
    "href": "cap2-1.html#section-2",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nCrie um objeto MaquinaIngressos e verifique os métodos disponíveis. Chame o método obterPreco e confira o preço do ingresso. Em seguida, insira uma quantia de dinheiro menor que o preço do ingresso usando o método inserirDinheiro e confira o saldo usando o método obterSaldo. Insira mais dinheiro até ter a quantidade exata necessária para comprar o ingresso, e então chame o método imprimirIngresso.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nQual é o saldo da máquina depois que você compra um ingresso?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente inserir quantidades diferentes de dinheiro antes de imprimir um ingresso. Você percebeu alguma coisa estranha? Quando você insere muito dinheiro, você recebe o troco? O que acontece se você não colocar dinheiro suficiente e tentar imprimir um ingresso?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nTente entender bem o funcionamento da máquina interagindo com o objeto no BlueJ antes de ver o código na próxima seção. Crie outra máquina que tenha ingressos de preço diferente e compre um ingresso dessa máquina. A impressão do bilhete é diferente?"
  },
  {
    "objectID": "cap2-1.html#section-3",
    "href": "cap2-1.html#section-3",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nos exercícios vimos que a máquina só funciona como deveria se inserirmos a quantidade exata de dinheiro para comprar um ingresso.\n\nVamos examinar os detalhes da classe e entender porque isso está acontecendo.\n\n\nDê uma olhada no código da classe MaquinaIngressos, clicando duas vezes na classe no diagrama do BlueJ.\n\nAvaliando o código podemos identificar alguns dos conceitos de OO que vimos no capítulo 1.\nA classe tem muitas funcionalidades do Java que veremos várias vezes, portanto, avalie o código cuidadosamente."
  },
  {
    "objectID": "cap2-1.html#section-4",
    "href": "cap2-1.html#section-4",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Podemos dividir o código da classe em duas partes principais.\n\nUma pequena parte externa que dá nome à classe (aparece com fundo verde no BlueJ).\nE uma parte interna muito maior que faz todo o trabalho.\n\n\nA parte externa tem o seguindo trecho de código\n\npublic class MaquinaIngressos\n{\n  // Parte interna da classe omitida\n}\n\n\n\nA parte externa de todas as classe se parecem muito, já que o objetivo é nomear a classe.\n\nPor convenção, sempre começamos o nome da classe com letra maiúscula.\nNo BlueJ, vemos que antes dessa linha há um texto azul que nos diz alguma coisa sobre a classe."
  },
  {
    "objectID": "cap2-1.html#section-5",
    "href": "cap2-1.html#section-5",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nEscreva como você acha que seria a parte externa das classes Estudante e Disciplina. Não se preocupe com a parte interna.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nFaz diferença escrever public class MaquinaIngressos ou class public MaquinaIngressos?\nFaça essa alteração no código, feche o editor e observe a mudança no diagrama. Clique no botão Compilar. Que mensagem de erro aparece? Ela explica claramente o que tem de errado?\nVolte o código para como estava antes e compile novamente (confira se não aparece mais a mensagem de erro).\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nVerifique se é possível remover a palavra public da parte externa da classe MaquinaIngressos (compile o código).\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nColoque a palavra public de volta e agora tente remover a palavra class e tente compilar de novo.\nVolte o código original para continuar a aula."
  },
  {
    "objectID": "cap2-1.html#palavras-chave",
    "href": "cap2-1.html#palavras-chave",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Palavras-chave",
    "text": "Palavras-chave\nAs palavras public e class são parte da linguagem Java.\n\nMas MaquinaIngressos não é.\n\nQuem criou a classe é que escolheu esse nome.\n\n\n\nNós chamamos as palavras public e class de palavras-chave ou palavras reservadas.\n\nHá cerca de 50 palavras desse tipo em Java.\nEm breve conheceremos diversas delas."
  },
  {
    "objectID": "cap2-1.html#atributos-construtores-e-métodos",
    "href": "cap2-1.html#atributos-construtores-e-métodos",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Atributos, construtores e métodos",
    "text": "Atributos, construtores e métodos\nA parte interna da classe é onde nós definimos os atributos, construtores e métodos que fazem os objetos terem suas características e comportamentos.\n\nEm resumo:\n\nAtributos guardam dados dentro de um objeto.\nConstrutores são responsáveis por garantir que um objeto seja configurado corretamente quando ele é criado.\nMétodos implementam o comportamento de um objeto. Fornecem o que ele é capaz de fazer.\n\n\n\n\n\nNo BlueJ os atributos aparecem em um fundo branco.\n\nJá os constrututores e métodos são mostrados em caixas amarelas."
  },
  {
    "objectID": "cap2-1.html#section-6",
    "href": "cap2-1.html#section-6",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "A linguagem Java permite que os atributos, construtores e métodos sejam colocados em qualquer ordem dentro de uma classe.\n\nMas, geralmente, nós colocamos primeiro os atributos, depois os construtores e depois os métodos.\n\npublic class NomeDaClasse\n{\n  // Atributos\n\n  // Construtores\n\n  // Métodos\n}\n\n\n\nVocê não é obrigado a seguir isso, mas deixa seu código mais claro.\n\nEspecialmente declarar todos os atributos primeiro."
  },
  {
    "objectID": "cap2-1.html#section-7",
    "href": "cap2-1.html#section-7",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nSabendo a ordem que os atributos, métodos e construtores são geralmente implementados em uma classe, avalie o código da classe MaquinaIngressos e faça uma tabela com três colunas. Na primeira coloque os nomes dos atributos, na segunda os nomes dos construtores e, na terceira, os métodos. Dica: a classe tem apenas um construtor.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nA assinatura do construtor tem duas características que são diferentes dos métodos. Você consegue descobrir quais são?"
  },
  {
    "objectID": "cap2-1.html#section-8",
    "href": "cap2-1.html#section-8",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Atributos guardam dados dentro de um objeto.\n\nAtributos também são chamados de variáveis de instância.\n\nO nome variável é usado para coisas que são armazenadas na memória do computador por um programa.\n\n\n\n\n\npublic class MaquinaIngressos\n{\n  private int preco;\n  private int saldo;\n  private int total;\n\n    // Construtores e métodos omitidos\n}\n\nA classe MaquinaIngressos, por exemplo, tem três atributos:\n\npreco: guarda o valor fixo de cada ingresso.\nsaldo: guarda a quantidade de dinheiro inserida na máquina por um usuário antes dele pedir para imprimir um ingresso.\ntotal: guarda o total de dinheiro inserido na máquina por todos os usuários, desde que ela foi construída (sem contar o saldo atual)."
  },
  {
    "objectID": "cap2-1.html#section-9",
    "href": "cap2-1.html#section-9",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Atributos (ou campos) descrevem características dos objetos.\n\n\n\n\nComo você descreveria essa bola, por exemplo?\n\nDizendo de outra forma, como contaria como ela é para alguém que não está vendo a bola?\nVocê poderia descrevê-la, informando:\n\nA cor, o tamanho, o tipo, etc.\n\n\n\n\n\n\n\n\n\nE quais seriam as características de um jogador em um jogo de videogame de futebol?\n\nPoderiam ser: nome, nacionalidade, altura, velocidade, agilidade, etc.\n\n\n\n\n\n\nNós chamamos essas características dos objetos de atributos."
  },
  {
    "objectID": "cap2-1.html#section-10",
    "href": "cap2-1.html#section-10",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Atributos podem representar coisas mais palpáveis ou coisas mais abstratas.\n\n\n\n\nDada a imagem acima, por exemplo, quais seriam os atributos físicos de cada pessoa?\n\nCor dos olhos.\nEstilo de roupa.\nAltura.\nEtc.\n\n\n\nE quais seriam características mais abstratas?\n\nInteligência.\nHumor.\nBeleza.\nEtc."
  },
  {
    "objectID": "cap2-1.html#section-11",
    "href": "cap2-1.html#section-11",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Atributos são pequenos espaços dentro de um objeto que podem ser usados para guardar dados de forma permanente.\n\nCada objeto terá espaço para cada atributo declarado na classe.\n\n\n\n\nPodemos representar um objeto como mostrado na figura ao lado.\n\nCada atributo tem um espaço para guardar um valor quando o objeto for criado.\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nAtributos guardam dados para um objeto usar. Eles também são chamados de variáveis de instância."
  },
  {
    "objectID": "cap2-1.html#section-12",
    "href": "cap2-1.html#section-12",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Cada atributo tem sua própria declaração no código-fonte.\n\nE na linha acima de cada declaração acrescentamos uma linha de texto: o comentário.\n\n\n  // O preço de um ingresso desta máquina\n  private int preco;\n\n\nAssim como em C++, comentários de uma única linha começam com //.\n\nComentários de várias linhas podem começar com /* e terminar com */.\n\nVeja, como exemplo, os comentários antes do cabeçalho da classe MaquinaIngressos.\n\n\n\n\n\n\n\n\nConceito\n\n\nComentários são inseridos em uma classe para explicar o código para leitores humanos. Eles não alteram nada no funcionamento da classe."
  },
  {
    "objectID": "cap2-1.html#section-13",
    "href": "cap2-1.html#section-13",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "As declarações dos atributos da classe MaquinaIngressos são todas bem similares.\n\nTodas elas indicam que os campos são privados do objeto.\n\nVamos entender melhor o que isso significa ao estudarmos o Capítulo 6.\nPor enquanto, basta sabermos que os atributos devem sempre ser definidos como privados.\n\nOs três atributos são do tipo int.\n\nint é uma palavra-chave do Java e indica que os atributos podem guardar valores que são números inteiros.\nComo nossa máquina guarda os valores em centavos, o tipo inteiro é apropriado."
  },
  {
    "objectID": "cap2-1.html#section-14",
    "href": "cap2-1.html#section-14",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Atributos podem armazenar valores que mudam com o tempo.\n\nPor isso, eles também são chamados de variáveis.\nO atributo saldo, por exemplo, é alterado sempre que o usuário insere dinheiro ou imprime um ingresso.\nPodemos ter atributos que mudam muito, como saldo e total,\n\ne atributos que não variam depois de inicializados, como o preco.\n\nMais adiante veremos que existem outros tipos de váriaveis, com a mesma ideia de que são dados armazenados no computador."
  },
  {
    "objectID": "cap2-1.html#section-15",
    "href": "cap2-1.html#section-15",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nQual é o tipo de cada um dos atributos abaixo?\n  private int contador;\n  private Estudante monitor;\n  private Computador notebook;\n\n\n\n\n\n\n\n\n\nExercício\n\n\nQual é o nome de cada um dos atributos abaixo?\n  private boolean vivo;\n  private Pessoa professor;\n  private Jogo jogo;\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nRepare os tipos dos atributos nos dois exercícios anteriores. Pelo que você sabe das convenções de nomes de classes, quais tipos você acha que são classes?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nSerá que a ordem das palavras na declaração de um atributo fazem diferença? A classe MaquinaIngressos tem a seguinte declaração: private int preco;. Experimente mudar a ordem, fechar o editor e ver como a classe fica no diagrama. Tente compilar a classe e avalie a mensagem de erro que aparece. Obs.: não se esqueça de voltar a declaração original."
  },
  {
    "objectID": "cap2-1.html#section-16",
    "href": "cap2-1.html#section-16",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nÉ muito interessante quando aprendemos as coisas pela experimentação, em vez de decorar uma regra. Será que, em Java, as declarações dos atributos precisam sempre terminar com ponto-e-vírgula? Experimente você mesmo e descubra!\n\n\n\n\n\n\n\n\n\nExercício\n\n\nEscreva a declaração completa de um atributo do tipo int chamado situacao."
  },
  {
    "objectID": "cap2-1.html#quiz-2.1",
    "href": "cap2-1.html#quiz-2.1",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.1",
    "text": "Quiz 2.1\n\nAtributo também é chamado de:\n\nVariável de instância.\nVariável de classe.\nVariável local.\nVariável binária."
  },
  {
    "objectID": "cap2-1.html#section-17",
    "href": "cap2-1.html#section-17",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Construtores têm um papel especial.\n\nSão responsáveis por garantir que um objeto seja configurado adequadamente quando é criado.\nOu seja, garantir que esteja pronto para ser usado logo após a criação.\nNós também costumamos chamar isso de inicialização.\n\n\nDepois que o objeto é criado, o construtor não tem mais utilidade para aquele objeto específico.\n\nPortanto, não podemos chamar o construtor para um objeto já criado.\n\n\n\n\n\nAbaixo está o código do construtor da classe MaquinaIngressos.\n  /**\n   * Cria uma máquina que emite ingressos de um dado preço.\n   * Note que o preço deve ser maior que zero, e não tem\n   * nenhuma verificação para garantir isso.\n   */\n  public MaquinaIngressos(int custoIngresso)\n  {\n      preco = custoIngresso;\n      saldo = 0;\n      total = 0;\n  }"
  },
  {
    "objectID": "cap2-1.html#section-18",
    "href": "cap2-1.html#section-18",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Em Java, construtores têm o mesmo nome da classe.\n\nVeja que o construtor da classe MaquinaIngressos se chama: MaquinaIngressos.\nGeralmente usamos a palavra-chave public antes do nome do construtor.\nE construtores não têm tipo de retorno.\n\n\nExiste uma relação direta entre o que acontece no corpo de um construtor e os atributos da classe.\n\nIsso porque a principal responsabilidade do construtor é inicializar os atributos.\nObs.: corpo de um construtor ou de um método é o bloco de código que contém sua implementação. Ou seja, é tudo que tem entre { e } logo após a assinatura.\nAtributos podem ser inicializados com constantes.\n\nComo é o caso do saldo e total que são inicializados com zero.\n\nOu podem ser inicializados por valores determinados externamente à classe.\n\nE que são passados para o construtor por parâmetro.\nComo é o caso do atributo preco."
  },
  {
    "objectID": "cap2-1.html#section-19",
    "href": "cap2-1.html#section-19",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "A questão é que podem ser criadas várias máquinas (instâncias) a partir da classe MaquinaIngressos.\n\nE cada máquina pode trabalhar com ingressos de preços diferentes.\nPortanto, não temos como saber o preço do ingresso de uma máquina específica, até que ela seja criada.\n\n\n\n\nPortanto, uma das principais funções de um atributo é “lembrar” de informações externas passadas para o objeto.\n\nDe forma que a informação continue disponível durante todo o tempo de vida do objeto.\nAssim, atributos servem para guardar informações que duram (são mantidas) por um tempo maior.\n\n\n\n\n\n\n\nConceito\n\n\nConstrutores permitem que cada objeto seja configurado adequadamente quando é criado."
  },
  {
    "objectID": "cap2-1.html#section-20",
    "href": "cap2-1.html#section-20",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "No diagrama ao lado, vemos a representação de um objeto máquina de ingressos, depois que o construtor é chamado.\n\nPodemos ver que ela foi criada com um preço de ingresso de 500 (R$ 5,00)."
  },
  {
    "objectID": "cap2-1.html#section-21",
    "href": "cap2-1.html#section-21",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Em Java, se um atributo não for inicializado explicitamente no código, ele é inicializado automaticamente com um valor padrão.\n\nAtributos inteiros, por exemplo, são inicializados automaticamente com zero.\n\n\n\n\n\n\n\nHá duas vantagens:\n\nQuem lê a classe entende que realmente queremos inicializar com zero.\n\n\nSe não tivéssemos colocado, a pessoa poderia ficar em dúvida se esquecemos de inicializar ou se queríamos deixar o valor padrão zero.\n\n\nQuem lê a classe não precisa conhecer o valor padrão do Java para os atributos."
  },
  {
    "objectID": "cap2-1.html#quiz-2.2",
    "href": "cap2-1.html#quiz-2.2",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.2",
    "text": "Quiz 2.2\n\nMarque a alternativa incorreta:\n\nUm construtor é chamado quando um objeto é criado.\nConstrutores podem receber informações externas ao objeto.\nConstrutores servem para definir valores válidos para os atributos do objeto.\nPodemos chamar um construtor para um objeto depois que ele foi criado."
  },
  {
    "objectID": "cap2-1.html#section-22",
    "href": "cap2-1.html#section-22",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Construtores e métodos têm funções diferentes, mas ambos podem receber valores de fora do objeto da mesma maneira:\n\nAtravés dos parâmetros.\n\n\nNós vimos um pouco sobre parâmetros no capítulo anterior.\n\nParâmetros são variáveis definidas na assinatura de um método ou construtor.\n\n\n\n\n  public MaquinaIngressos(int custoIngresso)\n\n\nEste construtor tem um único parâmetro custoIngresso de tipo int.\n\nO mesmo tipo do campo preco que guardará o valor do parâmetro.\n\n\n\n\nRepare que diferentemente de um atributo, um parâmetro é usado para guardar uma informação temporária.\n\nBasicamente para carregar dados de fora do objeto para dentro do seu construtor ou método."
  },
  {
    "objectID": "cap2-1.html#section-23",
    "href": "cap2-1.html#section-23",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "No BlueJ, um usuário envia informação externa para o objeto através da caixa de diálogo, que aparece quando um objeto máquina de ingressos é criado.\n\nO valor é copiado para o parâmetro custoIngresso do construtor da nova máquina (A).\n\nA caixa “MaquinaIngressos (construtor)” ilustra o espaço adicional que é criado para o objeto somente quando o construtor é chamado.\nEle é chamado de espaço do construtor, e é usado para armazenar seus parâmetros."
  },
  {
    "objectID": "cap2-1.html#section-24",
    "href": "cap2-1.html#section-24",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Tecnicamente, nós chamamos de parâmetro formal o nome do parâmetro declarado na assinatura do construtor ou método.\n\nApesar de, na prática, chamarmos simplesmente de parâmetro.\nJá o valor passado de fora do objeto é chamado, tecnicamente, de argumento ou parâmetro real.\nPortanto, no exemplo anterior, custoIngresso é o parâmetro formal e o valor 500 é o argumento.\n\n\n\n\n\n\nUm parâmetro formal está disponível para o objeto somente dentro do corpo do construtor ou método que onde ele é declarado.\n\nDizemos que este é o escopo do parâmetro.\nVeja que o escopo de um atributo é diferente, pois ele pode ser acessado em qualquer lugar dentro da classe."
  },
  {
    "objectID": "cap2-1.html#section-25",
    "href": "cap2-1.html#section-25",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Tempo de vida de uma variável é um conceito relacionado à escopo.\n\nUm parâmetro só existe durante uma única chamada do construtor ou do método.\nQuando o construtor é chamado, o espaço do construtor é criado e, depois que ele termina, esse espaço desaparece.\nPortanto, o tempo de vida de um parâmetro é limitado a uma única chamada do construtor.\n\n\n\nRepare que é diferente do tempo de vida de um atributo.\n\nO tempo de vida de um atributo é o mesmo do objeto.\nOu seja, ele existe a partir do momento que o objeto é criado e até ele ser destruído.\n\n\n\n\n\n\n\nConceito\n\n\nO escopo de uma variável define o trecho de código a partir do qual a variável pode ser acessada.\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nO tempo de vida de uma variável indica quanto tempo ela vai existir até ser destruída."
  },
  {
    "objectID": "cap2-1.html#section-26",
    "href": "cap2-1.html#section-26",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nA qual classe pertence o construtor abaixo?\npublic Estudante(String nome)\n\n\n\n\n\n\n\n\nExercício\n\n\nQuantos parâmetros tem o construtor abaixo e quais são seus tipos?\npublic Livro(String titulo, double preco)\n\n\n\n\n\n\n\n\nExercício\n\n\nApenas pela assinatura do construtor do exercício anterior, você conseguiria chutar alguma coisa sobre os nomes e tipos dos atributos da classe Livro?"
  },
  {
    "objectID": "cap2-1.html#section-27",
    "href": "cap2-1.html#section-27",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Repare que os nomes que escolhemos para os atributos e parâmetros indicam para que eles servem.\n\nApenas lendo os nomes preco, custo, titulo e vivo, já podemos ter uma noção de sua utilidade.\nPortanto, apesar da linguagem Java permitir que você dê qualquer nome, evite nomes sem sentido como a, b ou x1, x2."
  },
  {
    "objectID": "cap2-1.html#section-28",
    "href": "cap2-1.html#section-28",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Como vocês já aprenderam em disciplinas anteriores de programação, nós usamos o operador = para atribuir valores a variáveis.\n\nAssim, o comando:\npreco = custoIngresso;\nIndica que o valor do parâmetro custoIngresso será copiado para o atributo preco.\nDica:\n\nGeralmente a gente lê o comando acima assim: “preço igual a custo do ingresso”\nMas eu acho que fica mais fácil entender se usarmos a palavra recebe.\nRepare a diferença: “preço recebe custo do ingresso”\n\n\n\n\n\n\n\nNo diagrama, a atribuição é representada pela seta indica pela letra (B)."
  },
  {
    "objectID": "cap2-1.html#section-29",
    "href": "cap2-1.html#section-29",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O lado direito (o que vem depois do =) é chamado expressão.\n\nUma expressão pode ser um único valor (como custoIngresso).\nOu algo mais complexo, como o resultado de um cálculo.\n\n\nEm Java, o tipo do resultado da expressão tem que ser o mesmo tipo da variável.\n\nEx.: não podemos guardar um resultado inteiro em uma variável string.\n\n\n\n\n\n\n\nConceito\n\n\nComandos de atribuição guardam os valores representados pelo lado direito do comando na variável nomeada do lado esquerdo."
  },
  {
    "objectID": "cap2-1.html#section-30",
    "href": "cap2-1.html#section-30",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nSuponha que uma classe Cachorro tem um atributo nome. Escreva o comando de atribuição que inicializa o atributo nome, sabendo que a assinatura do construtor da classe é public Cachorro(String nomeCachorro).\n\n\n\n\n\n\n\n\n\nExercício\n\n\nA linha de código abaixo cria um objeto, chamando o construtor da classe Date.\n  new Date(\"Setembro\", 1, 2023)\nVocê conseguiria escrever a assinatura do construtor da classe Date? Obs.: escolha nomes representativos para os parâmetros."
  },
  {
    "objectID": "cap2-1.html#quiz-2.3",
    "href": "cap2-1.html#quiz-2.3",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.3",
    "text": "Quiz 2.3\n\nComplete a frase: _______ têm tempo de vida igual ao do objeto:\n\nParâmetros.\nAtributos.\nMétodos.\nClasses."
  },
  {
    "objectID": "cap2-1.html#section-31",
    "href": "cap2-1.html#section-31",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Analisando o código-fonte da classe MaquinaIngressos podemos ver que ela tem quatro métodos.\n\nOs métodos são mostrados em caixas amarelas no BlueJ.\n\n\nVeja, por exemplo, a implementação do método obterPreco.\n\nVemos que os métodos têm duas partes: a assinatura e o corpo do método.\nVemos também que antes da assinatura há um comentáro que descreve o método.\n\npublic class MaquinaIngressos\n{\n  // atributos ommitidos\n  // construtor omitido\n  /**\n   * Retorna o preço do ingresso.\n   */\n  public int obterPreco()\n  {\n    return preco;\n  }  \n  // métodos restantes omitidos\n\n\n\n\n\n\nConceito\n\n\nMétodos são formados por duas partes: assinatura e corpo."
  },
  {
    "objectID": "cap2-1.html#section-32",
    "href": "cap2-1.html#section-32",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Repare que a assinatura do método se parece um pouco com a declaração de atributo.\n\nComo então sabemos que é um método e não um atributo?\n\nRepare que a assinatura public int obterPreco() possui parênteses e não termina com ponto-e-vírgula.\n\n\n\nO corpo do método, que é o que fica entre chaves { }, pode conter declarações e comandos.\n\nEles definem o que o objeto faz quando o método é chamado.\nDeclarações servem para criar variáveis temporárias adicionais.\nE os comandos são as ações feitas pelo método.\n\n\n\nNós chamamos de bloco de código o conjunto de declarações e comandos que ficam entre um par de chaves.\n\nVemos então que o corpo da classe MaquinaIngressos define um bloco de código.\nO corpo do construtor e de cada método também definem blocos de código."
  },
  {
    "objectID": "cap2-1.html#section-33",
    "href": "cap2-1.html#section-33",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Tanto construtores quanto métodos podem ter quaisquer quantidades de parâmetros (inclusive nenhum).\n\nMas como podemos diferenciar um contrutor de um método?\n\nNote que construtores não têm tipo de retorno enquanto métodos têm\n\nObs.: o tipo de retorno aparece antes do nome do método.\n\npublic MaquinaIngressos(int custoIngresso)\npublic int obterPreco()\nAlém disso, construtores possuem o mesmo nome da classe."
  },
  {
    "objectID": "cap2-1.html#section-34",
    "href": "cap2-1.html#section-34",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O corpo do método obterPreco tem apenas um comando.\n\n  return preco;\n\n\nEsse comando é chamado comando de retorno.\nEle deve retornar um valor que seja do mesmo tipo do método.\nE deve ser sempre o último comando do método\n\npois depois dele nenhum outro comando é executado no método.\n\n\n\nPodemos pensar em uma chamada de método como uma pergunta feita ao objeto.\n\nQuando o método obterPreco é chamado é como se fosse feita para o objeto a pergunta Quanto custa o ingresso?.\nNesse caso específico, o objeto não precisa fazer nenhuma conta, já que ele tem o valor do ingresso guardado no atributo preco.\n\nMas veremos que métodos podem precisar de códigos mais complexos para retornar uma informação."
  },
  {
    "objectID": "cap2-1.html#section-35",
    "href": "cap2-1.html#section-35",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nós chamamos de métodos de acesso os métodos que começam com obter (como obterPreco e obterSaldo).\n\nPorque eles retornam uma informação do estado do objeto para quem chamou o método.\nOu seja, eles fornecem acesso ao estado do objeto.\n\n\nMétodos de acesso têm um comando de retorno.\n\nPorque eles retornam, ou repassam, uma informação do objeto para quem chamou o método."
  },
  {
    "objectID": "cap2-1.html#section-36",
    "href": "cap2-1.html#section-36",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Convenção\n\n\nEm inglês, usamos a palavra get em vez de obter.\n\nAssim, geralmente todos o métodos de acesso começam com a palavra get.\n\nEx.: getPrice, getBalance, etc.\n\nIsso é tão comum que até em códigos em português costumamos usar a palavra get.\n\nEx.: getPreco, getSaldo, etc.\n\nObs.: nesse material vou preferir usar sempre obter, mas fique à vontade para escolher o que prefere.\n\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nMétodos de acesso retornam informações sobre o estado de um objeto."
  },
  {
    "objectID": "cap2-1.html#section-37",
    "href": "cap2-1.html#section-37",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nCompare as assinaturas e os corpos dos métodos obterSaldo e obterPreco. O que eles têm de diferente?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nQual seria a pergunta feita ao objeto máquina de ingressos na chamada do método obterSaldo?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nComo você acha que seria a implementação de um método obterTotal?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente excluir o comando de retorno do método obterPreco. Qual mensagem de erro aparece quando você tenta compilar a classe?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAlém da diferença de nome, o que mais há de diferente nas assinaturas dos métodos obterPreco e inserirDinheiro. Você acha que isso pode ter algo a ver com o fato de que o primeiro método tem comando de retorno e o segundo não?"
  },
  {
    "objectID": "cap2-1.html#section-38",
    "href": "cap2-1.html#section-38",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Os métodos obter da classe MaquinaIngressos retornam valores dos atributos da classe.\n\nOs demais métodos (inserirDinheiro e imprimirIngresso) têm um papel muito mais importante.\nPrincipalmente porque eles mudam o valor de um ou mais atributos do objeto toda vez que são chamados.\n\n\nNós chamamos os métodos que mudam o estado de seus objetos de métodos modificadores.\n\nPodemos pensar nesses métodos como pedidos feitos para os objetos alterarem seus estados."
  },
  {
    "objectID": "cap2-1.html#section-39",
    "href": "cap2-1.html#section-39",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "É muito comum que classes tenham métodos modificadores que recebem um novo valor para um de seus atributos.\n\nNós não temos métodos desse tipo na classe MaquinaIngressos.\nMas podemos pensar, por exemplo, que uma classe Pessoa que tenha um atributo nome, poderia ter o método:\n\n\n\n  public void definirNome(String novoNome)\n  {\n    nome = novoNome;\n  }\n\n\n\n\n\n\n\n\n\n\n\nConvenção\n\n\nEm inglês, assim como os métodos de acesso começam com get, os métodos modificadores costumam começar com a palavra set.\n\nPoderíamos ter, por exemplo, o método setName.\nNesse caso é também comum usarmos a palavra set em códigos em português. Ex.: setNome."
  },
  {
    "objectID": "cap2-1.html#section-40",
    "href": "cap2-1.html#section-40",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Conceito\n\n\nMétodos modificadores mudam o estado de um objeto.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nCrie uma máquina de ingressos e chame o método obterSaldo.\n\nEm seguida, chame o método inserirDinheiro passando uma quantidade maior que zero.\nChame novamente o método obterSaldo.\nAs duas chamadas do método obterSaldo retornaram o mesmo valor? Por que?"
  },
  {
    "objectID": "cap2-1.html#section-41",
    "href": "cap2-1.html#section-41",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Vamos analisar agora o código do método inserirDinheiro.\n\n  /**\n   * Recebe uma quantidade de dinheiro de um cliente.\n   */\n  public void inserirDinheiro(int quantidade)\n  {\n      saldo = saldo + quantidade;\n  }\n\n\nRepare que o método tem retorno do tipo void.\n\nIsso significa que o método não retorna nenhum valor.\nNo BlueJ percemos que a diferença é que não aparece a caixa de diálogo quando chamamos métodos desse tipo.\nA diferença no corpo do método é que ele não tem comando de retorno."
  },
  {
    "objectID": "cap2-1.html#section-42",
    "href": "cap2-1.html#section-42",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nAvaliando apenas a assinatura abaixo, você saberia dizer se ela é de um construtor ou de um método?\n  public void setPreco(int custo)\n\n\n\n\n\n\n\n\n\nExercício\n\n\nComplete o código do método anterior de modo que ele atualize o valor de um atributo preco."
  },
  {
    "objectID": "cap2-1.html#quiz-2.4",
    "href": "cap2-1.html#quiz-2.4",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Quiz 2.4",
    "text": "Quiz 2.4\n\nMarque a alternativa incorreta:\n\nMétodos de acesso geralmente retornam o valor de um atributo.\nMétodos modificadores mudam o estado do objeto.\nOs nomes dos métodos de acesso obrigatoriamente começam com a palavra get.\nMétodos com retorno do tipo void não retornam nenhum valor."
  },
  {
    "objectID": "cap2-1.html#section-43",
    "href": "cap2-1.html#section-43",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O método imprimirIngresso é o mais complexo da classe.\n\n  /**\n   * Imprime um ingresso.\n   * Atualiza o total coletado e reduz o saldo para zero.\n   */\n  public void imprimirIngresso()\n  {\n    // Simula a impressão de um ingresso\n    System.out.println(\"##################\");\n    System.out.println(\"# Ingressos & Cia \");\n    System.out.println(\"# Ingresso\");\n    System.out.println(\"# \" + preco + \" centavos.\");\n    System.out.println(\"##################\");\n    System.out.println();\n\n    // Atualiza o total coletado com o saldo\n    total = total + saldo;\n    // Zera o saldo\n    saldo = 0;\n  }\n\n\nVocê deve ter notado que, ao chamar o método, o seguinte texto aparece no terminal.\n##################\n# Ingressos & Cia \n# Ingresso\n# 500 centavos.\n##################"
  },
  {
    "objectID": "cap2-1.html#section-44",
    "href": "cap2-1.html#section-44",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Vamos avaliar o método passo a passo.\n  /**\n   * Imprime um ingresso.\n   * Atualiza o total coletado e reduz o saldo para zero.\n   */\n1  public void imprimirIngresso()\n  {\n    // Simula a impressão de um ingresso\n2    System.out.println(\"##################\");\n    System.out.println(\"# Ingressos & Cia \");\n    System.out.println(\"# Ingresso\");\n    System.out.println(\"# \" + preco + \" centavos.\");\n    System.out.println(\"##################\");\n    System.out.println();\n\n    // Atualiza o total coletado com o saldo\n3    total = total + saldo;\n    // Zera o saldo\n4    saldo = 0;\n  }\n\n1\n\nA assinatura indica que o método tem retorno void e não espera nenhum parâmetro.\n\n2\n\nOs primeiros seis comandos imprimem o que vemos no terminal.\n\n3\n\nO sétimo comando adiciona o saldo atual inserido pelo usuário ao total acumulado.\n\n4\n\nO último comando retorna o saldo para zero, esperando o próximo usuário."
  },
  {
    "objectID": "cap2-1.html#section-45",
    "href": "cap2-1.html#section-45",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "O método imprimirIngresso chama várias vezes o método println do objeto System.out.\n\nO objeto System.out é construído dentro da linguagem Java.\nO que está dentro dos parênteses é o argumento que estamos passando para o método: alguma string.\n\n\nA maioria das chamadas do método println passa uma string literal.\n\nEx.: \"# Ingressos & Cia \".\nIsso significa que o método simplesmente exibe na tela o texto passado entre aspas duplas."
  },
  {
    "objectID": "cap2-1.html#section-46",
    "href": "cap2-1.html#section-46",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Mas veja que a linha abaixo é um pouco diferente.\n\n    System.out.println(\"# \" + preco + \" centavos.\");    \n\n\nEssa linha tem duas coisas diferentes.\n\nO operador + está sendo usado para concatenar (juntar) strings, criando uma nova string.\n\nEx.: \"Tião\" + \" \" + \"Silva\" resulta em \"Tião Silva\".\n\nMas, além disso, o atributo preco está sendo concatenado diretamente na string.\n\nJava converte valores automaticamente para String quando o operador + é usado.\nRepare que se digitássemos \"preco\", seria exibida a palavra preco e não o valor do atributo preco.\n\n\n\n\nOutra linha diferente é a última chamada do método println.\n\nQuando o método é chamado sem nenhum argumento, uma linha em branco é deixada no terminal.\n\n\n    System.out.println();"
  },
  {
    "objectID": "cap2-1.html#section-47",
    "href": "cap2-1.html#section-47",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nO que exatamente será exibido na tela pelo comando abaixo.\n  System.out.println(\"Orgulho de ser UFLA!\")\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAdicione um método imprimirPreco à classe MaquinaIngressos. O método deve ter retorno void, não ter nenhum parâmetro e exibir uma mensagem como a abaixo.\n  O preco do ingresso é X centavos\nOnde no lugar de X deve aparecer o valor do atributo preco.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nCria duas máquinas de ingressos com valores de ingresso diferentes. Ao chamar o método imprimirPreco para as duas máquinas, o texto exibido é igual ou diferente? Por que?"
  },
  {
    "objectID": "cap2-1.html#section-48",
    "href": "cap2-1.html#section-48",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Como você já viu na aula anterior, para que você tenha a presença\n\nconsiderada nas aula em formato ANP (Atividade Não-Presencial),\nvocê precisa demonstrar que realmente estudou o conteúdo.\n\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nPara ter presença nessa aula você deve responder, no Campus Virtual, aos quizes presentes nesses slides.\nVocê deve também enviar o projeto maquina-ingressos-ingenua como ele ficou após terem sido feitas todas as alterações pedidas ao longo da aula."
  },
  {
    "objectID": "cap1-1.html#como-estudar-esse-conteúdo",
    "href": "cap1-1.html#como-estudar-esse-conteúdo",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Como estudar esse conteúdo?",
    "text": "Como estudar esse conteúdo?\nUma dica fundamental é:\n\n\n\nO conteúdo é totalmente atrelado à prática usando o BlueJ.\nNão adianta ler os slides, ou ficar apenas assistindo à videoaula.\nÉ necessário usar o BlueJ e praticar você mesmo!\nSe ainda não instalou o BlueJ em seu computador, a hora é agora!"
  },
  {
    "objectID": "cap1-1.html#como-estudar-esse-conteúdo-1",
    "href": "cap1-1.html#como-estudar-esse-conteúdo-1",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Como estudar esse conteúdo?",
    "text": "Como estudar esse conteúdo?\n\nAlém disso, estes slides se baseiam no Cap. 1 do livro do Barnes e Kölling.\n\n\n\n\n\n\n\n\n\n\n\nEles seguem de forma bem direta o livro, com algumas poucas coisas a mais.\nPortanto, é muito interessante também ler o capítulo no livro para tirar dúvidas e complementar o que está sendo estudado.\n\n\n\n\n\n\n\n\n\n\nDica: faça anotações!\n\n\nEm qualquer dos casos, é altamente recomendável, ter um caderno e caneta para anotar os principais conceitos e eventuais dúvidas que surgirem."
  },
  {
    "objectID": "cap1-1.html#principais-conceitos-do-capítulo",
    "href": "cap1-1.html#principais-conceitos-do-capítulo",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Principais Conceitos do Capítulo",
    "text": "Principais Conceitos do Capítulo\n\nObjetos\nClasses\nMétodos\nParâmetros\n\n\nVamos começar nossa jornada no mundo da Programação Orientada a Objetos (POO)!\n\n\nComeçaremos pelos conceitos mais importantes que são a base de tudo: Objetos e Classes"
  },
  {
    "objectID": "cap1-1.html#section",
    "href": "cap1-1.html#section",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Como você descreveria essa cena para alguém não a está vendo?\n\n\nProvavelmente listando os objetos que nela se encontram.\n\nIsso porque nós entendemos o mundo através dos objetos!"
  },
  {
    "objectID": "cap1-1.html#section-1",
    "href": "cap1-1.html#section-1",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "E o que essas imagens têm em comum?\n\n\nElas são objetos!"
  },
  {
    "objectID": "cap1-1.html#section-2",
    "href": "cap1-1.html#section-2",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Ao criar um programa em uma linguagem Orientada a Objetos (OO)\n\nvocê está criando um modelo de alguma parte do mundo;\ne as partes do modelo são construídas a partir de objetos do domínio do problema."
  },
  {
    "objectID": "cap1-1.html#section-3",
    "href": "cap1-1.html#section-3",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Os objetos que criamos dependem do problema que estamos resolvendo\n\nSe estiver criando um software como o Word, os objetos podem ser palavras e parágrafos.\nJá se estiver programando uma rede social, podem ser usuários e mensagens.\nMas podem ser também monstros se estiver criando um jogo.\n\n\nOs objetos podem ser coisas mais concretas, como jogadores em um jogo de futebol.\n\nOu coisas mais abstratas, como um campeonato ou uma partida do jogo\n\n\n\n\n\n\n\nConceito\n\n\nObjetos Java modelam objetos do domínio de um problema."
  },
  {
    "objectID": "cap1-1.html#objetos-podem-ser-categorizados",
    "href": "cap1-1.html#objetos-podem-ser-categorizados",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Objetos podem ser categorizados",
    "text": "Objetos podem ser categorizados\nUma classe descreve, de forma abstrata, todos os objetos de um tipo específico.\n\nPara ficar mais claro, vamos pensar em um exemplo: uma simulação de trânsito.\n\nClaramente, nós precisaremos lidar com carros.\nNesse contexto, carro é uma classe ou um objeto?\n\n\n\nPara nos ajudar a decidir, vamos pensar em algumas perguntas?\n\nQual a cor do carro?\nO carro é rápido?\nQual direção está indo agora?\n\n\n\nNão dá para responder sem especificar de qual carro estamos falando.\n\nIsso porque a palavra “carro” nesse contexto, se refere a uma classe carro.\nEstamos falando de carros em geral e não de um carro em particular."
  },
  {
    "objectID": "cap1-1.html#section-4",
    "href": "cap1-1.html#section-4",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Agora, se eu digo: “meu carro velho está parado no estacionamento”.\n\nPodemos responder às perguntas.\nO carro é prata, é lento, e está no estacionamento.\n\n\nPortanto, agora estou falando de um objeto carro, pois é um exemplo de um carro em particular."
  },
  {
    "objectID": "cap1-1.html#section-5",
    "href": "cap1-1.html#section-5",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Uma classe pode ser vista como o projeto de um carro:\n\n\n\n\n\nEm uma fábrica de automóveis, por exemplo:\n\nOs engenheiros criam o projeto do carro.\nDepois os carros são produzidos de acordo com aquele projeto.\n\n\n\n\nNesse exemplo o projeto seria a classe, e os carros os objetos."
  },
  {
    "objectID": "cap1-1.html#section-6",
    "href": "cap1-1.html#section-6",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Uma classe pode ser vista como a planta de uma casa:\n\n\n\n\n\nEm um conjunto habitacional:\n\nO engenheiro cria uma planta idêntica para todas as casas.\nAs casas são então construídas de acordo com a planta.\n\n\n\n\nNesse exemplo a planta seria a classe, e as casas os objetos."
  },
  {
    "objectID": "cap1-1.html#section-7",
    "href": "cap1-1.html#section-7",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Pode realmente acontecer de nosso programa ter apenas um objeto de uma determinada classe."
  },
  {
    "objectID": "cap1-1.html#section-8",
    "href": "cap1-1.html#section-8",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Costumamos dizer que um objeto particular é uma instância de uma classe.\n\nInstância é sinônimo de exemplar daquele tipo.\nÉ sinônimo de objeto em OO.\nServe para enfatizar que é um exemplo particular de um classe específica.\n\n\n\n\n\n\nConceito\n\n\nObjetos são criados a partir de classes. A classe descreve o tipo do objeto; e os objetos representam instâncias individuais da classe."
  },
  {
    "objectID": "cap1-1.html#quiz",
    "href": "cap1-1.html#quiz",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Quiz",
    "text": "Quiz\nSobre objetos e classes é correto afirmar que:\n\nObjetos são usados para criar classes\nClasses são instâncias de objetos\nInstância é sinônimo de classe\nObjetos são instâncias de classes\n\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nAnote a resposta, pois você precisará depois responder ao Quiz no Campus Virtual para considerar a presença nessa aula."
  },
  {
    "objectID": "cap1-1.html#section-9",
    "href": "cap1-1.html#section-9",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Baixe o projeto de exemplo figuras e abra-o no BlueJ.\n\n\n\n\n\n\n\n\nComo baixar o projeto?\n\n\nOs projetos da disciplina são disponibilizados no GitHub. Se nunca o utilizou, não se preocupe, basta fazer o seguinte:\n\nClicando no link do projeto você verá um botão verde bem destacado escrito Code.\nClique nele e vá na última opção: Download ZIP.\nDescompacte o arquivo no seu computador, entre na pasta criada e clique duas vezes no arquivo: package.bluej.\n\n\n\n\n\n\n\nAo abrir o projeto, você verá um diagrama.\n\n\n\nCada retângulo representa uma classe no seu projeto.\nClique com o botão direito em Circulo e escolha a opção new Circulo().\nO sistema pedirá o nome da instância, apenas clique em OK."
  },
  {
    "objectID": "cap1-1.html#section-10",
    "href": "cap1-1.html#section-10",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Você verá um retângulo na parte inferior do BlueJ, chamado “circulo1”.\n\n\nEssa parte do BlueJ que mostra os objetos é chamada de bancada de objetos.\n\n\n\nAcabamos de criar nosso primeiro objeto.\n\nA caixa retangular representa a classe Circulo.\nE circulo1 é um objeto dessa classe.\n\n\n\n\n\n\n\n\nConvenção\n\n\nComeçamos os nomes de classes com letras maiúsculas e os nomes de objetos com letras minúsculas. Isso ajuda a identificar do que estamos falando.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAgora é com você: experimente criar outro círculo e um quadrado."
  },
  {
    "objectID": "cap1-1.html#section-12",
    "href": "cap1-1.html#section-12",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Veja que existem várias opções no menu do círculo.\n\nTente chamar moverDireita e moverBaixo algumas vezes até o círculo chegar perto do canto.\nExperimente também usar exibir e esconder.\n\n\n\n\n\n\nExercício\n\n\nO que acontece se você chamar moverBaixo duas vezes? Ou três vezes? O que acontece se chamar esconder duas vezes?"
  },
  {
    "objectID": "cap1-1.html#section-13",
    "href": "cap1-1.html#section-13",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "As opções do menu círculo representam operações que você pode usar para manipular o círculo\n\nElas são chamadas de métodos em Java.\nNós dizemos que os métodos são chamados ou invocados.\n\n\n\n\n\n\nConceito\n\n\nPodemos nos comunicar com objetos através da chamada de seus métodos. Geralmente os objetos fazem alguma coisa quando chamamos um método."
  },
  {
    "objectID": "cap1-1.html#section-14",
    "href": "cap1-1.html#section-14",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Nós podemos entender métodos também como comportamentos, ou mensagens que podem ser enviadas para os objetos.\n\nEm um jogo de futebol, por exemplo, quais são os comportamentos que um jogador pode ter?\n\n\n\nAlguns exemplos são: chutar, dar passe e correr.\n\nPortanto, um objeto jogador poderia ter os métodos chutar, darPasse e correr.\n\n\n\nJá fazerGol seria um método válido para um objeto jogador?\n\nVeja que o comportamento do jogador no jogo é chutar a bola. Fazer gol é uma consequência que pode acontecer ou não."
  },
  {
    "objectID": "cap1-1.html#section-15",
    "href": "cap1-1.html#section-15",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Vamos agora chamar o método moverHorizontal\n\nVeja que aparece uma caixa de diálogo que pede uma informação. \n\n\nDigite 50 e clique em OK.\n\nVocê verá que o círculo de move 50 pixels para a direita."
  },
  {
    "objectID": "cap1-1.html#section-16",
    "href": "cap1-1.html#section-16",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "O método que usamos precisa de informação adicional para ser executado.\n\nNesse caso, é a distância que o círculo deve ser mover.\nVeja que o método moverHorizontal é mais flexível que os métodos moverDireita e moverEsquerda que movem sempre por uma distância fixa.\n\n\n\n\n\n\nExercício\n\n\nTente chamar os métodos moverVertical, moverVerticalLento e mudarTamanho antes de continuar lendo. Descubra como o método moverHorizontal pode ser usado para movimentar o círculo 70 pixels para a esquerda.\n\n\n\n\n\n\nAs informações adicionais que alguns métodos precisam para executar são chamadas parâmetros.\n\nO método indica que tipos de parâmetros ele precisa."
  },
  {
    "objectID": "cap1-1.html#section-17",
    "href": "cap1-1.html#section-17",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Ao chamar o método moverHorizontal vemos na caixa de diálogo o seguinte:\n\nvoid moverHorizontal(int distancia)\n\n\nIsso é o que chamamos de assinatura do método.\n\nA parte que está entre parênteses (int distancia) indica as informações que o método precisa para executar.\nPara cada parâmetro, temos:\n\no tipo que indica o tipo de dado do parâmetro\ne o nome que dá uma ideia sobre o que significa a informação que é esperada.\n\n\n\n\n\n\n\n\nConceito\n\n\nMétodos podem ter parâmetros para fornecer informação adicional para uma tarefa.\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nO nome do método e os tipos dos seus parâmetros são chamados de assinatura. Ela tem todas as informações necessárias para chamar o método."
  },
  {
    "objectID": "cap1-1.html#section-18",
    "href": "cap1-1.html#section-18",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Quais poderiam ser os parâmetros de um método chutar de um objeto jogador em um jogo de futebol?\n\n\nOs parâmetros poderiam ser, por exemplo, a direção e a força do chute."
  },
  {
    "objectID": "cap1-1.html#quiz-1",
    "href": "cap1-1.html#quiz-1",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Quiz",
    "text": "Quiz\nSobre métodos e parâmetros é incorreto afirmar que:\n\nMétodos nos permitem comunicar com os objetos.\nParâmetros nos permitem fornecer informações adicionais aos métodos.\nA assinatura de um método indica quem o criou.\nEm Java, os parâmetros possuem um tipo e um nome."
  },
  {
    "objectID": "cap1-1.html#section-19",
    "href": "cap1-1.html#section-19",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Um tipo indica quais tipos de dados podem ser passados para um parâmetro.\n\nNo caso do método moverHorizontal o valor passado deve ser um inteiro (int).\n\n\nA maior parte dos métodos do projeto figuras que espera parâmetros, são parâmetros inteiros.\n\nRepare que ao clicarmos com o botão direito em um objeto (ex: circulo1), os métodos são listados já mostrando os parâmetros que eles esperam.\n\n\n\n\n\n\n\nConceito\n\n\nParâmetros têm tipos. O tipo define quais tipos de valores um parâmetro pode receber"
  },
  {
    "objectID": "cap1-1.html#section-20",
    "href": "cap1-1.html#section-20",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Veja que o método mudarCor espera um parâmetro do tipo String (texto).\n\nStrings em Java devem ser passadas entre aspas duplas (ex: \"vermelha\").\n\n\nVeja que quando clicamos em um método no BlueJ, a caixa de diálogo mostra também um texto de comentário antes da assinatura do método.\n\nComentários são usados para fornecer informações para nós, programadores.\nVeja que o comentário do método mudarCor indica quais são as cores que o programa conhece."
  },
  {
    "objectID": "cap1-1.html#section-21",
    "href": "cap1-1.html#section-21",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício\n\n\nChame o método mudarCor para um dos seus círculos e use a string “vermelha”. Tente também outras cores.\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente o que acontece quando você tenta usar uma cor que não existe.\n\n\n\n\n\n\n\n\nExercício\n\n\nTente chamar o método mudarCor e passar uma cor como parâmetro, mas sem as aspas. O que acontece?"
  },
  {
    "objectID": "cap1-1.html#section-22",
    "href": "cap1-1.html#section-22",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "A partir de uma classe, você pode criar vários objetos (ou instâncias).\n\nUsando a classe Circulo você pode criar muitos círculos. E o mesmo acontece com a classe Quadrado.\n\n\n\n\n\n\nExercício\n\n\nCrie vários objetos círculos, usando a opção new Circulo() no menu da classe Circulo. Faça um grande e amarelo e outro pequeno e verde. Experimente também criar alguns triângulos, quadrados e pessoas, mudando suas posições, tamanhos e cores.\n\n\n\n\n\n\nCada um desses objetos tem sua própria posição, cor e tamanho.\n\nVocê pode mudar uma característica de um objeto (como o tamanho), chamando um método daquele objeto.\nIsso muda apenas aquele objeto e não os demais.\nNós costumamos chamar as características dos objetos de atributos.\n\n\n\n\n\n\n\nConceito\n\n\nMúltiplas instâncias: muitos objetos similares podem ser criados a partir de uma única classe."
  },
  {
    "objectID": "cap1-1.html#section-23",
    "href": "cap1-1.html#section-23",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Ao fazer o último exercício você deve ter notado que o método mudarTamanho da classe Triangulo tem a seguinte assinatura.\n\nvoid mudarTamanho(int novaAltura, int novaLargura)\n\n\nEsse é um exemplo de um método com mais de um parâmetro.\n\nDe fato, métodos pode ter quaisquer quantidades de parâmetros."
  },
  {
    "objectID": "cap1-1.html#section-24",
    "href": "cap1-1.html#section-24",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Nós chamamos de estado de um objeto, o conjunto dos valores de todos os seus atributos.\n\nPara um círculo, por exemplo, seriam os valores de sua posição (X e Y), sua cor, seu diâmetro e sua informação de visibilidade.\n\n\nPodemos ver o estado de um objeto no BlueJ através da opção Inspecionar do menu de um objeto.\n\nEla exibe o Inspetor de objetos que mostra os atributos guardados dentro de um objeto."
  },
  {
    "objectID": "cap1-1.html#quiz-2",
    "href": "cap1-1.html#quiz-2",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Quiz",
    "text": "Quiz\nSe um programa tiver um objeto que é uma bola, a cor da bola é:\n\nUma instância.\nUm atributo.\nUm tipo.\nUm estado."
  },
  {
    "objectID": "cap1-1.html#section-25",
    "href": "cap1-1.html#section-25",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício\n\n\nCrie vários objetos de uma mesma classe e inspecione o estado de cada um. Com o inspetor de objetos aberto, mude o estado de um objeto (chamando o método moverEsquerda, por exemplo). Você verá os valores sendo modificados no inspetor de objetos.\n\n\n\n\n\nNo exercício vimos que alguns métodos, quando chamados, podem alterar o estado de um objeto.\n\nO método moverEsquerda, por exemplo, muda o valor do atributo posicaoX.\nNa linguagem Java, esses atributos também são chamados de campos."
  },
  {
    "objectID": "cap1-1.html#section-26",
    "href": "cap1-1.html#section-26",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Inspecionando objetos diferentes, você deve ter notado que objetos da mesma classe têm todos os mesmos atributos.\n\nOu seja, a quantidade, o tipo e os nomes dos campos são os mesmos.\nMas os valores de um atributo de cada objeto podem ser diferentes.\n\n\nJá objetos de classes diferentes podem ter atributos diferentes.\n\nPor exemplo: um círculo tem o atributo diâmetro, já um triângulo tem os atributos largura e altura.\n\n\n\nMas por que será que isso acontece?\n\nÉ que a quantidade, os tipos e os nomes dos atributos são definidos em uma classe, e não em um objeto."
  },
  {
    "objectID": "cap1-1.html#section-27",
    "href": "cap1-1.html#section-27",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "A classe Circulo, por exemplo, define que um objeto círculo terá cinco atributos chamados:\n\ndiametro\nposicaoX\nposicaoY\ncor\nestaVisivel\n\n\nA classe também define os tipos de cada atributo: os primeiros são int, a cor é do tipo String e o último é boolean (verdadeiro ou falso).\nAssim, quando um objeto da classe Círculo for criado, o objeto terá esses atributos."
  },
  {
    "objectID": "cap1-1.html#section-28",
    "href": "cap1-1.html#section-28",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Já os valores dos atributos são guardados dentro do objeto.\n\nPor isso, que cada círculo pode ter uma cor diferente, por exemplo."
  },
  {
    "objectID": "cap1-1.html#section-29",
    "href": "cap1-1.html#section-29",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "A mesma ideia vale para os métodos.\n\nMétodos são definidos na classe do objeto.\nAssim, objetos da mesma classe têm os mesmos métodos.\n\n\nMas, repare que os métodos são chamados nos objetos.\n\nAssim, quando o método moverDireita é chamado para um círculo, é apenas esse círculo que se move."
  },
  {
    "objectID": "cap1-1.html#section-30",
    "href": "cap1-1.html#section-30",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício\n\n\nEscolha uma das imagens abaixo e tente criar uma imagem parecida usando as formas do projeto figuras. Mas seja criativo e utilize cores, posições e tamanhos diferentes. Ao fazer isso, anote o que você teve que fazer para conseguir. Seria possível fazer de formas diferentes?\n\n\n\n\n\n\n\n\n\n\n\n\n\nEntrega no Campus Virtual\n\n\nTire um print da imagem que você criou no exercício anterior. Você precisará desse print para as atividades de entrega dessa aula!"
  },
  {
    "objectID": "cap1-1.html#section-31",
    "href": "cap1-1.html#section-31",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Vamos reforçar os conceitos que aprendemos usando agora um outro exemplo.\n\nBaixe o projeto de exemplo disciplina e abra-o no BlueJ.\n\n\n\n\n\n\nExercício\n\n\nCrie um objeto da classe Estudante. Veja que agora você precisa fornecer não só o nome do objeto, mas também alguns outros parâmetros.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nCrie alguns objetos da classe Estudante. Chame o método obterNome de cada objeto. Explique o que está acontecendo."
  },
  {
    "objectID": "cap1-1.html#section-32",
    "href": "cap1-1.html#section-32",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "O método obterNome da classe Estudante tem algo diferente:\n\nEle pode retornar um valor.\n\n\nNós conseguimos saber o tipo do valor retornado pela assinatura do método\n\nString obterNome()\n\n\n\nA palavra String antes do nome do método indica que ele retorna um valor string (texto).\n\n\nAgora repare a assinatura do método mudarNome.\n\nA palavra void indica que o método não retorna nenhum valor.\n\n\nvoid mudarNome(String novoNome)"
  },
  {
    "objectID": "cap1-1.html#section-33",
    "href": "cap1-1.html#section-33",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Portanto, podemos obter informações de um objeto através de uma chamada de método.\n\nQuer dizer então que os métodos podem mudar o estado de um objeto e/ou retornar algo sobre seu estado.\n\n\n\n\n\n\nConceito\n\n\nMétodos podem retornar informação sobre o objeto através de um valor de retorno"
  },
  {
    "objectID": "cap1-1.html#quiz-3",
    "href": "cap1-1.html#quiz-3",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Quiz",
    "text": "Quiz\nMarque a alternativa incorreta:\n\nObjetos da mesma classe têm os mesmos atributos.\nValores dos atributos são guardados dentro das classes.\nMétodos podem retornar valores.\nObjetos podem ser passados como parâmetros."
  },
  {
    "objectID": "cap1-1.html#section-34",
    "href": "cap1-1.html#section-34",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Vamos agora criar um objeto da classe Disciplina no projeto disciplina, chamado poo.\n\nAcesse o método matricularEstudante, o que o método espera como parâmetro?\n\n\n\n\n\n\nExercício\n\n\nCrie três estudantes e matricule-os na disciplina poo. Em seguida, chame o método imprimirLista do objeto poo.\n\n\n\n\n\n\nFazendo o exercício podemos perceber que objetos podem ser passados como parâmetros de métodos de outros objetos.\n\nQuando um método espera um objeto como parâmetro, o tipo do parâmetro é o nome da classe do objeto que deve ser passado."
  },
  {
    "objectID": "cap1-2.html#sobre-as-aulas-práticas",
    "href": "cap1-2.html#sobre-as-aulas-práticas",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "Sobre as Aulas Práticas",
    "text": "Sobre as Aulas Práticas\n\nAs aulas práticas são fundamentais para que consigamos entender os conceitos e saber como aplicá-los em um programa real.\n\nE, para conseguirmos acompanhar a aula, é fundamental ter estudado o conteúdo teórico ANP antes da aula prática.\n\nNão se esqueça de enviar suas atividades ao terminar aula (mesmo que não tiver terminado).\n\nPara que possa terminar em casa."
  },
  {
    "objectID": "cap1-2.html#section",
    "href": "cap1-2.html#section",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Programar em Java consiste, basicamente, em escrever comandos para chamar métodos de objetos.\n\nUsando o BlueJ, nós chamamos os métodos clicando nos objetos e acessando opções de menu.\nMas, em um programa normal em Java, nós digitamos os códigos que chamam os métodos."
  },
  {
    "objectID": "cap1-2.html#section-1",
    "href": "cap1-2.html#section-1",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "O BlueJ tem uma opção interessante que nos permite ver como as chamadas de métodos são feitas em Java.\n\n\n\n\n\nExercício 1.1\n\n\n\nBaixe o projeto de exemplo figuras e abra-o no BlueJ.\n\nAcesse o menu Exibir → Exibir Terminal (ou use o atalho Ctrl-TCtrl-T)\n\nSerá exibida uma janela que o BlueJ usa para exibir dados de saída.\nDica: arraste as janelas para que você consiga ver a janela principal do BlueJ e o Terminal ao mesmo tempo.\n\nNa janela do Terminal, acesse o menu Opções → Anotar chamadas de métodos.\n\nCom essa opção, todas as chamadas de método feitas pelo BlueJ serão exibidas como código Java.\n\nAgora, crie alguns objetos, chame alguns de seus métodos e observe a saída na janela do terminal."
  },
  {
    "objectID": "cap1-2.html#section-2",
    "href": "cap1-2.html#section-2",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "No passo anterior, vimos que o código Java necessário para criar uma pessoa, exibi-la e fazê-la mover para a direita seria o seguinte:\n\nPessoa pessoa1 = new Pessoa();\npessoa1.exibir();\npessoa1.moverDireita();\n\n\nPodemos observar que:\n\nQuando criamos um objeto e damos um nome a ele, na verdade estamos armazenando um objeto Pessoa em uma variável.\nChamamos métodos usando o nome da variável, seguido de ., seguido do nome do método, seguido da lista de parâmetros (que pode ser vazia) entre parênteses.\nTodos os comandos em Java terminam com ;."
  },
  {
    "objectID": "cap1-2.html#section-3",
    "href": "cap1-2.html#section-3",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Nós também podemos digitar comandos Java usando o Bloco de Códigos.\n\n\n\n\n\nExercício 1.2\n\n\n\nConfira se o Bloco de Códigos está sendo exibido no seu BlueJ.\n\nPara exibi-lo, acesse o menu Exibir → Exibir Bloco e Códigos (ou use o atalho Ctrl-ECtrl-E)\n\nVai aparecer um painel na parte inferior, à direita da bancada de objetos.\n\nAgora digite no Bloco de Códigos os comandos do slide anterior para criar uma pessoa, exibi-la e movê-la para a direita.\nEm seguida, digite os comandos necessários para desenhar uma bandeira do Brasil."
  },
  {
    "objectID": "cap1-2.html#section-4",
    "href": "cap1-2.html#section-4",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa primeira parte dos exercícios e envie um print do BlueJ mostrando a bandeira do Brasil que você criou."
  },
  {
    "objectID": "cap1-2.html#section-5",
    "href": "cap1-2.html#section-5",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 1.3\n\n\n\nBaixe o projeto de exemplo casa e abra-o no BlueJ.\n\nCrie uma instância da classe Figura e chame seu método desenhar. Em seguida, experimente os métodos definirPretoEBranco e definirColorida.\nComo você acha que a classe Figura desenha a figura que aparece?"
  },
  {
    "objectID": "cap1-2.html#section-6",
    "href": "cap1-2.html#section-6",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Repare que cinco classes do projeto casa são idênticas as do projeto figuras.\n\nMas há uma classe adicional: Figura.\nEssa classe é programada exatamente como você fez no exercício da aula teórica.\n\n\nGeralmente, quando queremos fazer alguma tarefa em Java, nós não fazemos na mão.\n\nNós criamos uma classe que faça a tarefa para nós.\nÉ isso que a classe Figura faz.\n\nA classe Figura é escrita de forma que, quando uma instância é criada, são criados dois objetos Quadrado (para a parede e para a janela), um Triângulo e um Círculo.\nEsses objetos são então exibidos, movidos e têm seu tamanho e cor alterados até a figura ficar como vimos."
  },
  {
    "objectID": "cap1-2.html#section-7",
    "href": "cap1-2.html#section-7",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "O importante aqui é entendermos que objetos podem criar objetos.\n\nE objetos podem chamar métodos de outros objetos.\nUm programa em Java tem centenas ou milhares de objetos.\n\nO usuário inicia o programa (que geralmente cria o primeiro objeto) e, daí em diante, todos os objetos são criados a partir de outros objetos.\n\n\n\n\n\n\n\nConceito\n\n\nObjetos podem se comunicar chamando métodos uns dos outros.\n\n\n\n\n\n\nMas como podemos escrever a classe para que objetos façam isso?"
  },
  {
    "objectID": "cap1-2.html#section-8",
    "href": "cap1-2.html#section-8",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Cada classe tem um código-fonte associada a ela; é o texto que define os detalhes da classe.\n\nNo BlueJ podemos ver o código de uma classe clicando duas vezes no retângulo da classe no diagrama.\n\n\nO código-fonte de nossas classes é escrito na linguagem Java.\n\nEle define os atributos e métodos que uma classe tem, e o que exatamente acontece quando um método é chamado.\nVeremos isso melhor na próxima aula.\n\n\n\nA maior parte da arte da programação consiste em aprender como escrever essas definições de classes.\n\nPara isso precisamos aprender a usar a linguagem Java (ou, claro, outras linguagens que existem).\n\n\n\n\n\n\n\nConceito\n\n\nO código-fonte de uma classe determina a estrutura e o comportamento (os atributos e métodos) de cada um dos objetos daquela classe."
  },
  {
    "objectID": "cap1-2.html#section-9",
    "href": "cap1-2.html#section-9",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "No BlueJ, quando alteramos o código de uma classe e fechamos o editor, o retângulo da classe aparece listrado.\n\nIsso indica que o código foi alterado e precisa ser recompilado.\nVocê pode recompilar uma classe, clicando com o botão direito no retângulo da classe e acessando a opção Compilar.\nOu você pode compilar todas as classes acessando o menu Ferramentas → Compilar (ou o atalho de teclado Ctrl-KCtrl-K)\nQuando recompilamos uma classe, o BlueJ remove quaisquer objetos que tenham sido criados antes."
  },
  {
    "objectID": "cap1-2.html#section-10",
    "href": "cap1-2.html#section-10",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 1.4\n\n\nNo código-fonte da classe Figura, encontre a parte que realmente desenha a figura e o altere de forma que o sol seja azul em vez de amarelo.\n\n\n\n\n\n\n\n\n\nExercício 1.5\n\n\nAdicione um segundo sol à figura. Para isso, repare a definição dos atributos no início da classe. Você verá o seguinte código\n\nprivate Quadrado parede;\nprivate Quadrado janela;\nprivate Triangulo telhado;\nprivate Circulo sol;\n\nVocê precisará adicionar uma linha nesse trecho para o segundo sol. Além disso, faça as alterações necessárias para que ele apareça quando a figura é desenhada."
  },
  {
    "objectID": "cap1-2.html#section-11",
    "href": "cap1-2.html#section-11",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 1.6\n\n\nVamos criar um pôr do sol no nosso projeto. Ou melhor, dois! Altere a classe Figura de forma que, quando uma figura é criada, os dois sóis se ponham automaticamente. Dica: lembre-se que a classe Circulo tem um método moverVerticalLento que você pode usar.\n\n\n\n\n\n\n\n\n\nExercício 1.7\n\n\nFica mais interessante se o pôr do sol for tratado em um método separado. Assim podemos criar a figura e depois começarmos o pôr do sol quando quisermos. Altere o código da classe Figura, criando um método chamado porDoSol e fazendo as alterações necessárias.\n\n\n\n\n\n\n\n\n\n\nExercício 1.8\n\n\nAltere a classe Figura para incluir uma pessoa na cena. Faça com que ela caminhe para a casa depois do pôr do sol."
  },
  {
    "objectID": "cap1-2.html#section-13",
    "href": "cap1-2.html#section-13",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Baixe o projeto de exemplo nave e abra-o no BlueJ."
  },
  {
    "objectID": "cap1-2.html#section-14",
    "href": "cap1-2.html#section-14",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Baixe o projeto de exemplo nave e abra-o no BlueJ."
  },
  {
    "objectID": "cap1-2.html#section-15",
    "href": "cap1-2.html#section-15",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.1 - Criando objetos para jogar\n\n\n\nEsse é um jogo bem simples, mas que será interessante para reforçarmos mais alguns conceitos de OO.\n\nVeja que existem seis classes no projeto: Nave, Inimigo, Placar, Cenario, Tiro e TesteJogo.\n\nVamos começar conhecendo os objetos envolvidos.\n\nCrie um objeto da classe Nave.\nClique com o botão direito no objeto e veja os métodos disponíveis.\nClique em Inspecionar e veja os atributos do objeto.\n\nFaça o mesmo com as seguintes classes:\n\nInimigo.\nPlacar.\n\nAgora crie um objeto da classe Cenario:\n\nVeja que para criar um cenário, é necessário passar objetos da classe Nave, Inimigo e Placar por parâmetro.\nPasse os objetos criados anteriormente.\nAvalie os métodos e atributos da objeto cenário."
  },
  {
    "objectID": "cap1-2.html#section-16",
    "href": "cap1-2.html#section-16",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.2 - Jogando\n\n\n\nBom, essa é a parte mais divertida…\n\nChame o método executarLoopDeJogo do objeto da classe Cenario.\n\nA dinâmica do jogo é simples.\n\nVocê controla a nave da esquerda usando as setas do teclado.\nE pode atirar digitando a tecla CtrlCtrl.\nA tecla ENTERENTER pausa o jogo.\nO inimigo se move aleatoriamente na vertical e também atira aleatoriamente.\nSeu objetivo é destruir o maior número de inimigos possível sem ser morto.\nVocê ganha 50 pontos a cada inimigo morto.\nSe você morrer, você pode reiniciar o jogo apertando a tecla F2F2.\n\nJogue um pouco e veja quantos pontos consegue alcançar:\n\nMas não se esqueça de continuar os exercícios ☺"
  },
  {
    "objectID": "cap1-2.html#section-17",
    "href": "cap1-2.html#section-17",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.3 - Conhecendo as classes\n\n\n\nNesse passo, vamos dar uma passada de olhos no código das classes do jogo.\n\nNão se preocupe em entender detalhes do código nesse momento.\nApenas tente identificar os atributos e métodos que existem no código-fonte das classes Nave, Inimigo e Placar.\nDê uma olhada com mais detalhes no método atirar da classe Nave e tente entender o que ele faz.\n\nObs.: a classe Cenario é bem complexa porque usa conceitos avançados, portanto, pode ignorá-la. Mas se estiver curioso, fique à vontade.\n\n\n\n\n\n\n\n\n\n\nExercício 2.4 - A Classe TesteJogo\n\n\n\nAbra o código da classe TesteJogo.\n\nRepare que ela possui uma nave, um inimigo, um placar e um cenário.\nEla cria esses objetos e chama o método executarLoopDeJogo da classe Cenario.\nMas isso é exatamente o que fizemos para iniciar o jogo.\n\nOu seja, essa classe é um atalho para inicializarmos o jogo mais rápido.\n\nBasta criar um objeto dessa classe que o jogo será executado.\n\nExperimente!"
  },
  {
    "objectID": "cap1-2.html#section-18",
    "href": "cap1-2.html#section-18",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.5 - Alterando o Código\n\n\n\nA classe Nave possui um método chamado getTextoExibicao.\n\nRepare que atualmente ele retorna uma string vazia.\nColoque algum texto na String e inicie o jogo pra ver o que acontece.\nDica: use um objeto da classe TesteJogo.\n\nVocê viu que o texto aparece ao lado da nave. Vamos aproveitar esse fato então para criar um atributo novo na classe Nave para guardar o nome da nave.\n\nCrie então um atributo do tipo String chamado nome.\nAvalie onde seria possível iniciar o atributo nome e coloque um nome bem criativo para a sua nave.\nPor fim, altere o método getTextoExibicao para que ele exiba o valor do atributo nome.\n\nVale ressaltar que o nome será definido diretamente no código.\n\nPortanto, se você quiser usar um nome diferente, será necessário alterar o código, recompilar e executar o jogo novamente.\n\nTeste suas alterações."
  },
  {
    "objectID": "cap1-2.html#section-19",
    "href": "cap1-2.html#section-19",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.6 - Melhorando a Nave\n\n\n\nA nave atualmente é muito fraca certo?\n\nCom apenas um tiro ela morre!\nE que tal se ela tivesse uma campo magnético de proteção contra tiros?\nAssim, quando ela tomar um tiro ela perde parte da proteção, mas só morre se o campo não for forte o suficiente para proteger a nave.\n\nAltere a classe Nave de forma que ela passe a ter o campo de proteção.\n\nCrie um atributo nivelDeProtecao.\nAvalie em qual método ele deve ser inicializado e faça com que a nave sempre comece o jogo com nível 100 de proteção.\nQuando a nave tomar um tiro, ela deve perder 20 pontos do seu campo de proteção.\n\nQual parte do código deve ser alterada para que a nave não morra com um único tiro, mas sim perca a proteção primeiro?\nLembre-se de que a nave deve morrer se tomar um tiro e o seu campo de proteção estiver abaixo de 20.\nLembre-se ainda, que ao reiniciar o jogo (usando a tecla F2F2), a nave deve voltar a ter nível 100 de proteção.\n\nFaça a alteração nos métodos necessários.\n\nJogue e teste o campo magnético de proteção da nave."
  },
  {
    "objectID": "cap1-2.html#section-20",
    "href": "cap1-2.html#section-20",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Exercício 2.7 - Melhorando a usabilidade\n\n\n\nBom, foi bacana nossa nave ter ficado mais forte.\n\nMas quem está jogando não sabe qual o nível de proteção atual da nave!\n\nAltere o método getTextoExibicao para exibir o nível do campo de proteção.\n\nExiba, na frente do nome da nave, o nível de proteção da nave.\n\nJogue novamente e teste a alteração.\n\nAgora ficou bem melhor, não ficou?\n\n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\nO operador + em Java pode ser usado para concatenar (juntar) Strings e também Strings com outros tipos de dados. A linguagem converte automaticamente números para strings, por exemplo.\nLogo, é possível em Java implementar um código como o apresentado abaixo. Experimente executá-lo no Bloco de Códigos do BlueJ e depois digite somente frase para que ele exiba o valor desta variável:\n\nint numero = 10;\nString palavra = \"nota\";\nString frase = palavra + \" \" + numero;"
  },
  {
    "objectID": "cap2-2.html#sobre-as-aulas-práticas",
    "href": "cap2-2.html#sobre-as-aulas-práticas",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Sobre as Aulas Práticas",
    "text": "Sobre as Aulas Práticas\n\nComo já foi comentado na aula passada:\n\nAulas práticas são importantes para o entendimento dos conceitos.\nMas, para isso, é fundamental que tenha estudado o conteúdo teórico ANP antes da aula prática.\n\n\n\n\n\n\n\n\n\nConvenção\n\n\nLembre-se que para ter presença na aula prática é necessário.\n\nResponder à chamada;\ne, também, entregar, no mínimo, 30% do exercícios propostos até o final da aula."
  },
  {
    "objectID": "cap2-2.html#section",
    "href": "cap2-2.html#section",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Para fazer os exercícios, baixe o projeto maquina-ingressos-ingenua.\n\n\n\n\nExercício 1.1\n\n\nModifique o construtor da classe MaquinaIngressos de forma que ele não receba mais parâmetros. Em vez disso, o preço dos ingressos deve ser fixado em 1000 centavos (R$ 10,00).\nCom essa alteração, o que muda na hora de criar uma máquina de ingressos no BlueJ?\n\n\n\n\n\n\n\n\nExercício 1.2\n\n\nAltere agora a classe de forma que ela passe a ter dois construtores. Um que recebe o preço do ingresso por parâmetro e outro que não recebe nenhum parâmetro (neste caso, escolha um valor fixo padrão para o preço dos ingressos).\nTeste as alterações criando máquinas usando os dois construtores."
  },
  {
    "objectID": "cap2-2.html#section-1",
    "href": "cap2-2.html#section-1",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.3\n\n\nCrie um método na classe MaquinaIngressos que retorne o valor do total de dinheiro arrecadado na máquina (o valor do atributo total). Ao escolher o nome do método, siga a convenção de nomenclatura da classe.\nAcrescente um comentário no método dizendo se esse é um método de acesso ou um método modificador, justificando sua resposta.\n\n\n\n\n\n\n\n\nExercício 1.4\n\n\nPara simular a operação de remover dinheiro da máquina de ingressos, crie um método chamado esvaziar na classe MaquinaIngressos. O método deve ter tipo de retorno void e deve somente mudar o valor do total para zero. Avalie se o método precisa receber algum parâmetro.\nAcrescente um comentário no método dizendo se esse é um método de acesso ou um método modificador, justificando sua resposta.\nPor fim, teste sua implementação inserindo dinheiro na máquina, comprando ingresso, verificando o total e então esvaziando a máquina e verificando o total novamente."
  },
  {
    "objectID": "cap2-2.html#section-2",
    "href": "cap2-2.html#section-2",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.5\n\n\nAo imprimir um ingresso você deve ter notado que aparece o texto Ingressos & Cia, que seria o nome da empresa que vende os ingressos. Vamos agora permitir que cada máquina possa vender ingressos de uma empresa diferente. Repare que, para isso, quando uma máquina é criada ela precisará guardar o nome da empresa.\nComo podemos fazer isso? (Pense na solução antes de continuar.)\n\nVeja que basta você alterar a classe MaquinaIngressos fazendo o seguinte:\n\nCrie um novo atributo para guardar o nome da empresa.\nReceba o nome da empresa por parâmetro nos dois construtores da classe e guarde a informação no novo atributo.\nAltere o método imprimirIngresso para que ele exiba o nome da empresa em vez do texto Ingressos & Cia.\nPara que o código fique mais completo, crie também um método de acesso que retorne o nome da empresa."
  },
  {
    "objectID": "cap2-2.html#section-3",
    "href": "cap2-2.html#section-3",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.6\n\n\nPara evitar a ação de cambistas, as empresas que vendem ingressos pediram que o nome do comprador seja impresso junto com o ingresso.\nComo você pode tratar isso fazendo alterações apenas no método imprimirIngresso?"
  },
  {
    "objectID": "cap2-2.html#section-4",
    "href": "cap2-2.html#section-4",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.7 - Desafio\n\n\nAltere o método imprimirIngresso de forma que o preço do ingresso seja exibido em reais, em vez de centavos. O preço deve aparecer conforme o exemplo abaixo.\n##################\n# Ingressos & Cia \n# Ingresso\n# R$ 5,00\n##################\nObservações:\n\nO valor do ingresso deve continuar sendo guardado em centavos. A alteração deve ser feita somente na hora de exibir os dados do ingresso na tela.\nPesquise na internet sobre como uma String pode ser formatada em Java de forma que o valor sempre apareça com duas casas decimais e com vírgula como separador dos decimais."
  },
  {
    "objectID": "cap2-2.html#section-5",
    "href": "cap2-2.html#section-5",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do projeto maquina-ingressos-ingenua da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar);"
  },
  {
    "objectID": "cap2-2.html#section-6",
    "href": "cap2-2.html#section-6",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Os exercícios a seguir são do projeto da nave, que você já trabalhou no capítulo anterior.\n\nEles servem para reforçar os conceitos e, ao mesmo tempo, para conhecer mais sobre a linguagem Java.\n\n\n\n\nFazendo esses os exercícios você terá um jogo mais interessante:\n\nO nível de proteção vai variar a cada vez que começa o jogo.\nOs tiros do inimigo terão velocidades diferentes.\nE o inimigo ficará mais rápido a cada mudança de nível (a cada 500 pontos)."
  },
  {
    "objectID": "cap2-2.html#section-7",
    "href": "cap2-2.html#section-7",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.1 - Nível de proteção variável\n\n\nVamos deixar a dificuldade do jogo um pouco imprevisível.\n\nCrie um método na classe Nave chamado gerarNivelDeProtecao.\nDentro desse método faça com que o atributo nivelDeProtecao receba um valor aleatório entre 0 e 140.\n\nDica: Estude como o objeto da classe Random é usado na classe Inimigo.\nRepare todos os lugares onde ele é usado na classe Inimigo e veja o que precisa ser feito de forma similar na classe Nave.\n\nAltere então a inicialização do atributo nivelDeProtecao, retirando o código atual que o inicializa com 100 e usando o retorno do método gerarNivelDeProtecao.\n\nJogue o jogo e reinicie-o algumas vezes ao morrer.\n\nDeu certo, conforme esperado? Senão, o que ficou faltando?"
  },
  {
    "objectID": "cap2-2.html#section-8",
    "href": "cap2-2.html#section-8",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.2 - Tiros variados\n\n\nA gente tinha facilitado as coisas colocando o campo de proteção.\n\nAgora vamos dificultar um pouco.\n\nVamos fazer com que cada tiro do inimigo possa ter uma velocidade diferente.\n\nA classe Tiro sabe quando um tiro é do inimigo ou da nave.\nAltere então o construtor da classe Tiro de forma que a velocidade do tiro do inimigo (apenas dele) possa ser de 1 a 5 vezes mais rápida que a velocidade normal (valor sorteado aleatoriamente).\n\nJogue o jogo e teste a alteração.\n\nE aí, ficou mais divertido?"
  },
  {
    "objectID": "cap2-2.html#section-9",
    "href": "cap2-2.html#section-9",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Nosso objetivo agora é fazer com que o inimigo fique mais rápido à medida que avançamos no jogo.\n\nA ideia é que o jogador comece no nível 1 e mude de nível a cada 500 pontos.\nE, a cada nível, o inimigo fica mais rápido.\nPara tratar isso, vamos fazer os próximos dois exercícios.\n\n\nObs.: os exercícios seguintes são opcionais."
  },
  {
    "objectID": "cap2-2.html#section-10",
    "href": "cap2-2.html#section-10",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "(OPCIONAL) Exercício 2.3 - Tratando níveis\n\n\nFaça as alterações a seguir na classe Placar:\n\nCrie um novo atributo chamado nivelAtual.\nInicialize o novo atributo com valor 1 dentro do método inicializar.\nAltere o método contarMorteInimigo de forma que, a cada 500 pontos, o nível atual seja incrementado em 1.\n\nDica: Basta acrescentar uma condição que verifique o resto da divisão por zero.\nif (pontos % 500 == 0) {\n    nivelAtual = nivelAtual + 1\n}\n\nCrie um método de acesso que retorne o nível atual.\n\nAgora, precisamos que o jogador consiga saber em que nível está.\n\nPara isso, procure o método desenharPlacar em Cenario e encontre a linha abaixo:\ng.drawString(\"Pontos: \" + placar.getPontos(), posX, posY);\nVeja que o primeiro argumento passado para o método drawString é a String que aparece na tela com o valor do placar (ex: Pontos: 150).\n\nConcatene à String passada a palavra nivel e o valor do nível atual (usando o método de consulta que você criou na classe Placar).\n\n\nJogue o jogo e teste suas alterações."
  },
  {
    "objectID": "cap2-2.html#section-11",
    "href": "cap2-2.html#section-11",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "(OPCIONAL) Exercício 2.4 - Inimigo mais rápido\n\n\nVamos agora fazer com que o inimigo fique mais rápido a cada mudança de nível.\nQuando o inimigo morre, o método inicializar da classe Inimigo é chamado para que ele viva novamente.\n\nVamos alterar esse método para que ele receba o nível atual do jogo e defina a velocidade do inimigo de acordo com o nível.\n\nPara isso: crie um parâmetro no método para receber o nível atual.\nE altere a linha que define a velocidade de forma que ela seja igual a 10 no primeiro nível, 20 no segundo nível e assim sucessivamente.\n\n\nPrecisaremos alterar agora as chamadas do método inicializar do inimigo, passando o nível atual.\n\nNa própria classe Inimigo o método é chamado no construtor. Altere a chamada passando o valor 1 como o nível atual.\nO método inicializar do inimigo é chamado também dentro do método reiniciarInimigo da classe Cenario. Altere a chamada passando o valor do nível atual (usando o objeto placar).\n\nSe você testar as alterações feitas até agora, verá que, quando o jogo reinicia, a velocidade do inimigo no primeiro nível não fica correta.\n\nPara corrigir isso, basta alterar o método inicializar da classe Cenario de forma que o placar seja inicializado antes do inimigo.\n\nDica: enquanto estiver testando, para agilizar, faça com que o nível mude a cada 100 pontos em vez de 500. Mas não esqueça de voltar para 500 antes de terminar."
  },
  {
    "objectID": "cap2-2.html#section-12",
    "href": "cap2-2.html#section-12",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do projeto nave da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar);"
  },
  {
    "objectID": "cap2-4.html#sobre-as-aulas-práticas",
    "href": "cap2-4.html#sobre-as-aulas-práticas",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Sobre as Aulas Práticas",
    "text": "Sobre as Aulas Práticas\n\nRelembrando:\n\nAulas práticas são importantes para o entendimento dos conceitos.\nMas, para isso, é fundamental que tenha estudado o conteúdo teórico ANP antes da aula prática.\n\n\n\n\n\n\n\n\n\nConvenção\n\n\nLembre-se que para ter presença na aula prática é necessário.\n\nResponder à chamada;\ne, também, entregar, no mínimo, 30% do exercícios propostos até o final da aula."
  },
  {
    "objectID": "cap2-4.html#section",
    "href": "cap2-4.html#section",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "É muito comum precisarmos implementar expressões em nossos códigos.\n\nComo cálculos usando variáveis.\nOu chamadas de métodos de variáveis que são objetos.\nO Bloco de Códigos do BlueJ pode ser muito útil para experimentarmos expressões antes de as implementarmos em nossas classes.\n\n\nTente adivinhar os resultados das expressões abaixo, antes de usar o Bloco de Códigos.\n\n2023 + 4\n\"passa\" + \"tempo\"\n\"passa\" + 9\n7 + 2 + \"tempo\"\n\"tempo\" + 7 + 2\n\"passatempo\".substring(5,6)\n\"passatempo\".substring(5,11)\n\n\n\nO que foi novidade para você nesse exercício?"
  },
  {
    "objectID": "cap2-4.html#section-1",
    "href": "cap2-4.html#section-1",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "No Bloco de Códigos, quando o resultado de uma expressão é um objeto (como uma String), aparece um símbolo vermelho próximo ao resultado.\n\nVocê pode clicar duas vezes no símbolo para inspecionar o objeto.\nOu clicar uma vez para colocá-lo na bancada de objetos.\nExperimente!\n\n\nVocê pode também declarar variáveis e escrever comandos completos no Bloco de Códigos.\n\nExperimente os comandos abaixo:\nsoma = 2023 + 4;\nint soma = 0;\nsoma = 2023 + 4;\n\n\n\nSe você digitar o nome de uma variável sem ponto-e-vírgula, o Bloco de Códigos exibe seu valor.\n\nExperimente digitar, por exemplo: soma"
  },
  {
    "objectID": "cap2-4.html#section-2",
    "href": "cap2-4.html#section-2",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nAbra o projeto maquina-ingressos-melhor e digite o código abaixo. Veja que tem linhas que terminam com ponto-e-virgula e outras não. Preste atenção ao valor retornado pelo método obterSaldo em cada chamada.\n\nMaquinaIngressos m1 = new MaquinaIngressos(1000);\nm1.obterSaldo()\nm1.inserirDinheiro(500);\nm1.obterSaldo()\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAgora digite a linha abaixo no Bloco de Códigos.\n\nMaquinaIngressos m2 = m1;\n\nO que você acha que a chamada m2.obterSaldo() retornaria?\nExperimente!"
  },
  {
    "objectID": "cap2-4.html#section-3",
    "href": "cap2-4.html#section-3",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício\n\n\nAgora digite o comando abaixo\n\nm1.inserirDinheiro(500);\n\nAvalie a linha abaixo e tente adivinhar o que ela vai retornar antes de digitar o código no Bloco de Códigos.\n\nm2.obterSaldo()\n\nA resposta foi a que você esperava?\nVocê consegue imaginar alguma ligação entre m1 e m2 que explique o que está acontecendo?"
  },
  {
    "objectID": "cap2-4.html#section-4",
    "href": "cap2-4.html#section-4",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Vamos agora começar os exercícios de implementação a serem entregues nessa semana.\nBaixe o projeto exercicio-livro.\n\nAvalie o código da classe Livro antes de começar os exercícios.\nVeja que ela tem apenas o rascunho inicial da classe, com dois atributos e um construtor.\nNos exercícios vamos completá-la."
  },
  {
    "objectID": "cap2-4.html#section-5",
    "href": "cap2-4.html#section-5",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.1\n\n\nAdicione à classe Livro dois métodos, imprimirAutor e imprimirTitulo, que exibem no terminal os valores de seus atributos correspondentes.\n\n\n\n\n\n\n\n\n\nExercício 1.2\n\n\nAdicione um atibuto paginas à classe Livro para guardar a quantidade de páginas do livro. O atributo deve ser do tipo int e seu valor inicial deve ser passado para o construtor junto com o autor e o titulo. Adicione também um método de acesso obterPaginas para esse atributo.\n\n\n\n\n\n\n\n\n\n\nExercício 1.3\n\n\nOs objetos Livro são imutáveis? Escreva sua resposta no comentário da classe (que aparece antes da declaração da classe)."
  },
  {
    "objectID": "cap2-4.html#section-6",
    "href": "cap2-4.html#section-6",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.4\n\n\nAdicione um método imprimirDetalhes à classe Livro, que imprime no terminal o autor, o título e o número de páginas. Escolha como você quer que a informação apareça na tela (poderia ser tudo em uma linha, ou uma informação por linha, por exemplo). Pode ser útil explicar para o usuário o que é cada informação. Exemplo:\n\nLivro de título: A Dança dos Dragões, escrito por: George R. R. Martin (864 páginas)\n\n\n\n\n\n\n\n\n\n\nExercício 1.5\n\n\nVamos agora adicionar um atributo para representar o número de chamada do livro, que é o identificador usado na biblioteca quando queremos buscar um livro. O livro da disciplina, por exemplo, tem o número de chamada 005.133 BAR pro.\nCrie então um atributo para guardar essa informação (note que ele precisa ser do tipo String). O atributo deve ser inicializado com string vazia (\"\") no construtor. Crie um método modificador para o número de chamada, de forma que o usuário consiga defini-lo depois que o objeto estiver criado. Crie também um método de acesso para que o usuário consiga consultar o valor definido."
  },
  {
    "objectID": "cap2-4.html#section-7",
    "href": "cap2-4.html#section-7",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.6\n\n\nModifique o método imprimirDetalhes para incluir o número de chamada do livro. Caso o livro ainda não tenha um número de chamada definido, o método deve exibir a informação NDEF (de “não definido”).\nDica: use um comando condicional e o método length da classe String para saber se o número de chamada já foi definido ou não.\n\n\n\n\n\n\n\n\n\nExercício 1.7\n\n\nAltere o método que define o número de chamada de forma que ele só aceite números de chamada que tenham pelo menos três caracteres. Caso o valor passado tenha menos que três caracteres, uma mensagem de erro deve ser exibida e o número de chamada não deve ser alterado."
  },
  {
    "objectID": "cap2-4.html#section-8",
    "href": "cap2-4.html#section-8",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 1.8\n\n\nPor fim, vamos alterar a classe Livro para que seja possível contabilizar quantas vezes o livro já foi emprestado.\n\nCrie um atributo numeroEmprestimos do tipo int para guardar a quantidade de vezes que o livro foi emprestado.\nCrie um método emprestar que adiciona 1 ao atributo.\nCrie um método de acesso que permita consultar o número de empréstimos.\nAltere o método imprimmirDetalhes para incluir a informação do atributo criado."
  },
  {
    "objectID": "cap2-4.html#section-9",
    "href": "cap2-4.html#section-9",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do projeto exercicio-livro da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap2-4.html#section-10",
    "href": "cap2-4.html#section-10",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Agora, na segunda parte, vamos criar um novo projeto do zero no BlueJ.\nMas como todos os exercícios que vocês fizeram no BlueJ até o momento utilizaram projetos já criados, antes de começarmos os exercícios, veja nos slides a seguir como criar um novo projeto e uma nova classe no BlueJ."
  },
  {
    "objectID": "cap2-4.html#section-11",
    "href": "cap2-4.html#section-11",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Acesse o menu Projeto → Novo Projeto."
  },
  {
    "objectID": "cap2-4.html#section-12",
    "href": "cap2-4.html#section-12",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Aparecerá uma caixa de diálogo na qual você informará o nome do projeto.\n\nVocê pode também mudar a pasta onde o projeto será colocado.\n\nSerá criada uma subpasta dentro dela com o nome que escolheu para o projeto.\n\nO projeto será criado, a princípio, sem nenhuma classe."
  },
  {
    "objectID": "cap2-4.html#section-13",
    "href": "cap2-4.html#section-13",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Clique no botão Nova Classe….\n\nNa caixa diálogo que aparece digite um nome para a classe e clique em OK."
  },
  {
    "objectID": "cap2-4.html#section-14",
    "href": "cap2-4.html#section-14",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "A nova classe aparecerá no diagrama do BlueJ.\n\nNa imagem abaixo, por exemplo, foi criada uma classe de nome Teste."
  },
  {
    "objectID": "cap2-4.html#section-15",
    "href": "cap2-4.html#section-15",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Clique duas vezes na classe no diagrama para abrir o código-fonte.\n\nVeja que a classe é criada com um código inicial de exemplo.\nApague e/ou altere o código de acordo com que precisar implementar na sua classe."
  },
  {
    "objectID": "cap2-4.html#resumo",
    "href": "cap2-4.html#resumo",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "Resumo",
    "text": "Resumo\n\nAcesse o menu Projeto → Novo Projeto.\n\nDê um nome para o projeto.\n\nClique no botão Nova Classe….\n\nDigite um nome para a classe e clique em OK.\n\nClique duas vezes na classe no diagrama para abrir o código-fonte.\n\nApague e/ou altere o código gerado para a classe de acordo com que precisar implementar na sua classe."
  },
  {
    "objectID": "cap2-4.html#section-16",
    "href": "cap2-4.html#section-16",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.1\n\n\nCrie um novo projeto chamado exercicio-aquecedor dentro do BlueJ.\n\nCrie uma classe chamada Aquecedor que contenha um único atributo, chamado temperatura, cujo tipo é double (ponto flutuante de precisão dupla).\nImplemente um construtor que não aceite parâmetros.\nO campo temperatura deve ser definido como o valor 20.0 no construtor.\nImplemente os métodos modificadores esquentar e esfriar, cujo efeito é aumentar ou diminuir o valor da temperatura em 3.0 graus, respectivamente.\nDefina um método de acesso para retornar o valor da temperatura.\n\nTeste a classe criando alguns objetos e chamando seus métodos."
  },
  {
    "objectID": "cap2-4.html#section-17",
    "href": "cap2-4.html#section-17",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.2\n\n\nModifique sua classe Aquecedor para definir três novos atributos de ponto flutuante de precisão dupla: min, max e incremento.\n\nOs valores de min e max devem ser definidos por parâmetros passados ​​ao construtor.\nJá o valor de incremento deve ser definido como 3.0 no construtor.\nModifique a implementação dos métodos esquentar e esfriar para que usem o valor de incremento em vez de um valor explícito de 3.0.\n\nAntes de prosseguir para o próximo exercício, verifique se tudo funciona como antes."
  },
  {
    "objectID": "cap2-4.html#section-18",
    "href": "cap2-4.html#section-18",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.3\n\n\nAgora modifique o método esquentar para que ele não permita que a temperatura seja definida para um valor maior que max.\n\nDa mesma forma, modifique esfriar para que ele não permita que a temperatura seja definida para um valor menor que min.\n\nVerifique se a classe funciona corretamente."
  },
  {
    "objectID": "cap2-4.html#section-19",
    "href": "cap2-4.html#section-19",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Exercício 2.4\n\n\nAgora adicione um método chamado mudarIncremento, que espera um único parâmetro do tipo apropriado e o usa para definir o valor de incremento.\nMais uma vez, teste se a classe funciona como você esperaria criando alguns objetos Aquecedor dentro do BlueJ e chamando seus métodos.\nAs coisas ainda funcionam como esperado se um valor negativo for passado para o método mudarIncremento?\n\nAdicione uma verificação a este método para evitar que um valor negativo seja atribuído ao incremento."
  },
  {
    "objectID": "cap2-4.html#section-20",
    "href": "cap2-4.html#section-20",
    "title": "IPOO - Cap. 2 Entendendo as Definições de Classe",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do seu projeto exercicio-aquecedor (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap3-2.html#section",
    "href": "cap3-2.html#section",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Algumas coisas para relembrar e pensar:\n\nO que precisa ser feito antes das aulas práticas mesmo?\nE o que você precisa fazer para ter presença na aula prática?"
  },
  {
    "objectID": "cap3-2.html#sobre-essa-aula",
    "href": "cap3-2.html#sobre-essa-aula",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Sobre essa aula",
    "text": "Sobre essa aula\nNa primeira parte da aula:\n\nvamos aprender a usar uma ferramenta muito útil para todo programador.\nFaremos isso sincronizando toda a turma.\n\n\nNa segunda parte:\n\nTeremos exercícios práticos como de costume.\nCada um fazendo no seu próprio passo."
  },
  {
    "objectID": "cap3-2.html#section-1",
    "href": "cap3-2.html#section-1",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Na aula teórica vimos um exemplo de interação entre objetos, no projeto visor-relogio.\n\nVimos que objetos podem criar objetos e chamar métodos de outros objetos\nAprendemos isso usando leitura de código.\n\nLer e entender código é uma habilidade fundamental.\nUm desenvolvedor de software faz isso durante toda a carreira.\n\nMas, às vezes, vale muito a pena usar ferramentas adicionais.\n\nPara entender mais profundamente como um programa funciona.\n\n\n\n\n\nUma dessas ferramentas, que vamos aprender a usar agora, é o depurador (debugger)."
  },
  {
    "objectID": "cap3-2.html#section-2",
    "href": "cap3-2.html#section-2",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Um depurador é um programa que permite que programadores possam executar seus programas um passo de cada vez.\n\nGeralmente ele tem uma função de parar e continuar a execução de um programa em um ponto específico do código.\n\nE permite examinar os valores das variáveis.\n\n\n\nIDEs mais avançadas têm depuradores complexos, com inúmeras funcionalidades.\n\nJá o BlueJ tem um depurador que faz o básico:\n\nParar o programa, executar uma linha de cada vez e ver os valores das variáveis.\nMesmo sendo “só isso”, é uma mão na roda na hora de programar.\n\n\n\n\n\n\n\n\nAcredite: a qualidade de vida de um programador muda de patamar quando ele passa a usar um depurador!"
  },
  {
    "objectID": "cap3-2.html#o-exemplo-do-sistema-de-e-mail",
    "href": "cap3-2.html#o-exemplo-do-sistema-de-e-mail",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "O exemplo do sistema de e-mail",
    "text": "O exemplo do sistema de e-mail\nPara aprender a usar o depurador, vamos trabalhar com o projeto de exemplo sistema-de-email.\n\nPor enquanto, não vamos avaliar o código.\nVamos apenas executar o projeto e entender como ele funciona.\n\n\nA ideia do projeto é simular o envio e recebimento de e-mails entre usuários.\n\nUm usuário usa um cliente de e-mail para enviar e-mails para um servidor.\nE outros usuários podem baixar seus e-mails do servidor."
  },
  {
    "objectID": "cap3-2.html#section-3",
    "href": "cap3-2.html#section-3",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nExperimente a simulação do sistema de e-mails.\n\nCrie um objeto ServidorDeEmail.\nCrie um objeto ClienteDeEmail para um usuário, passando o servidor de e-mail criado.\nCrie outro objeto ClienteDeEmail para outro usuário, passando o mesmo servidor de e-mail.\nExperimente enviar e-mails de um usuário para outro (usando o método enviarEmail);\n\ne receber os e-mails (usando obterProximoEmail ou imprimirProximoEmail).\n\nExperimente também criando mais clientes de e-mail."
  },
  {
    "objectID": "cap3-2.html#section-4",
    "href": "cap3-2.html#section-4",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Ao fazer o exercício anterior vimos que:\n\nO projeto tem três classes: ServidorDeEmail, ClienteDeEmail e Email.\nUm objeto servidor de email deve ser criado primeiro para ser usado pelos clientes de e-mail.\n\nÉ ele quem cuida da troca de mensagens.\n\nVários clientes de e-mail podem ser criados.\n\nCada cliente de e-mail está associado a um nome de usuário.\n\nE-mails podem ser enviados de um cliente para outro usando um método da classe do cliente de e-mail.\nE-mails podem ser recebidos, um de cada vez, do servidor, usando um método da classe do cliente de e-mail.\nA classe Email nunca é instanciada explicitamente pelo usuário.\n\nEla é usada internamente pelos clientes de e-mail e pelo servidor para criar, armazenar e trocar mensagens.\n\n\n\n\n\n\n\nAtividade em aula\n\n\nDesenhe o diagrama de objetos representando a situação logo após a criação de um servidor de e-mail e três clientes de e-mail."
  },
  {
    "objectID": "cap3-2.html#section-5",
    "href": "cap3-2.html#section-5",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Não vamos analisar todo o código do projeto.\n\nA classe ServidorDeEmail usa conceitos que veremos apenas mais adiante na disciplina.\n\nVamos então usar abstração, assumindo que ela faz o que tem que fazer sem nos preocuparmos em entender seus detalhes.\n\n\n\nA classe Email é bem simples.\n\nDê uma olhada no código e veja se tem alguma dúvida.\nRepare que, no construtor, ela usa algo do Java que não tínhamos visto ainda.\n\nA palavra-chave this."
  },
  {
    "objectID": "cap3-2.html#section-6",
    "href": "cap3-2.html#section-6",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "public class Email\n{\n    private String remetente;\n    private String destinatario;\n    private String mensagem;\n    \n    public Email(String remetente, String destinatario, String mensagem)\n    {\n        this.remetente = remetente;\n        this.destinatario = destinatario;\n        this.mensagem = mensagem;\n    }\n\n    // métodos omitidos\n\nVamos avaliar a primeira linha do construtor."
  },
  {
    "objectID": "cap3-2.html#section-7",
    "href": "cap3-2.html#section-7",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "public class Email\n{\n    private String remetente;\n    private String destinatario;\n    private String mensagem;\n    \n    public Email(String remetente, String destinatario, String mensagem)\n    {\n        this.remetente = remetente;\n        this.destinatario = destinatario;\n        this.mensagem = mensagem;\n    }\n\n    // métodos omitidos\n\n\nRepare que é um comando de atribuição.\n\nA variável do lado esquerdo (this.remetente), recebe o valor da variável do lado direito (remetente).\n\nPrecisarmos usar this aqui por causa da sobrecarga de nomes.\n\nUm mesmo nome usado para coisas diferentes."
  },
  {
    "objectID": "cap3-2.html#section-8",
    "href": "cap3-2.html#section-8",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Quantos atributos a classe tem?\n\n3 (remetente, destinatario e mensagem).\n\n\nE quantos parâmetros o construtor tem?\n\n3 (também chamados remetente, destinatario e mensagem).\n\n\n\nPortanto, de quantas variáveis estamos falando?\n\n6 (3 parâmetros + 3 atributos).\nRepare que apesar de terem o mesmo nome, os atributos e os parâmetros são coisas diferentes."
  },
  {
    "objectID": "cap3-2.html#section-9",
    "href": "cap3-2.html#section-9",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Suponha que tivéssemos a linha de código destacada abaixo no construtor:\n\n    public Email(String remetente, String destinatario, String mensagem)\n    {\n        System.out.println(remetente);\n        this.remetente = remetente;\n        this.destinatario = destinatario;\n        this.mensagem = mensagem;\n    }\n\n\nSeria exibido o valor do atributo remetente ou do parâmetro remetente?\n\nA especificação da linguagem Java indica o uso do escopo mais próximo.\nO parâmetro foi declarado no construtor, e o atributo na classe.\n\nLogo, o parâmetro foi declarado “mais perto” da linha de código.\nPortanto, na linha de código acima, estamos referenciando o parâmetro remetente."
  },
  {
    "objectID": "cap3-2.html#section-10",
    "href": "cap3-2.html#section-10",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Portanto, para inicializarmos o atributo remetente precisamos de uma maneira de conseguir referenciá-lo.\n\nE é justamente para isso que a palavra-chave this serve.\n\n\nthis é uma referência para o próprio objeto que está tendo seu método executado.\n\nAssim, this.remetente se refere ao atributo remetente do objeto atual.\n\n\n\nPortanto:\n\n    this.remetente = remetente;\n\n\n\nPode ser lido como:\n\n    atributo chamado remetente *recebe* parâmetro chamado remetente;"
  },
  {
    "objectID": "cap3-2.html#section-11",
    "href": "cap3-2.html#section-11",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "O motivo de usarmos o mesmo nome é a legibilidade.\n\nÀs vezes, encontramos o melhor nome para descrever uma variável.\nComo é o melhor nome, queremos usá-lo para nomear o parâmetro.\n\nPara facilitar para quem precisa chamar o construtor ou método.\n\nE, pelo mesmo motivo, queremos usá-lo também para nomear o atributo.\n\nLogo, precisamos do this para diferenciar um do outro."
  },
  {
    "objectID": "cap3-2.html#section-12",
    "href": "cap3-2.html#section-12",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nO que aconteceria se o construtor fosse implementado desse jeito?\n\n    public Email(String remetente, String destinatario, String Mensagem)\n    {\n        remetente = this.remetente;\n        destinatario = destinatario;\n        this.mensagem = mensagem;\n    }"
  },
  {
    "objectID": "cap3-2.html#section-13",
    "href": "cap3-2.html#section-13",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "A classe mais interessante do sistema de e-mails é a de cliente de email.\n\nVamos estudá-la em detalhes usando o depurador.\nPara isso, vamos preparar um cenário de uso."
  },
  {
    "objectID": "cap3-2.html#section-14",
    "href": "cap3-2.html#section-14",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nCrie um servidor de e-mail, e depois crie dois clientes de e-mail para os usuários “Tião” e “Maria”. Dica use nomes de variáveis tiao e maria para os clientes de e-mail para facilitar.\nEnvie um e-mail da Maria para o Tião usando o método enviarEmail. Não leia a mensagem ainda!"
  },
  {
    "objectID": "cap3-2.html#section-15",
    "href": "cap3-2.html#section-15",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Depois do exercício, o servidor tem um e-mail armazenado para o Tião, esperando para ser buscado.\n\nVocê já sabe que o método imprimirProximoEmail vai pegar esse e-mail e exibi-lo no terminal.\nVamos entender como isso funciona exatamente, usando o depurador."
  },
  {
    "objectID": "cap3-2.html#definindo-pontos-de-parada-breakpoints",
    "href": "cap3-2.html#definindo-pontos-de-parada-breakpoints",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Definindo pontos de parada (breakpoints)",
    "text": "Definindo pontos de parada (breakpoints)\nUm breakpoint é uma marcação ligada a uma linha de código na qual o depurador para a execução do programa.\n\nNo BlueJ você pode definir um breakpoint selecionando uma linha e teclando Ctrl+B.\n\nOu clicando na barra na margem esquerda da linha.\nAparece um marcador indicando que o breakpoint foi criado. \n\nObs.: a classe precisa estar compilada para que você consiga fazer isso.\n\nVocê pode remover o breakpoint clicando no marcador."
  },
  {
    "objectID": "cap3-2.html#section-16",
    "href": "cap3-2.html#section-16",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nCrie um breakpoint na primeira linha do método imprimirProximoEmail.\n\n\n\n\n\nAgora chame o método imprimirProximoEmail do cliente de e-mail do Tião.\n\nO que acontece?\n\n\n\nA janela do depurador do BlueJ é exibida."
  },
  {
    "objectID": "cap3-2.html#section-17",
    "href": "cap3-2.html#section-17",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Do lado direito da janela do depurador podemos observar que:\n\nNão há variáveis de classe (estáticas).\n\nVeremos esse conceito mais adiante na disciplina.\n\nVemos as variáveis de instância.\n\nOu seja, os atributos do objeto que teve o método chamado.\n\nO servidor: uma referência para o objeto do servidor.\nE o usuário: a string “Tião”.\n\n\nE ainda não há variáveis locais.\n\nIsso porque a linha do breakpoint ainda não foi executada.\nO programa parou antes de executar essa linha.\n\n\n\nVeja então que o depurador nos permite parar a execução do programa, ver os valores as variáveis\n\ne, especialmente, a partir de agora executar o programa passo a passo."
  },
  {
    "objectID": "cap3-2.html#depuração-passo-a-passo",
    "href": "cap3-2.html#depuração-passo-a-passo",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Depuração passo a passo",
    "text": "Depuração passo a passo\nNa parte inferior da janela do depurador há botões que nos permitem controlar a execução do programa.\n\n\n\n\nAtividade em aula\n\n\nUse o botão Avançar uma vez para executar uma linha do método imprimirProximoEmail.\n\n\n\n\n\nVeja que, no editor de código, a linha destacada agora é a próxima linha.\n\nE, na janela do depurador, vemos que a variável local email foi criada.\n\nVocê pode, inclusive, clicar duas vezes na variável para inspecionar o objeto."
  },
  {
    "objectID": "cap3-2.html#section-18",
    "href": "cap3-2.html#section-18",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nAntes de continuar, advinhe qual será a próxima linha a ser executada. Depois, clique novamente em Avançar e veja se tinha acertado. Tente entender porque você acertou ou errou."
  },
  {
    "objectID": "cap3-2.html#section-19",
    "href": "cap3-2.html#section-19",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Podemos agora clicar em Avançar repetidamente até terminar o método.\n\nCom isso conseguimos acompanhar o fluxo de execução do nosso programa.\nIsso é especialmente interessante em comandos condicionais (blocos if-else).\n\nPois podemos entender e/ou confirmar qual bloco de código foi executado."
  },
  {
    "objectID": "cap3-2.html#section-20",
    "href": "cap3-2.html#section-20",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nChame novamente o método imprimirProximoEmail do cliente de e-mail do Tião. Avance a execução passo a passo e observe o que acontece dessa vez. Explique porque o fluxo de execução foi diferente."
  },
  {
    "objectID": "cap3-2.html#entrando-em-métodos",
    "href": "cap3-2.html#entrando-em-métodos",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "Entrando em métodos",
    "text": "Entrando em métodos\nAo depurarmos as chamadas do método imprimirProximoEmail, você deve ter notado duas chamadas de métodos externos.\n\nNa linha abaixo, é chamado um método do objeto servidor.\n\nNa declaração dos atributos, vemos que o objeto é do tipo ServidorDeEmail.\nPortanto, o objeto da classe cliente de e-mail está chamando o método obterProximoEmail do objeto servidor de e-mail.\n\n\n    Email email = servidor.obterProximoEmail(usuario);"
  },
  {
    "objectID": "cap3-2.html#section-21",
    "href": "cap3-2.html#section-21",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Já na linha abaixo, o método imprimir é chamado para o objeto email.\n\nE na primeira linha do método imprimirProximoEmail, vemos que email é uma variável local do tipo Email.\nPortanto, o objeto da classe cliente de e-mail está chamando o método imprimir do objeto e-mail.\n\n\n    email.imprimir();"
  },
  {
    "objectID": "cap3-2.html#section-22",
    "href": "cap3-2.html#section-22",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Veja que, ao usar o botão Avançar, estamos usando abstração.\n\nIsso porque estamos enxergando o método imprimir, por exemplo, como um único comando.\nE vimos que o efeito dele é imprimir os detalhes da mensagem no terminal.\n\n\nMas se estivermos interessados em mais detalhes, podemos aprofundar a análise.\n\nE ver a execução passo a passo do próprio método imprimir.\nPodemos fazer isso no BlueJ usando o botão Entrar em.\n\nCom essa opção, a execução entrará no método sendo chamado e parará na primeira linha dele."
  },
  {
    "objectID": "cap3-2.html#section-23",
    "href": "cap3-2.html#section-23",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Atividade em aula\n\n\nRefaça o cenário anterior, no qual Maria enviou uma mensagem para Tião e ele ainda não a leu.\nChame o método imprimirProximoEmail para o cliente de e-mail do Tião novamente.\nUse o botão Avançar até chegar na linha: email.imprimir().\nChegando nela, use o botão Entrar em em vez de Avançar.\nO que você observa? Explique o que vê?"
  },
  {
    "objectID": "cap3-2.html#section-24",
    "href": "cap3-2.html#section-24",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Nos exercícios anteriores vimos um objeto chamando método de outro objeto.\n\nNós podemos usar o depurador também para exarminarmos um objeto criando outro objeto."
  },
  {
    "objectID": "cap3-2.html#section-25",
    "href": "cap3-2.html#section-25",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício\n\n\nCrie um breakpoint na primeira linha do método enviarEmail da classe ClienteDeEmail e, em seguida, chame o método.\nUse o botão Entrar em para entrar no construtor do objeto e-mail.\nNa janela do depurador observe que os atributos e os parâmetros têm os mesmos nomes. Execute o programa passo a passo para ver os atributos sendo inicializados um a um.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nUse o depurador para investigar o método inserirDinheiro do projeto maquina-ingressos-melhor que vimos anteriormente.\nChame métodos de forma que consiga depurar a execução tanto do bloco if quanto do bloco else."
  },
  {
    "objectID": "cap3-2.html#section-26",
    "href": "cap3-2.html#section-26",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 1.1\n\n\nAdicione um assunto (string) nas mensagens de e-mail do projeto sistema-de-email.\nNão se esqueça de garantir que o assunto do e-mail seja exibido ao imprimir um e-mail. Modifique a classe ClienteDeEmail conforme necessário.\nTeste suas alterações!"
  },
  {
    "objectID": "cap3-2.html#section-27",
    "href": "cap3-2.html#section-27",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 1.2\n\n\nVamos agora simular o envio de arquivos anexados a um e-mail, aproveitando para reforçar o conceito de sobrecarga de métodos e construtores.\nPara isso, siga cuidadosamente as instruções abaixo:\n\nAdicione um atributo anexo, do tipo String, para as mensagens de e-mail.\n\nVamos simular que existe um arquivo anexo guardando apenas o nome do arquivo nesse atributo.\n\nCrie um construtor sobrecarregado na classe Email que receba o anexo (além, é claro, de todas as informações do construtor original).\nNo construtor original, inicialize o anexo com string vazia.\nCrie um método de acesso para o atributo anexo.\nAltere o método imprimir para que o anexo seja exibido.\nNa classe ClienteDeEmail, crie uma versão sobrecarregada do método enviarEmail que receba o anexo.\n\nTeste suas alterações!"
  },
  {
    "objectID": "cap3-2.html#section-28",
    "href": "cap3-2.html#section-28",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "No próximo exercício você precisará utilizar uma estrutura de repetição.\n\nÉ interessante então que saiba que, em Java, a sintaxe das estruturas de repetição for, while e do while é a mesma de C++."
  },
  {
    "objectID": "cap3-2.html#section-29",
    "href": "cap3-2.html#section-29",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 1.3\n\n\nNosso sistema de e-mails permite imprimir um e-mail por vez, mas seria interessante se pudéssemos ver todos os nossos e-mails de uma vez.\n\nCrie então um método imprimirTodosEmails na classe ClienteDeEmail que permita fazer isso.\n\nVocê precisará usar a palavra-chave null que é o valor de uma variável que não referencia nenhum objeto.\nUse alguma forma de separação entre um e-mail e outro.\n\nEx.: imprimindo a string \"---------\" entre os e-mails.\n\nAo final exiba quantos e-mails foram impressos.\n\nNão se esqueça de testar suas alterações!"
  },
  {
    "objectID": "cap3-2.html#section-30",
    "href": "cap3-2.html#section-30",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 1.4\n\n\nSuponha que você tenha muitos e-mails para receber mas está interessado em ler apenas os e-mails de um remetente específico.\n\nAltere o método imprimirTodosEmails acrescentando um parâmetro remetente.\n\nSe o valor do parâmetro for null ou string vazia, o método deve continuar imprimindo todos os e-mails como já fazia antes.\nCaso contrário, exiba apenas os e-mails do remetente recebido por parâmetro.\n\nVeja que você precisará chamar um método do objeto email que permita obter o remetente do e-mail e compará-lo ao parâmetro recebido.\n\nPara fazer a comparação, use o método equals da classe String, que permite comparar o conteúdo de duas strings.\n\nEx.: string1.equals(string2) retorna true se as duas strings forem iguais.\nAtenção: em Java não podemos comparar strings usando ==, pois nem sempre funciona como se esperaria.\n\n\n\nTerminou? Se não tiver testado, ainda não terminou ;)"
  },
  {
    "objectID": "cap3-2.html#section-31",
    "href": "cap3-2.html#section-31",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 1.5\n\n\nCrie um método imprimirTodosEmailsPorAssunto que permita imprimir apenas os e-mails com determinado assunto.\n\nA ideia é parecida com o que fizemos antes, para os remetentes, mas com as seguintes diferenças:\n\nO método deve aceitar apenas parte do assunto a ser considerado.\nO método deve ignorar maiúsculas/minúsculas.\nPor ex.: se chamarmos o método passando \"poo\" como parâmetro, os dois primeiros e-mails abaixo seriam exibidos, mas o terceiro não.\n\nAssunto do e-mail 1: \"Notas de Poo\"\nAssunto do e-mail 2: \"IPOO: videoaulas\"\nAssunto do e-mail 3: \"Rebobina Aí!\"\n\n\n\nPara fazer esse exercício, pesquise na internet sobre os métodos contains e toLowerCase da classe String.\nNão se esqueça de testar suas alterações!"
  },
  {
    "objectID": "cap3-2.html#section-32",
    "href": "cap3-2.html#section-32",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do projeto sistema-de-emails da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap3-2.html#section-33",
    "href": "cap3-2.html#section-33",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Exercício 2.1\n\n\nAltere a classe VisorDeRelogio do projeto visor-relogio para que o relógio exiba os segundos, além das horas e dos minutos.\nObs.: com essa alteração o método tiqueTaque deveria ser chamado a cada segundo, em vez de a cada minuto."
  },
  {
    "objectID": "cap3-2.html#section-34",
    "href": "cap3-2.html#section-34",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "(Opcional) Exercício 2.2 Desafio\n\n\n\nNo design atual do projeto visor-relogio, um objeto VisorDeRelogio é responsável por detectar quando um objeto VisorDeNumero voltou para zero e, em seguida, informar outro objeto VisorDeNumero para incrementar. Em outras palavras, não há ligação direta entre objetos VisorDeNumero.\nSeria possível que um objeto VisorDeNumero informasse outro que ele voltou para zero e que este, por sua vez, deveria ser incrementado?\nPor exemplo, seria possível que o objeto minutos informasse ao objeto horas que outra hora se passou ou fazer com que o objeto segundos informasse ao objeto minutos que outros sessenta segundos se passaram?\n\nO método tiqueTaque deveria interagir com quais objetos?\nO que o objeto horas deveria fazer quando um dia inteiro tivesse passado?\n\nExplique os problemas envolvidos neste design alternativo e, se você realmente sentir vontade de se desafiar, tente implementá-lo!"
  },
  {
    "objectID": "cap3-2.html#section-35",
    "href": "cap3-2.html#section-35",
    "title": "IPOO - Cap. 3 Interação entre Objetos",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa parte dos exercícios e envie o código do projeto visor-relogio da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap4-3.html#section",
    "href": "cap4-3.html#section",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Este material é baseado no livro-texto da disciplina:\n.\n\nDessa vez não vou colocar os lembretes antes de começar a aula.\n\nA essa altura você já sabe né? Não preciso repetir."
  },
  {
    "objectID": "cap4-3.html#section-1",
    "href": "cap4-3.html#section-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Na aula anterior nós aprendemos sobre o loop for-each que é usado para processar uma coleção inteira.\n\nMas há situações na quais queremos percorrer uma coleção, mas sem necessariamente precisar passar por todos os elementos dela.\nÉ o que chamamos de interação indefinida.\n\n\nSuponha, por exemplo, que queremos encontrar a primeira música que tenha uma determinada string.\n\nNesses casos, o loop for-each não é a melhor opção, pois ele é projetado para iterar por todos os elemento da coleção.\n\nMas, ao encontrarmos a primeira música, não precisaríamos percorrer o restante da coleção.\n\nNós podemos então utilizar outro tipo de loop, com o comando while."
  },
  {
    "objectID": "cap4-3.html#o-loop-while",
    "href": "cap4-3.html#o-loop-while",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop while",
    "text": "O loop while\nAntes de entrarmos no exemplo da busca da primeira música, vamos detalhar um pouco mais o comando while.\n\nA sintaxe do while em Java é igual à do C++ que vocês viram na disciplina IALG."
  },
  {
    "objectID": "cap4-3.html#o-loop-while-1",
    "href": "cap4-3.html#o-loop-while-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop while",
    "text": "O loop while\nComo exemplo, os trechos de código abaixo fazem a mesma coisa, mas um usando for-each e outro while.\n\n  public void listarTodosOsArquivos() {\n      for(String nomeDoArquivo : arquivos) {\n          System.out.println(nomeDoArquivo);  \n      }\n  }\n\n\n\n  public void listarTodosOsArquivos() {\n      int indice = 0;\n      while (indice &lt; arquivos.size()) {\n          String nomeDoArquivo = arquivos.get(indice);\n          System.out.println(nomeDoArquivo);\n          indice++;\n      }\n  }"
  },
  {
    "objectID": "cap4-3.html#o-loop-while-2",
    "href": "cap4-3.html#o-loop-while-2",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop while",
    "text": "O loop while\nRepare que, neste caso, como estamos processando a coleção inteira, a opção com for-each é melhor:\n\nPrimeiro porque o código é mais simples de implementar.\nSegundo porque não corremos o risco de cometer algum erro e provocar um loop infinito.\nAlém disso, o código do for-each é o mesmo para diversas coleções diferentes.\n\nHá coleções nas quais o acesso não é por índice ou não é com um método chamado get, por exemplo."
  },
  {
    "objectID": "cap4-3.html#o-loop-while-3",
    "href": "cap4-3.html#o-loop-while-3",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop while",
    "text": "O loop while\nAssim, você pode estar se perguntando, mas então para que usar o comando while?\n\nPrimeiro, porque podemos usar while para outras situações, que não sejam percorrer uma coleção.\nE, no caso de coleções, porque podemos precisar parar as iterações antes de processar a coleção inteira.\nPor fim, pode ser que precisemos do índice do elemento na coleção."
  },
  {
    "objectID": "cap4-3.html#o-loop-while-4",
    "href": "cap4-3.html#o-loop-while-4",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop while",
    "text": "O loop while\nO código abaixo, por exemplo, exibe o índice das músicas\n\no que pode ajudar na hora de chamar os métodos de tocar ou remover uma música.\n\n\npublic void listarTodosOsArquivos() {\n    int indice = 0;\n    while (indice &lt; arquivos.size()) {\n        String nomeDoArquivo = arquivos.get(indice);\n        // inclui o índice da música na impressão\n        System.out.println(indice + \": \" + nomeDoArquivo); \n        indice++;\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#exemplo-de-busca-com-while",
    "href": "cap4-3.html#exemplo-de-busca-com-while",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Exemplo de busca com while",
    "text": "Exemplo de busca com while\nNa aula passada, vimos o método buscarMusicas que listava os nomes de todas as músicas que tinham uma string de busca.\n\nMas suponha que queiramos um método para encontrar a primeira música que tenha a string.\nEste é um exemplo de situação na qual podemos interromper a interação sem precisar processar a coleção inteira.\n\nObs.: apesar de existir uma forma de parar a iteração de um for-each ela é considerada um estilo ruim de programação."
  },
  {
    "objectID": "cap4-3.html#exemplo-de-busca-com-while-1",
    "href": "cap4-3.html#exemplo-de-busca-com-while-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Exemplo de busca com while",
    "text": "Exemplo de busca com while\n/**\n * Busca o índice da primeira música que bate com a string passada.\n * @param stringDeBusca A string a ser procurada.\n * @return O índice da primeira ocorrência, ou -1 se nenhuma música tem a string passada.\n */\npublic int buscarPrimeiraMusica(String stringDeBusca)\n{\n    int indice = 0;\n    // Indica se a primeira música foi encontrada\n    boolean encontrou = false;\n    // A busca continua enquanto a coleção não terminar e nenhuma música foi encontrada\n    while (indice &lt; arquivos.size() && !encontrou) {\n        String nomeDoArquivo = arquivos.get(indice);\n        if (nomeDoArquivo.contains(stringDeBusca)) {\n            // Uma música foi encontrada, podemos parar a busca\n            encontrou = true;\n        }\n        else {\n            // Não encontramos a música ainda, podemos continuar a busca\n            indice++;\n        }\n    }\n    if (encontrou) {\n        // Retorna a posição onde a música foi encontrada\n        return indice;\n    }\n    else {\n        // Não encontramos nenhuma música\n        return -1;\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#section-2",
    "href": "cap4-3.html#section-2",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Como vimos no final da aula passada, usar String para representar as músicas não é o ideal.\n\nQualquer tocador de música comercial permite, por exemplo, buscar por título, artista, álbum, gênero, etc.\n\nAlém de ter informações adicionais como a duração da música, por ex..\n\n\n\nUm dos poderes da Orientação a Objetos é justamente permitir que entidades do mundo real possam ser representadas como objetos em nossos programas.\n\nComo já sabemos como criar classes, com construtores, atributos e métodos, podemos criar uma classe Musica que represente as músicas."
  },
  {
    "objectID": "cap4-3.html#section-3",
    "href": "cap4-3.html#section-3",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Mas repare que, se quisermos ter todos os atributos mencionados para cada música (artista, título, gênero, álbum, etc.),\n\nprecisaríamos pedir ao usuário para fornecer todas essas informações.\n\n\nPara evitar esse trabalho, vamos ilustrar essa questão com um exemplo bem simples.\n\nVamos aproveitar o fato de que os arquivos de música fornecidos têm o nome do artista e da música no nome,\n\ne usar uma classe auxiliar, chamada LeitorDeMusica,\nque vai procurar todas as músicas .mp3 que estão em uma pasta, e usar os nomes dos arquivos para criar objetos da classe Musica."
  },
  {
    "objectID": "cap4-3.html#section-4",
    "href": "cap4-3.html#section-4",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "O projeto organizador-musicas-v5 tem a implementação proposta, com a classe Musica.\n\nObs.: não vamos avaliar a classe LeitorDeMusica pois ela usa conceitos que ainda não vimos.\n\n\nLeia o código da classe OrganizadorDeMusica.\n\nQuais são as principais alterações?"
  },
  {
    "objectID": "cap4-3.html#section-5",
    "href": "cap4-3.html#section-5",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Você deve ter notado que as principais alterações são:\n\nA classe OrganizadorDeMusicas tem agora um ArrayList de Musicas em vez de um ArrayList de Strings.\n\nIsso afeta diversos métodos que tínhamos implementado.\n\nNo método listarTodasAsMusicas, pedimos ao objeto Musica que retorna uma String contendo seus detalhes.\n\nIsso indica que estamos deixando a classe Musica responsável por fornecer os detalhes a serem exibidos, como o título e o artista.\nEste é um exemplo de design baseado em responsabilidade que veremos em mais detalhes no Cap. 7.\n\nNo método tocarMusica, precisamos agora obter o nome do arquivo do objeto Musica para passá-lo para o tocador.\nForam adicionados também códigos para buscar todas as músicas que estão na pasta principal do projeto."
  },
  {
    "objectID": "cap4-3.html#section-6",
    "href": "cap4-3.html#section-6",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que ao utilizarmos a classe Musica alguns métodos ficaram um pouco mais complicados.\n\nMas a estrutura do programa é agora muito melhor.\nA classe Musica é mais bem estruturada que uma simples String\n\ne ainda nos permite guardar informações mais interessantes, como, por exemplo, uma imagem do artista ou do álbum de música, por exemplo.\n\n\n\nAlém disso, agora conseguimos evitar o problema mencionado no final da aula anterior,\n\nDe querermos buscar todas as músicas que tenham a palavra renda no título, mas isso acabar retornando músicas de uma cantora chamada Brenda."
  },
  {
    "objectID": "cap4-3.html#section-7",
    "href": "cap4-3.html#section-7",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "No método abaixo resolvemos essa questão usando o fato de que a classe Musica tem a informação do título separada do nome do arquivo.\n\n/**\n * Lista todas as músicas que tenham uma string passada em seu título\n * @param stringDeBusca A string a ser procurada.\n */\npublic void buscarNoTitulo(String stringDeBusca)\n{\n    for (Musica musica : musicas) {\n        String titulo = musica.obterTitulo();\n        if (titulo.contains(stringDeBusca)) {\n            System.out.println(musica.obterDetalhes());\n        }\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#section-8",
    "href": "cap4-3.html#section-8",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nAdicione um atributo numeroDeExecucoes à classe Musica. Implemente métodos para reiniciar a contagem (voltando para zero) e para incrementá-la em um. Altere também o método obterDetalhes para que inclua essa informação.\nEm seguida, altere a classe OrganizadorDeMusicas de forma que toda vez que uma música for tocada, seja contabilizada mais uma execução dela.\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nVocê deve ter notado que se você tocar duas músicas sem parar a primeira, elas ficam tocando simultaneamente. E, claro, isso não é muito útil. Implemente as alterações necessárias para que uma música pare de tocar automaticamente quando uma outra música começa a tocar."
  },
  {
    "objectID": "cap4-3.html#section-9",
    "href": "cap4-3.html#section-9",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Existe uma terceira forma de iterar sobre uma coleção que é uma espécie de um meio-termo entre for-each e while.\n\nEla usa um loop while, mas com um objeto iterador em vez de uma variável inteira índice para guardar a posição na lista.\nA seguir usaremos Iterator, uma classe, e iterator um método. Repare a diferença pela letra i maiúscula e minúscula, respectivamente.\n\n\nA classe ArrayList tem um método iterator que retorna um objeto Iterator.\n\nPara usar a classe, precisamos importá-la do pacote java.util.\n\n\n\n\nimport java.util.ArrayList;\nimport java.util.Iterator;"
  },
  {
    "objectID": "cap4-3.html#section-10",
    "href": "cap4-3.html#section-10",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Um iterador tem apenas quatro métodos, e usamos dois deles para iterar sobre uma coleção.\n\nO método hasNext (temProximo) indica se há mais elementos na coleção.\nE o método next (proximo) retorna o próximo elemento.\n\n\nO pseudocódigo abaixo mostra como geralmente utilizamos iteradores para percorrer uma coleção\n\n  // Obtemos o iterador da coleção\n  // - Como Iterator é uma classe genérica, precisamos informar um segundo tipo \n  //   (que é o tipo dos elementos da coleção)\n  Iterator&lt;TipoDoElemento&gt; it = minhaColecao.iterator();\n  // Enquanto há elementos a processar\n  while (it.hasNext()) {      \n      // Chamamos it.next() para obter o próximo elemento\n      // Fazemos alguma coisa com o elemento\n  }"
  },
  {
    "objectID": "cap4-3.html#section-11",
    "href": "cap4-3.html#section-11",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Podemos fazer então uma terceira versão do método que lista todas as músicas, agora usando um Iterator.\n\n\n  public void listarTodasAsMusicas() {\n      Iterator&lt;Musica&gt; it = musicas.iterator();\n      while (it.hasNext()) {\n          Musica musica = it.next();\n          System.out.println(musica.obterDetalhes());\n      }\n  }\n\n\n\nQuais são as diferenças para as versões anteriores do método listarTodosOsArquivos?\n\nNós usamos um loop while, mas não precisamos nos preocupar com uma variável de índice.\nRepare que o principal ponto a entender é que o método next, além de retornar o próximo elemento, passa o iterador para frente.\nPortanto, chamadas sucessivas do método next retornam sempre elementos diferentes.\n\nMas cuidado, se terminarem os elementos, e o método next for chamado sem antes verificar se hasNext retorna true, ocorrerá um erro no programa."
  },
  {
    "objectID": "cap4-3.html#section-12",
    "href": "cap4-3.html#section-12",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Conceito\n\n\nUm iterador é um objeto que permite iterar sobre todos os elementos de uma coleção.\n\n\n\n\n\n\n\n\nRealmente, o que fizemos até agora não traz vantagens. Mas há duas situações nas quais um Iterator é muito útil:\n\nPara coleções cujo acesso por posição não é possível, ou muito lento.\nPara a remoção de elementos de uma coleção"
  },
  {
    "objectID": "cap4-3.html#acesso-por-índice-vs.-iteradores",
    "href": "cap4-3.html#acesso-por-índice-vs.-iteradores",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Acesso por índice vs. iteradores",
    "text": "Acesso por índice vs. iteradores\nQuando estamos usando um ArrayList, não faz nenhuma diferença utilizar while acessando por índice ou com iteradores.\n\nMas nem toda coleção funciona assim.\nVeremos coleções mais adiante que não permitem acesso por posição.\n\nOu esse acesso seria muito lento.\nE, portanto, seria inviável utilizar while acessando por índice.\n\n\n\nA solução de utilizar while com um Iterator funciona para todas as coleções da biblioteca de classes do Java.\n\nE, portanto, é um padrão de código que usaremos novamente mais adiante."
  },
  {
    "objectID": "cap4-3.html#section-13",
    "href": "cap4-3.html#section-13",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Remover elementos traz consequências importantes quando estamos iterando uma coleção.\n\nSuponha, por exemplo, que não estamos mais interessados em um artista e queremos remover todas as suas músicas.\nPode parecer bem simples implementar um método para isso, seguindo pseudocódigo abaixo.\npara cada música na colecao {\n    se musica.obterArtista() é o artista que não queremos mais {\n        colecao.remove(musica);\n    }\n}\n\n\nApesar dessa forma parecer perfeitamente razoável, não é possível remover elementos usando um loop for-each.\n\nSe você tentar fazer isso, ocorrerá um erro no programa (ConcurrentModificationException).\nIsso ocorre porque a remoção causa uma confusão sobre qual seria o próximo elemento nesta situação."
  },
  {
    "objectID": "cap4-3.html#section-14",
    "href": "cap4-3.html#section-14",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "A solução para usar isso é usar um Iterator para remover elementos de uma coleção.\n\nAlém dos métodos hasNext e next, a classe tem um método remove.\nO método remove o elemento que foi retornado pela última chamada do método next.\n\n\nO trecho de código abaixo mostra como remover as músicas de um artista da coleção de músicas.\n\nRepare que chamamos o método remove do iterador e não do ArrayList.\n\n\n  Iterator&lt;Musica&gt; it = musicas.iterator();\n  while (it.hasNext()) {\n      Musica musica = it.next();\n      String artista = musica.obterArtista();\n      if (artista.equals(artistaARemover)) {\n          it.remove();\n      }\n  }"
  },
  {
    "objectID": "cap4-3.html#section-15",
    "href": "cap4-3.html#section-15",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Há outras formas de remover elementos de uma coleção.\n\nPor ex.: fazer um loop para encontrar a posição de um elemento.\nE depois do loop remover o elemento daquela posição.\n\n\nMas veja que há desvantagens:\n\nComo já mencionamos, nem toda coleção permite acessar elementos por posição, ou esse acesso é lento.\nAlém disso, com iterador podemos fazer a remoção já dentro do loop, sem precisar fazer uma operação separada.\n\n\n\nPortanto, é uma boa ideia saber como remover elementos de uma coleção usando um objeto Iterator. :)"
  },
  {
    "objectID": "cap4-3.html#section-16",
    "href": "cap4-3.html#section-16",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nImplemente um método na classe OrganizadorDeMusicas que receba uma string por parâmetro e remova todas as músicas cujos títulos tenham aquela string."
  },
  {
    "objectID": "cap4-3.html#section-17",
    "href": "cap4-3.html#section-17",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Apesar de coleções de tamanho flexível serem úteis na maioria dos casos,\n\nHá situações nas quais sabemos quantos elementos uma coleção terá durante todo o tempo de execução de um programa.\nNesses casos, é melhor utilizar uma coleção de tamanho fixo: um vetor (ou array).\n\n\nMas qual a vantagem de usarmos vetores?\n\nÉ que o acesso por índice (posição) é geralmente mais eficiente do que em uma coleção de tamanho flexível, como a ArrayList.\nOutra vantagem é que, em Java, podemos ter vetores de elementos que são tipos primitivos.\n\nEnquanto ArrayList, por exemplo, permite guardar apenas objetos.\nApesar de que, como veremos no próximo capítulo, há uma forma de lidarmos comn isso usando wrappers (classes empacotadoras)."
  },
  {
    "objectID": "cap4-3.html#section-18",
    "href": "cap4-3.html#section-18",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Um vetor é um grupo de variáveis que contém elementos de um mesmo tipo.\n\nEm Java, vetores são considerados objetos, portanto, são considerados tipos por referência.\nComo já mencionado, os elementos de um vetor podem ser de tipos primitivos (int, double, boolean, etc.) ou de tipos por referência (objetos).\n\n\nExemplo de um vetor:"
  },
  {
    "objectID": "cap4-3.html#section-19",
    "href": "cap4-3.html#section-19",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Podemos declarar um vetor em Java, utilizando uma das seguintes formas:\n\nTipoDosElementos[] nomeDoVetor;\nTipoDosElementos nomeDoVetor[];\n\n\nExemplos:\n\ndouble[] notas;\nint meuVetorDeInteiros[];"
  },
  {
    "objectID": "cap4-3.html#section-20",
    "href": "cap4-3.html#section-20",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Como os demais objetos, os vetores são criados por meio da palavra-chave new:\n\nnomeDoVetor = new TipoDosElementos[capacidade];\n\n\nExemplos:\n\ndouble[] notas;\nnotas = new double[3];\n\nint meuVetorDeInteiros[];\nmeuVetorDeInteiros = new int[10];"
  },
  {
    "objectID": "cap4-3.html#section-21",
    "href": "cap4-3.html#section-21",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Há ainda outras duas formas alternativas de se instanciar um vetor.\n\n\n// Declara e instancia em uma única linha\nint meuVetorDeInteiros[] = new int[10];\n\n// Declara, instancia um vetor com 3 posições e já inicializa os seus valores\ndouble notas[] = {7.5, 8.0, 9.0};\n\n\n\nEm C++ um vetor criado, mas não inicializado, pode conter lixo de memória.\n\nMas em Java, vale a regra de inicialização igual a dos atributos.\n\nVetor de tipos numéricos tem todos os elementos inicializados com zero.\nVetor de booleanos tem todos os elementos inicializados com false.\nVetor de objetos tem todos os elementos inicializados com null."
  },
  {
    "objectID": "cap4-3.html#o-loop-for",
    "href": "cap4-3.html#o-loop-for",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop for",
    "text": "O loop for\nGeralmente utilizamos um loop for para percorrer os elementos de um vetor.\n\nA sintaxe do loop for em Java é igual à do C++.\nUsamos o atributo length, que é constante e público, e retorna o tamanho do vetor.\n\n\n\nfor(int i = 0; i &lt; vetor.length; i++) {\n    // Usando vetor[i], estamos acessando a posição i do vetor.\n    vetor[i] = i;\n}"
  },
  {
    "objectID": "cap4-3.html#o-loop-for-1",
    "href": "cap4-3.html#o-loop-for-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "O loop for",
    "text": "O loop for\nComo podemos então exibir todos os elementos de um vetor de inteiros chamado vet?\n\n\nfor(int i = 0; i &lt; vet.length; i++) {\n    System.out.println(vet[i]);\n}"
  },
  {
    "objectID": "cap4-3.html#usando-vetores-em-métodos",
    "href": "cap4-3.html#usando-vetores-em-métodos",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Usando vetores em métodos",
    "text": "Usando vetores em métodos\nPodemos passar vetores como parâmetro de métodos.\n\nA passagem é por referência, ou seja, estamos passando o ponteiro para o vetor.\nPortanto, se o método alterar o vetor, ele estará alterando o vetor original passado por parâmetro\n\n\n\npublic void preencherVetor(int vet[]) {\n    for (int i = 0; i &lt; vet.length; i++) {\n        vet[i] = i;\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#usando-vetores-em-métodos-1",
    "href": "cap4-3.html#usando-vetores-em-métodos-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Usando vetores em métodos",
    "text": "Usando vetores em métodos\nPodemos também criar métodos que retornam vetores.\n\n\npublic int[] criarVetor() {\n    int v[] = new int[10];\n    return v;\n}"
  },
  {
    "objectID": "cap4-3.html#vetores-de-objetos",
    "href": "cap4-3.html#vetores-de-objetos",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Vetores de objetos",
    "text": "Vetores de objetos\nNós podemos também criar vetores para guardar objetos.\n\nSuponha, por exemplo, que queiramos poder criar e trabalhar com vários objetos de uma classe Carro.\n\n\n\n// Estamos declarando um vetor de carros, com capacidade de\n// guardar 10 objetos Carro\nCarro[] carros = new Carro[10];\n\n// Em cada posição do vetor, podemos colocar um objeto do tipo Carro.\ncarros[0] = new Carro(\"Gol\");\ncarros[1] = new Carro(\"Onix\");"
  },
  {
    "objectID": "cap4-3.html#vetores-de-objetos-1",
    "href": "cap4-3.html#vetores-de-objetos-1",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Vetores de objetos",
    "text": "Vetores de objetos\nNós podemos então acessar cada objeto Carro no vetor, a partir de sua posição.\n\n\nfor(int i = 0; i &lt; carros.length; i++) {\n    if (carros[i] != null) {\n        // Estamos exibindo nome do carro chamando o método obterNome\n        System.out.println(carros[i].obterNome());\n    }\n}\n\n\n\nRepare que a condição (if) da linha 2 é muito importante:\n\npois caso alguma posição do vetor não tenha sido inicializada, seu valor é null.\nE poderia então ocorrer um erro (NullPointerException) ao tentar chamar o método obterNome."
  },
  {
    "objectID": "cap4-3.html#usando-for-each-com-vetores",
    "href": "cap4-3.html#usando-for-each-com-vetores",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Usando for-each com vetores",
    "text": "Usando for-each com vetores\nNós também podemos usar um loop for-each para percorrer os elementos de um vetor.\n\n\nfor(Carro carro : carros) {\n    if (carro != null) {\n        // Estamos exibindo nome do carro chamando o método obterNome\n        System.out.println(carro.obterNome());\n    }\n}\n\n\n\nEste exemplo nos permite enfatizar uma das vantagens do loop for-each:\n\nRepare que esse código seria exatamente igual se a variável carros fosse um ArrayList em vez de um vetor.\nJá na opção anterior, usando loop for tradicional, os códigos seriam diferentes.\n\nPrimeiro porque consultamos o tamanho de um vetor usando o atributo length e de um ArrayList usando o método size.\nE segundo que acessamos um elemento por posição em um vetor usando [i] e em um ArrayList usando get(i)."
  },
  {
    "objectID": "cap4-3.html#vetores-vs.-arraylist",
    "href": "cap4-3.html#vetores-vs.-arraylist",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "Vetores vs. ArrayList",
    "text": "Vetores vs. ArrayList\nAgora que conhecemos tanto vetores quanto ArrayList, qual deles devemos utilizar?\n\nÉ melhor usar ArrayList se o número de elementos pode ser alterado durante a execução do programa.\n\nOu se você não sabe, antes de criar a coleção, quantos elementos serão usados.\n\nSeria melhor usar um vetor quando o número de elementos é pré-determinado.\n\nE a eficiência de acesso por posição é muito importante.\n\n\n\nNa prática acabamos usando ArrayList em muitas situações mesmo quando temos uma quantidade fixa de elementos.\n\nMas, de toda forma, precisamos saber utilizar vetores pois é comum precisarmos usar métodos de classes da biblioteca do Java (ou de terceiros) que trabalham com vetores."
  },
  {
    "objectID": "cap4-3.html#section-22",
    "href": "cap4-3.html#section-22",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para ilustrar o uso de vetores, vamos aproveitar para conhecer um recurso que pode ser interessante no trabalho da disciplina.\n\nEm jogos com gráficos 2D, podemos criar animações dos personagens usando sprites.\nSprites nada mais são que imagens que, quando exibidas seguidamente, dão a ilusão de movimento.\n\n\nVamos criar um projeto no Greenfoot para vermos isso na prática.\n\nE, portanto, você precisa ter o Greenfoot instalado para conseguir fazer os exercícios da aula."
  },
  {
    "objectID": "cap4-3.html#section-23",
    "href": "cap4-3.html#section-23",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Vamos criar uma classe MeuMundo e nela definir um mundo de 800x600 pixels com fundo preto.\n\npublic class MeuMundo extends World\n{\n    public MeuMundo()\n    {    \n        // Cria um novo mundo com 800x600 células,\n        // com células de tamanho 1x1 pixels.\n        super(800, 600, 1); \n        // Cria uma imagem do tamanho do mundo\n        GreenfootImage imagemFundoPreto = new GreenfootImage(800, 600);\n        // Desenha um retângulo preto em toda a imagem\n        imagemFundoPreto.setColor(Color.BLACK);\n        imagemFundoPreto.fillRect(0, 0, 800, 600);\n        // Define a imagem com o plano de fundo do mundo\n        setBackground(imagemFundoPreto);\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#section-24",
    "href": "cap4-3.html#section-24",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nCrie o projeto no Greenfoot e use o código do slide anterior para definir o mundo (altere a classe inicial MyWorld).\nCrie então um objeto da classe MeuMundo, clicando na caixa da classe e acessando a opção new MeuMundo(). Você verá que o jogo exibirá uma tela preta."
  },
  {
    "objectID": "cap4-3.html#section-25",
    "href": "cap4-3.html#section-25",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Vamos agora criar uma classe Cavaleiro.\n\nPara ficar claro o conceito das animações, vamos começar com uma imagem estática.\n\n\nAs imagens que vamos utilizar foram baixadas do site:\n\nhttps://www.gameart2d.com/the-knight-free-sprites.html\n\n\n\n\n\n\n\nExercício (entrega)\n\n\nBaixe as imagens do site citado, encontre a imagem Idle (1).png e copie-a para a pasta images do projeto do Greenfoot. Renomeie a imagem para knight.png."
  },
  {
    "objectID": "cap4-3.html#section-26",
    "href": "cap4-3.html#section-26",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "O código abaixo utiliza a imagem que copiamos como a imagem do cavaleiro.\n\npublic class Cavaleiro extends Actor\n{\n    public Cavaleiro()\n    {\n        // cria a imagem do cavaleiro\n        GreenfootImage imagem = new GreenfootImage(\"knight.png\");\n        // como a imagem é muito grande, vamos redimensioná-la para 120x140 pixels\n        imagem.scale(120,140);\n        // usamos a imagem como a imagem do cavaleiro\n        setImage(imagem);\n    }\n    \n    public void act() \n    { \n        // não faz nada, por enquanto\n    }\n}"
  },
  {
    "objectID": "cap4-3.html#section-27",
    "href": "cap4-3.html#section-27",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nCrie uma classe Cavaleiro no seu projeto. Para isso, clique em Actor e acesse a opção Nova subclasse.... Use o nome Cavaleiro na janela que aparece e clique em OK.\nEm seguida, implemente o construtor da classe conforme apresentado no slide anterior.\nPara testar, crie um objeto da classe Cavaleiro e o coloque no mundo."
  },
  {
    "objectID": "cap4-3.html#section-28",
    "href": "cap4-3.html#section-28",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Vamos agora adicionar código para que o cavaleiro possa caminhar na horizontal.\n\nPara isso, vamos alterar o método act do Cavaleiro.\nO método, basicamente, aumenta ou diminui o valor da posição do cavaleiro no eixo X (horizontal),\n\ndependendo da tecla que está sendo pressionada (seta para a esquerda ou para a direita).\n\n\n\n\n    public void act()\n    {\n        // se a tecla seta para a ESQUERDA estiver pressionada\n        if (Greenfoot.isKeyDown(\"left\")) {\n            // posição do cavaleiro DIMINUI 4 no eixo X e se mantém no eixo Y\n            setLocation(getX()-4, getY());            \n        }\n        // se a tecla seta para a DIREITA estiver pressionada\n        if (Greenfoot.isKeyDown(\"right\")) {\n            // posição do cavaleiro AUMENTA 4 no eixo X e se mantém no eixo Y\n            setLocation(getX()+4, getY());            \n        }\n    }"
  },
  {
    "objectID": "cap4-3.html#section-29",
    "href": "cap4-3.html#section-29",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nAltere o método act da classe Cavaleiro de acordo com o slide anterior.\nCrie um objeto da classe, coloque-o no mundo e então clique no botão Executar.\nExperimente movimentar o cavaleiro usando as setas para a direita e para a esquerda.\nO que achou do movimento?"
  },
  {
    "objectID": "cap4-3.html#section-30",
    "href": "cap4-3.html#section-30",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que o movimento funciona, mas não é muito realista.\n\nParece que o cavaleiro está deslizando no chão sem mexer o corpo.\n\n\nMas você deve ter notado, nos arquivos que baixou, que há várias imagens do cavaleiro.\n\nAs imagens têm um nome seguido de um número.\nCada nome indica uma ação do personagem.\n\nEx.: idle (parado), walk (caminhando), run (correndo), etc.\n\nE o número é a sequência de imagens que fazem acontecer a animação.\n\nPor ex.: se exibirmos repetidamente, e em sequência, todas as imagens que começam com walk:\nteremos uma ilusão de movimento do personagem."
  },
  {
    "objectID": "cap4-3.html#section-31",
    "href": "cap4-3.html#section-31",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para fazer isso, vamos primeiro copiar todas as imagens que baixamos do cavaleiro para a pasta images do projeto no Greenfoot.\n\nVamos começar tratando a imagem do cavaleiro parado (idle).\nRepare que as imagens se chamam: Idle (1).png, Idle (2).png, …, até Idle (10).png.\n\n\nPara usar essas imagens, vamos declarar um vetor de imagens como atributo da classe Cavaleiro.\n\nE, no construtor da classe, vamos carregar as 10 imagens e guardá-las no vetor."
  },
  {
    "objectID": "cap4-3.html#section-32",
    "href": "cap4-3.html#section-32",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "public class Cavaleiro extends Actor\n{\n    // declaramos um vetor de imagens\n    private GreenfootImage[] imagens;\n    public Cavaleiro() {\n        // criamos o vetor com 10 posições, pois temos 10 imagens\n        imagens = new GreenfootImage[10];\n        // usamos um loop for que rodará 10 vezes\n        for (int i = 0; i &lt; imagens.length; i++) {\n            // em cada iteração, carregamos uma imagem usando o\n            // valor i+1 para montar o nome da imagem.\n            // e a guardamos na posição i do vetor.\n            imagens[i] = new GreenfootImage(\"Idle (\" + (i+1) + \").png\");\n            // redimensionamos a imagem porque ela é muito grande.\n            imagens[i].scale(120,140);\n        }\n        // definimos a primeira imagem como a imagem inicial do cavaleiro\n        setImage(imagens[0]);\n    }\n    // restante da classe omitido\n}"
  },
  {
    "objectID": "cap4-3.html#section-33",
    "href": "cap4-3.html#section-33",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "A alteração no slide anterior apenas carregou as imagens para a memória, mas ainda não faz nenhuma animação.\n\nPara criar a animação, precisamos que seja exibida uma das imagens de cada vez.\nPodemos então usar o método act que é chamado várias vezes por segundo na execução do jogo.\n\nA princípio, parece que basta mudarmos para a imagem seguinte a cada chamada.\nE quando chegarmos na última imagem, voltamos para a primeira.\n\n\n\nRepare que para que consigamos mudar para a próxima imagem, precisaremos de um atributo que indique qual é a imagem atual.\n\nVamos então criar um atributo inteiro indiceImagemAtual, e inicializá-lo com 0 no construtor.\nFeito isso, podemos utilizá-lo no método act, como mostrado no slide a seguir."
  },
  {
    "objectID": "cap4-3.html#section-34",
    "href": "cap4-3.html#section-34",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Toda vez que o método act é chamado, a próxima imagem do vetor é exibida.\n\n    public void act()\n    {        \n        // início do método que trata eventos de teclado omitido\n        \n        // incrementamos o índice da imagem atual para que\n        // possamos usar a próxima imagem.\n        indiceImagemAtual++;\n        // mas se o índice chegou ao final do vetor, voltamos para a primeira posição\n        if (indiceImagemAtual &gt;= imagens.length) {\n            indiceImagemAtual = 0;\n        }\n        // usamos então a próxima imagem, como imagem do cavaleiro\n        setImage(imagens[indiceImagemAtual]);\n    }"
  },
  {
    "objectID": "cap4-3.html#section-35",
    "href": "cap4-3.html#section-35",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nImplemente as últimas alterações apresentadas da classe Cavaleiro: a criação do atributo indiceImagemAtual e alterações no construtor e no método act.\nAgora crie um objeto Cavaleiro e execute o jogo.\nO que achou da animação?"
  },
  {
    "objectID": "cap4-3.html#section-36",
    "href": "cap4-3.html#section-36",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Veja que a animação ficou muito acelerada.\n\nIsso porque a quantidade de vezes por segundo que o método act está sendo chamado é muito alta para as imagens que estamos usando.\n\n\nComo podemos resolver?\n\nPodemos fazer com que cada imagem seja usada por mais de uma execução do método act.\n\nOu dizendo, de outra forma, podemos fazer a atualização a cada X vezes que o método é chamado.\nEm vez de atualizar em toda chamada.\n\n\n\n\nE como podemos fazer isso?"
  },
  {
    "objectID": "cap4-3.html#section-37",
    "href": "cap4-3.html#section-37",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que podemos definir de quantos em quantos passos precisamos atualizar as imagens.\n\nE usarmos essa informação para saber se é hora de atualizar a imagem ou não.\n\nMas, para usá-lo, precisamos contar quantos passos foram dados desde a última atualização.\n\n\n\nVamos então definir esses dois atributos na classe Cavaleiro.\n\n\n\n    private int passosParaAtualizarImagem;\n    private int passosDesdeUltimaAtualizacaoImagem;\n\n\n\nE inicializá-los no construtor da classe.\n\nInicializamos passosDesdeUltimaAtualizacaoImagem com zero.\nMas qual valor devemos usar para passosDesdeUltimaAtualizacaoImagem?\n\nAqui vai um processo de tentativa e erro.\nVamos experimentando até achar um valor que a animação pareça razoável."
  },
  {
    "objectID": "cap4-3.html#section-38",
    "href": "cap4-3.html#section-38",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Por fim, vamos alterar o método act para usar os atributos que criamos\n\n\n    public void act()\n    {        \n        // início do método que trata eventos de teclado omitido\n\n        // contamos mais um passo desde a última atualização da imagem\n        passosDesdeUltimaAtualizacaoImagem++;\n        \n        // se já se passaram os passos necessários para atualizar a imagem\n        if (passosDesdeUltimaAtualizacaoImagem &gt;= passosParaAtualizarImagem) {\n            // a imagem será atualizada, então voltamos o valor da variável para zero\n            passosDesdeUltimaAtualizacaoImagem = 0;\n            \n            // e atualizamos a imagem (é o código que já tínhamos feito antes)\n            indiceImagemAtual++;\n            if (indiceImagemAtual &gt;= imagens.length) {\n                indiceImagemAtual = 0;\n            }\n            setImage(imagens[indiceImagemAtual]);\n        }\n    }"
  },
  {
    "objectID": "cap4-3.html#section-39",
    "href": "cap4-3.html#section-39",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício (entrega)\n\n\nImplemente as últimas alterações para uso dos atributos passosParaAtualizarImagem e passosDesdeUltimaAtualizacaoImagem na classe Cavaleiro.\nExecute o jogo e veja o resultado. Altere o valor do atributo passosParaAtualizarImagem até encontrar um valor interessante. Qual valor achou melhor?"
  },
  {
    "objectID": "cap4-3.html#section-40",
    "href": "cap4-3.html#section-40",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Repare que usamos um vetor para guardar as imagens porque sabemos que usaremos 10 imagens e isso não vai mudar durante a execução do jogo.\n\nEsse, portanto, é um exemplo prático da utilidade de vetores em Java."
  },
  {
    "objectID": "cap4-3.html#section-41",
    "href": "cap4-3.html#section-41",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Mas, pensando no jogo, repare que fizemos todo esse trabalho só para tratar o movimento de corpo do personagem parado.\n\nJá que quando ele se movimenta, ele continua deslizando pela tela.\nComo podemos tratar isso?\n\n\nVeja que, nas imagens que baixamos, há imagens para a ação de caminhar (walk).\n\nBasta, portanto, seguirmos a mesma ideia:\n\nCriarmos um novo vetor de imagens.\nFazermos com o que a imagem seja alterada a cada X passos (usando passosParaAtualizarImagem).\n\n\n\n\nMas há um “detalhe” importante:\n\nPrecisamos agora saber quando o cavaleiro está parado e quando está se movimentando.\nPara saber qual vetor de imagens usarmos."
  },
  {
    "objectID": "cap4-3.html#section-42",
    "href": "cap4-3.html#section-42",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício - DESAFIO\n\n\nAltere a classe Cavaleiro de forma que ela use as imagens com prefixo Walk, quando o cavaleiro estiver se movimentando.\nVocê precisará criar outro atributo vetor de imagens e carregar nele as imagens.\nAlém disso, precisará de um atributo para indicar a ação atual do cavaleiro (se ele está parado ou caminhando). O atributo deve ser atualizado ao tratar os eventos do teclado, e deve ser usado para saber qual vetor de imagens utilizar.\nPor enquanto, não se preocupe com a movimentação para a esquerda."
  },
  {
    "objectID": "cap4-3.html#section-43",
    "href": "cap4-3.html#section-43",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Exercício - DESAFIO\n\n\nA ideia agora é tratar a movimentação para a esquerda.\nRepare que, nesse caso, o ideal seria mostrar o cavaleiro olhando para a esquerda. Uma forma de fazer isso é invertermos a imagem horizontalmente. A classe GreenfootImage tem um método chamado mirrorHorizontally que faz exatamente isso.\nPara tratar a movimentação para a esquerda, precisaremos ter agora quatro vetores de imagens: parado olhando para a direita, parado olhando para a esquerda, caminhando para a direita e caminhando para a esquerda. Os dois vetores para a direita você já tratou no exercício anterior. Já os outros dois você pode carregar as mesmas imagens e usar o método mirrorHorizontally para invertê-las.\nAlém disso, é necessário que o atributo que indica a ação do cavaleiro tenha quatro estados, assim como os vetores.\nE aí? Vai encarar o desafio?"
  },
  {
    "objectID": "cap4-3.html#section-44",
    "href": "cap4-3.html#section-44",
    "title": "IPOO - Cap. 4 Agrupando Objetos",
    "section": "",
    "text": "Para ter presença nessa aula teórica ANP, demostrando que você estudou o conteúdo, você deve fazer a atividade abaixo.\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nResponda às tarefas no Campus Virtual enviando o o seu projeto do organizador-musicas-v5 e o projeto criado no Greenfoot com a animação do cavaleiro, contendo as alterações solicitadas nos exercícios ao longo dos slides."
  },
  {
    "objectID": "cap5-2.html#section",
    "href": "cap5-2.html#section",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Na aula teórica anterior nós melhoramos as respostas do sistema de suporte acrescentando uma sequência de if\\else if no método gerarResposta.\n\nfazendo com que a resposta dada tivesse relação com a pergunta do usuário.\nE isso foi feito verificando-se palavras-chave como: lento, bug, etc.\n\n\nMas repare que essa forma de implementação tem uma desvantagem importante:\n\nSe quisermos evoluir o sistema acrescentando novas respostas (para novas palavras-chave), teríamos que modificar o método gerarResposta e recompilar o sistema.\nO ideal era que essas informações viessem de um arquivo e pudéssemos utilizá-las sem precisar modificar o código e recompilar o sistema."
  },
  {
    "objectID": "cap5-2.html#section-1",
    "href": "cap5-2.html#section-1",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Supondo que tivéssemos uma forma de ler os dados de arquivo, nós poderíamos tratar essas informações utilizando a classe HashMap.\n\nNesta aula vamos conhecer os conceitos que envolvem essa classe.\nE como ela pode ser bem útil em nossos sistemas.\n\n\nMas antes disso, vamos entender um pouquinho mais sobre a palavra-chave import."
  },
  {
    "objectID": "cap5-2.html#section-2",
    "href": "cap5-2.html#section-2",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nos exercícios da aula teórica anterior, você provavelmente usou as linhas de código abaixo:\n\nimport java.util.ArrayList;\nimport java.util.Random;\n\n\nNós já usamos import antes, mas vamos agora entender um pouco mais sobre ele."
  },
  {
    "objectID": "cap5-2.html#section-3",
    "href": "cap5-2.html#section-3",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "As classes da biblioteca de classes do Java não ficam disponíveis automaticamente, como as outras classes do projeto.\n\nPara usá-las precisamos informar isso para o compilador.\nEsse processo é chamado de importação de classe.\n\nE é feito usando a palavra-chave import.\n\n\n\nO comando import tem o seguinte formato:\n\nimport nome_qualificado_da_classe;"
  },
  {
    "objectID": "cap5-2.html#section-4",
    "href": "cap5-2.html#section-4",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Como a biblioteca de classes do Java possui milhares de classes,\n\né necessário ter alguma forma de organização que facilite a utilização delas.\n\n\nJava usa pacotes para organizar as classes em grupos.\n\nE os pacotes podem ser aninhados (ou seja, os pacotes podem conter outros pacotes)."
  },
  {
    "objectID": "cap5-2.html#section-5",
    "href": "cap5-2.html#section-5",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "As classes ArrayList e Random, por exemplo, fazem parte do pacote java.util.\n\nNós podemos ver essa informação na documentação das classes.\n\n\nO nome completo ou nome qualificado de uma classe é:\n\no nome do seu pacote, seguido de um ponto, seguido do nome da classe.\nAssim, o nome completo da classe ArrayList, por exemplo, é: java.util.ArrayList."
  },
  {
    "objectID": "cap5-2.html#section-6",
    "href": "cap5-2.html#section-6",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Java também nos permite importar pacotes completos com o comando:\n\nimport nome_do_pacote.*;\n\n\nPortanto, o comando abaixo importaria todas as classes do pacote java.util:\n\nimport java.util.*;\n\n\n\nMas, apesar da linguagem permitir isso, é uma boa prática importar apenas as classes que você realmente vai usar.\n\nA vantagem é a legibilidade, pois fica claro quais classes são realmente necessárias."
  },
  {
    "objectID": "cap5-2.html#section-7",
    "href": "cap5-2.html#section-7",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Há uma exceção a essas regras de pacotes:\n\nAlgumas classes são tão usadas que seriam importadas em quase todas as classes que implementamos.\nEssas classes pertecem ao pacote java.lang.\n\n\nEsse pacote é importado automaticamente pelo compilador em todas as classes.\n\nPortanto, não precisamos usar o comando import para esse pacote.\nA classe String é um exemplo de classe desse pacote."
  },
  {
    "objectID": "cap5-2.html#section-8",
    "href": "cap5-2.html#section-8",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Um Mapa é uma coleção de pares de objetos chave-valor.\n\nAssim como um ArrayList, um Mapa pode guardar uma quantidade flexível de entradas.\nMas uma diferença importante é que em um Mapa, uma entrada não é um objeto, e sim um par de objetos.\n\nEste par é formado por um objeto chave e um objeto valor.\n\n\n\nEnquanto com ArrayList buscamos objetos pela sua posição,\n\ncom um Mapa, usamos o objeto chave para buscar o objeto valor associado a ele."
  },
  {
    "objectID": "cap5-2.html#section-9",
    "href": "cap5-2.html#section-9",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Você consegue pensar em um exemplo de Mapa, ou seja, de coleção de dados organizados na forma de pares chave/valor?\n\nUm exemplo bem comum de um Mapa é a lista de contatos de um celular.\nA lista de contatos tem entradas, e cada entrada é um par: um nome e um número de telefone.\n\n\nUsamos a lista de contatos procurando por um nome e, ao encontrá-lo, obtemos o número de telefone associado a ele.\n\nNós não procuramos os contatos por um índice ou posição.\nPortanto, nós buscamos um valor (o número de telefone), a partir de uma chave (o nome)"
  },
  {
    "objectID": "cap5-2.html#section-10",
    "href": "cap5-2.html#section-10",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Na lista de contatos de um celular poderíamos ter uma coleção como a seguinte:\n\n\n\nNome\nNúmero\n\n\n\n\nTião\n9999 1111\n\n\nMaria\n8888 1234\n\n\nJoaquim\n9876 5432\n\n\n\n\nNeste exemplo:\n\nA primeira entrada tem a chave \"Tião\" e o valor \"9999 1111\".\nEu poderia buscar um número a partir da chave \"Maria\".\n\nE a resposta a esta busca seria \"8888 1234\"."
  },
  {
    "objectID": "cap5-2.html#section-11",
    "href": "cap5-2.html#section-11",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Você consegue pensar em outros exemplos de coleções na forma de Mapa que usamos no dia a dia?\n\nUm dicionário:\n\nBuscamos um significado (valor) a partir de uma palavra (chave).\n\n\n\nSiglas e nomes de estados:\n\nPodemos buscar o nome de um estado (valor) a partir de sua sigla (chave).\n\n\n\nUma coleção de alunos:\n\nPodemos buscar um objeto aluno (valor) a partir da sua matrícula (chave).\n\n\n\n\n\n\n\nConceito\n\n\nUm mapa é uma coleção que guarda pares chave/valor como entradas. Valores podem ser buscados forncendo-se a chave correspondente."
  },
  {
    "objectID": "cap5-2.html#section-12",
    "href": "cap5-2.html#section-12",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A forma mais simples de usar essa estrutura é através da classe HashMap.\n\nHashMap é uma implementação particular de Mapa."
  },
  {
    "objectID": "cap5-2.html#section-13",
    "href": "cap5-2.html#section-13",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Os métodos mais importantes da classe HashMap são: put e get.\n\nO método put insere uma entrada no mapa (um par de objetos chave/valor).\nJá o método get recupera o valor associado a uma chave.\n\n\nO trecho de código abaixo cria um HashMap e insere nele três entradas.\n\nCada entrada é um par chave/valor consistindo de um nome e um número de telefone.\n\n\n    HashMap&lt;String,String&gt; contatos = new HashMap&lt;&gt;();\n    contatos.put(\"Tiao\", \"9999 1111\");\n    contatos.put(\"Maria\", \"8888 1234\");\n    contatos.put(\"Joaquim\", \"9876 5432\");"
  },
  {
    "objectID": "cap5-2.html#section-14",
    "href": "cap5-2.html#section-14",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Quando declaramos uma variável do tipo HashMap e quando criamos um objeto HashMap\n\nprecisamos informar o tipo dos objetos que serão guardados.\nAssim como fazemos com ArrayList.\n\n\nNo caso do HashMap, precisamos informar dois tipos:\n\no tipo dos objetos chave e o tipo dos objetos valor.\n\n\n\nNo caso da lista de contatos, por exemplo, definimos que tanto a chave quanto o valor são objetos do tipo String.\n\n    HashMap&lt;String,String&gt; contatos = new HashMap&lt;&gt;();"
  },
  {
    "objectID": "cap5-2.html#section-15",
    "href": "cap5-2.html#section-15",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O trecho de código abaixo encontra e exibe o telefone da Maria.\n\n    String telefone = contatos.get(\"Maria\");\n    System.out.println(\"Telefone da Maria: \" + telefone);\n\n\nRepare que passamos a chave (o nome \"Maria\") para o método get e ele nos retorna o valor (o número do telefone dela).\n\n\n\n\n\n\nExercício\n\n\nLeia a documentação dos métodos get e put da classe HashMap e veja se a explicação bate com o que você está entendendo até o momento."
  },
  {
    "objectID": "cap5-2.html#section-16",
    "href": "cap5-2.html#section-16",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\n\nCrie no BlueJ um projeto chamado contatos-hashmap.\nCrie uma classe chamada Contatos e use um HashMap para implementar uma lista de contatos similar à que vimos anteriormente. Lembre-se que você deve importar java.util.HashMap.\nNa classe, implemente dois métodos:\n\n    public void cadastrarNumero(String nome, String numero)\n\ne\n\n    public String buscarNumero(String nome)\n\nOs métodos devem usar os métodos put e get da classe HashMap para implementar suas funcionalidades."
  },
  {
    "objectID": "cap5-2.html#section-17",
    "href": "cap5-2.html#section-17",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Para os exercícios a seguir, você pode usar a documentação oficial da classe HashMap do Java.\n\n\n\n\n\nExercício\n\n\nVerifique na documentação como podemos saber quantas entradas estão guardadas em um HashMap.\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente com o BlueJ o que acontece quando você adiciona uma entrada em uma mapa com uma chave que já existia no mapa.\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente com o BlueJ o que acontece quando você adiciona duas entradas em uma mapa com o mesmo valor, mas com chaves diferentes."
  },
  {
    "objectID": "cap5-2.html#section-18",
    "href": "cap5-2.html#section-18",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nComo você pode verificar se uma chave existe em um mapa? Escreva um código Java de exemplo.\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente com o BlueJ o que acontece quando você tenta procurar um valor e a chave fornecida não existe no mapa.\n\n\n\n\n\n\n\n\nExercício\n\n\nComo podemos imprimir todas as chaves que estão armazenadas em um HashMap."
  },
  {
    "objectID": "cap5-2.html#section-19",
    "href": "cap5-2.html#section-19",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\nAltere o projeto contatos-hashmap, criando uma classe chamada TestesHashMap.\nNesta classe, implemente um método chamado testar que demonstre todas as funcionalidades que você experimentou nos exercícios dos slides anteriores."
  },
  {
    "objectID": "cap5-2.html#section-20",
    "href": "cap5-2.html#section-20",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Na aula passada você fez um exercício para que o sistema de suporte desse respostas que tivessem relação com a reclamação do usuário.\n    if (entrada.contains(\"lento\")) {\n        return \"Acredito que isso tem a ver com o seu hardware. \" +\n               \"Atualizar seu processador deve resolver todos os \" +\n               \"problemas de desempenho. Você tem algum problema \" + \n               \"com nosso software?\"\n    }\n    else if (entrada.contains(\"bug\")) {\n        ...\n\nMas tratar isso usando blocos if\\else if não é a melhor forma implementar.\n\nIsso porque a cada nova palavra-chave tratada, teríamos que alterar o código e recompilar o sistema."
  },
  {
    "objectID": "cap5-2.html#section-21",
    "href": "cap5-2.html#section-21",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós podemos melhorar essa implementação usando um HashMap.\n\nA ideia é ter um mapa que relacione palavras como \"lento\" e \"bug\" com as respostas correspondentes a estas palavras.\nPortanto, o mapa terá como chave uma String e como valor também uma String.\n\n\nNos próximos exercícios vamos fazer essa implementação.\n\nNós vamos colocar as entradas do HashMap diretamente no código.\nE, portanto, alguém pode argumentar que isso não é muito diferente de usar if\\else if.\nMas, a inclusão das entradas no HashMap poderia ser feita a partir de um arquivo, por exemplo.\n\nE, assim, poderíamos acrescentar novas palavras-chave no arquivo sem precisar recompilar o sistema."
  },
  {
    "objectID": "cap5-2.html#section-22",
    "href": "cap5-2.html#section-22",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício (entrega)\n\n\n\nAltere a classe a classe Respondedor do projeto suporte-tecnico1 para que ela tenha um atributo mapa para guardar as palavras-chaves e as respostas.\nCrie um método chamado preencherMapaDeRespostas que preenche o mapa com as respostas que você tinha tratado como if\\else if na aula anterior. Chame o método no construtor da classe.\nPor fim, altere o método gerarResposta da seguinte forma:\n\nEle deve ter um loop para percorrer as chaves do mapa.\nDentro do loop deve verificar se a variável entrada contém a chave.\n\nSe sim, ele deve retornar o valor associado a esta chave.\n\nSe o loop terminar e a entrada não tiver nenhuma das chaves, ele deve retornar uma resposta padrão.\n\nPor exemplo, “Desculpe, não entendi o que você quis dizer. Poderia reformular a pergunta?”."
  },
  {
    "objectID": "cap5-2.html#section-23",
    "href": "cap5-2.html#section-23",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A biblioteca de classes do Java possui diferentes tipos de conjuntos implementados em diferentes classes.\n\nUma delas é a classe HashSet.\n\n\n\n\n\n\nExercício\n\n\nBusque na documentação do Java, ou em outras fontes, quais são as similaridades e as diferenças enre um HashSet e um ArrayList.\nTente entender porque ArrayList é um caso especial de List e HashSet é um caso especial de Set."
  },
  {
    "objectID": "cap5-2.html#section-24",
    "href": "cap5-2.html#section-24",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A declaração de um HashSet, a criação do objeto e a adição de elementos é feita da mesma forma que um ArrayList.\n\n    import java.util.HashSet;\n    . . .\n    HashSet&lt;String&gt; conjunto = new HashSet&lt;&gt;();\n    conjunto.add(\"um\");\n    conjunto.add(\"dois\");\n    conjunto.add(\"três\");\n\n\nPara percorrer um HashSet podemos usar um for-each, igualzinho ao que usamos para ArrayList.\n\n    for(String elemento : conjunto) {\n        // faz alguma coisa com o elemento.\n    }"
  },
  {
    "objectID": "cap5-2.html#section-25",
    "href": "cap5-2.html#section-25",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Repare, portanto, que usar diferentes coleções em Java é sempre muito parecido.\n\nSe você entender como usar uma delas, você conseguirá usar as outras com facilidade.\n\n\nAs diferenças entre as coleções estão nos seus comportamentos.\n\nUma lista, por exemplo, mantém a ordem dos elementos, permite acesso aos elementos por posição, e permite elementos repetidos.\nJá um conjunto não mantém a ordem dos elementos, e garante que não existem elementos repetidos.\n\nPortanto, os elementos podem ser percorridos no for-each em ordem diferente da que eles foram inseridos.\nE inserir um mesmo elemento uma segunda vez, simplesmente não tem nenhum efeito."
  },
  {
    "objectID": "cap5-2.html#section-26",
    "href": "cap5-2.html#section-26",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Quando estamos trabalhando em nossos projetos,\n\né importante escrevermos a documentação de nossas classes, à medida que desenvolvemos o código.\nMuitas vezes programadores não levam a sério a documentação, o que pode levar a sérios problemas.\n\n\nSe você não fornecer documentação suficiente, pode ser difícil para outro programador entender suas classes.\n\nMuitas vezes esse outro programador pode ser você mesmo :)\n\n\n\nSem documentação, precisamos ler o código da classe para tentar entender como ela funciona.\n\nIsso pode funcionar em um projeto pequeno de estudante.\nMas cria problemas em projetos do mundo real."
  },
  {
    "objectID": "cap5-2.html#section-27",
    "href": "cap5-2.html#section-27",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "É muito comum que sistemas comerciais tenham centenas de milhares de linhas de código.\n\nImagine que você tivesse que ler todas essas linhas para entender como o código funciona.\nSeria impossível!\n\n\nNós conseguimos usar as classes da biblioteca Java, como HashSet e Random, olhando apenas a documentação delas.\n\nNós nunca precisamos olhar o código-fonte destas classes.\n\n\n\nIsso funciona porque as classes estão suficientemente bem documentadas.\n\nSeria muito mais difícil usar essas classes, se precisássemos ler e entender o código-fonte delas primeiro."
  },
  {
    "objectID": "cap5-2.html#section-28",
    "href": "cap5-2.html#section-28",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Em uma equipe de desenvolvimento de software, a implementação das classes é geralmente dividida entre vários programadores.\n\nUm programador poderia implementar a classe SistemaDeSuporte, por exemplo, e outro a classe LeitorDeEntrada.\nPortanto, você pode precisar implementar uma classe enquanto chama métodos de outras classes.\n\n\nAssim, o mesmo argumento usado para as classes da biblioteca Java vale para as classes que você escreve.\n\nSe podemos usar as classes sem ter que ler e entender toda a implementação, nossa tarefa fica mais fácil.\nNós precisamos apenas da interface das classes e não da implementação.\nPortanto, precisamos escrever boa documentação de classes também para as nossas próprias classes.\n\n\n\n\n\n\n\nConceito\n\n\nA documentação de uma classe deve ser detalhada o suficiente para que outros programadores consigam usar a classe sem precisar ler o código fonte."
  },
  {
    "objectID": "cap5-2.html#section-29",
    "href": "cap5-2.html#section-29",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O Java tem uma ferramenta chamada javadoc que gera documentação a partir de comentários no código.\n\nToda a documentação oficial das classes da biblioteca Java é gerada com o javadoc.\n\n\nO BlueJ usa o javadoc para gerar documentação das classes.\n\nCom o código de uma classe aberto no BlueJ, podemos acessar a caixa de opções no canto superior direito e mudar de código-fonte para documentação.\nOu podemos também usar o menu Ferramentas → Documentaçao do Projeto para gerar a documentação de todas as classes do projeto."
  },
  {
    "objectID": "cap5-2.html#section-30",
    "href": "cap5-2.html#section-30",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nExperimente acessar a documentação da classe SistemaDeSuporte no BlueJ.\n\n\n\n\n\n\nOs arquivos HTML gerados ficam em uma pasta doc dentro do projeto e podem ser abertos em qualquer navegador."
  },
  {
    "objectID": "cap5-2.html#section-31",
    "href": "cap5-2.html#section-31",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A documentação de uma classe deveria incluir, no mínimo:\n\nO nome da classe.\nUm comentário descrevendo o objetivo e as características da classe.\nUm número de versão.\nO nome do(s) autor(es).\nDocumentação para cada construtor e para cada método."
  },
  {
    "objectID": "cap5-2.html#section-32",
    "href": "cap5-2.html#section-32",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A documentação de todo construtor e método deve incluir, no mínimo:\n\nO nome do método.\nO tipo de retorno.\nOs nomes e tipos dos parâmetros.\nUma descrição do objetivo e função do método.\nUma descrição de cada parâmetro.\nUma descrição do valor retornado.\n\n\nAlém disso, cada projeto deveria ter um comentário geral sobre o projeto.\n\nGeralmente dentro de um arquivo README na pasta raiz do projeto.\nNo BlueJ podemos fazer esse comentário de projeto abrindo o arquivo que fica no canto superior esquerdo do diagrama de classses."
  },
  {
    "objectID": "cap5-2.html#section-33",
    "href": "cap5-2.html#section-33",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Alguns elementos da documentação podem ser sempre extraídos do código-fonte.\n\nComo os nomes e parâmetros dos métodos, por exemplo.\nJá a descrição da classe e dos métodos demanda mais atenção já que pode ser facilmente esquecida, ou ficar incompleta.\n\n\nNo Java, comentários Javadoc são escritos com um símbolo especial de comentário.\n\n/**\n * Este é um comentário Javadoc.\n * Ele pode ter várias linhas.\n */"
  },
  {
    "objectID": "cap5-2.html#section-34",
    "href": "cap5-2.html#section-34",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "O comentário deve ter /** no início e */ no final para ser reconhecido como um comentário javadoc.\n\nSe o comentário vem imediatamente antes da declaração da classe, ele é lido como a descrição da classe.\nSe ele está acima de uma assinatura de método, é considerado como um comentário do método.\n\n\nComo exatamente o comentário deve ser formatado para gerar a documentação pode variar de acordo com as ferramentas de cada linguagem de programação.\n\n\nNo caso do javadoc várias palavras-chave especiais estão disponíveis para formatar a documentação.\n\nEssas chaves começam com @, como, por exemplo:\n\n@version\n@author\n@param\n@return"
  },
  {
    "objectID": "cap5-2.html#section-35",
    "href": "cap5-2.html#section-35",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nEncontre exemplos de palavras-chave javadoc no projeto do sistema de suporte e verifique como eles influenciam a formatação da documentação.\nExperimente fazer alterações e conferir o resultado na documentação gerada.\n\n\n\n\n\n\n\n\nExercício (entrega)\n\n\n\nDocumente adequadamente as classes do projeto de suporte técnico e gere a documentação usando o BlueJ.\nConfira se a documentação gerada está completa antes de enviar o projeto."
  },
  {
    "objectID": "cap5-2.html#section-36",
    "href": "cap5-2.html#section-36",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Para ter presença nessa aula teórica ANP, demostrando que você estudou o conteúdo, você deve fazer a atividade abaixo.\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nResponda às duas tarefas no Campus Virtual enviando os seus projetos contatos-hashmap e suporte-tecnico1 com as alterações dos exercícios solicitados ao longo dos slides."
  },
  {
    "objectID": "cap6-1.html#section",
    "href": "cap6-1.html#section",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Vai aí um conselho:\n\nSeu desempenho como profissional no futuro depende de seu empenho agora.\nTome nota durante as aulas.\n\nFoque no conteúdo e não no WhatsApp, TikTok, etc."
  },
  {
    "objectID": "cap6-1.html#principais-conceitos-da-aula",
    "href": "cap6-1.html#principais-conceitos-da-aula",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Principais Conceitos da Aula",
    "text": "Principais Conceitos da Aula\nEste é o único conteúdo da disciplina que não se encontra no livro-texto que estamos utilizando.\n\nNesta aula aprenderemos sobre relacionamentos de classes.\n\nVeremos que podemos classificar a forma como os objetos de duas classes se relacionam.\n\nOs relacionamentos podem ser de composição, agregação ou associação.\n\nAprenderemos como esses relacionamentos podem ser tratados e/ou verificados no código-fonte dos nossos programas."
  },
  {
    "objectID": "cap6-1.html#section-1",
    "href": "cap6-1.html#section-1",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Nós já vimos que sistemas orientados a objetos se baseiam em envio de mensagens:\n\nOu seja, um objeto pode chamar métodos públicos de objetos de outras classes.\n\n\n\n\nNós dizemos que os objetos se relacionam quando enviam mensagens uns aos outros.\n\nSistemas orientados a objetos dependem muito de como os objetos se relacionam.\nO planejamento/modelagem das classes se baseiam nesses relacionamentos."
  },
  {
    "objectID": "cap6-1.html#section-2",
    "href": "cap6-1.html#section-2",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Quais objetos vocês acham que podem existir em um software de um caixa de supermercado?\n\nComo você acha que esses objetos se relacionam?\nO que cada um tem a ver com o outro? Quem envia mensagem pra quem?\n\n\n\nPodemos pensar que existiriam, por exemplo, as classes:\n\nProduto, Vendedor e Compra.\nUma compra pode ser formada por um conjunto de produtos e estar relacionada a um vendedor."
  },
  {
    "objectID": "cap6-1.html#section-3",
    "href": "cap6-1.html#section-3",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "E quais objetos vocês acham que podem existir em um software como o SIG?\n\nPense mais uma vez em como os objetos se relacionam. O que cada um tem a ver com o outro.\n\n\n\nPodemos pensar que existiriam, por exemplo, as classes:\n\nAluno, Disciplina, Turma, Curso, Professor, etc.\nComo cada objeto se relaciona com o outro?"
  },
  {
    "objectID": "cap6-1.html#section-4",
    "href": "cap6-1.html#section-4",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Vamos a um último exemplo. Quais objetos poderiam existir em uma plataforma de streaming como a Netflix?\n\n\nPosso pensar em classes como:\n\nUsuário, PerfilDeUsuário, Filmes, etc.\nPodemos pensar que um usuário possui vários perfis.\nCada perfil possui um conjunto de filmes já vistos.\nE por aí vai…"
  },
  {
    "objectID": "cap6-1.html#section-5",
    "href": "cap6-1.html#section-5",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Podemos perceber, portanto, que a grande maioria dos softwares orientados a objetos dependem em grande parte de como os objetos se relacionam."
  },
  {
    "objectID": "cap6-1.html#section-7",
    "href": "cap6-1.html#section-7",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Vamos começar com um exemplo de classes Carro e Motor.\n\nComo podemos dizer que é o relacionamento entre os objetos das classes Carro e Motor?\n\n\n\nPodemos dizer que um carro tem um motor.\n\n\nE quanto aos pneus?\n\nDe forma similar, podemos dizer que um carro tem vários pneus."
  },
  {
    "objectID": "cap6-1.html#section-8",
    "href": "cap6-1.html#section-8",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Agora um novo exemplo, qual é o relacionamento entre os objetos de uma classe Banco e uma classe Agencia?\n\n\nVeja que também podemos dizer que um banco tem várias agências."
  },
  {
    "objectID": "cap6-1.html#section-9",
    "href": "cap6-1.html#section-9",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Por fim, qual o relacionamento entre os objetos de uma nota fiscal e os itens de compra que compõem a nota fiscal?\n\n\n\n\n\nMais uma vez, uma nota fiscal tem vários itens de compra."
  },
  {
    "objectID": "cap6-1.html#section-10",
    "href": "cap6-1.html#section-10",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Repare que os três exemplos têm em comum o fato de que um objeto tem (um ou mais) objetos de outra classe.\n\n\nNós também podemos dizer que estes são relacionamentos do tipo todo/parte.\n\nA classe que representa o todo tem objetos da classe que representa a parte."
  },
  {
    "objectID": "cap6-1.html#section-11",
    "href": "cap6-1.html#section-11",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Mas além disso, há outro fator importante. Repare que:\n\nSe não tenho um carro, não faz sentido criar as rodas.\nSe um banco faliu, não preciso mais de agências.\nSem um pedido não tenho itens de pedido.\n\n\n\nNós dizemos então que, nestes casos, o todo controla o tempo de vida das partes."
  },
  {
    "objectID": "cap6-1.html#section-12",
    "href": "cap6-1.html#section-12",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Nós chamamos esses casos de Relacionamentos de Composição."
  },
  {
    "objectID": "cap6-1.html#composição---exemplo-de-código",
    "href": "cap6-1.html#composição---exemplo-de-código",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Composição - Exemplo de Código",
    "text": "Composição - Exemplo de Código\nSuponha que vamos implementar em Java um sistema que tenha as classes Carro, Motor e Porta.\n\nNós vimos que esse é um exemplo de composição.\nMas como isso pode ser implementado?\n\n\n\npublic class Carro {\n    private Motor motor;\n    private Porta[] portas;\n    \n    public Carro() {\n        motor = new Motor();\n        portas = new Porta[4];\n        for (int i = 0; i &lt; 4; i++) {\n            portas[i] = new Porta();\n        }\n    }\n    // restante do código omitido\n}"
  },
  {
    "objectID": "cap6-1.html#composição---exemplo-de-código-1",
    "href": "cap6-1.html#composição---exemplo-de-código-1",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Composição - Exemplo de Código",
    "text": "Composição - Exemplo de Código\n\npublic class Carro {\n    private Motor motor;\n    private Porta[] portas;\n    \n    public Carro() {\n        motor = new Motor();\n        portas = new Porta[4];\n        for (int i = 0; i &lt; 4; i++) {\n            portas[i] = new Porta();\n        }\n    }\n    // restante do código omitido\n}\n\nComo o motor e as portas são partes do carro, eles devem ser atributos do carro.\n\nE como qualquer atributo devem ser privados.\nO carro controla o tempo de vida do motor e das portas, portanto é ele quem cria os objetos do motor e das portas."
  },
  {
    "objectID": "cap6-1.html#section-13",
    "href": "cap6-1.html#section-13",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Atenção!\nÉ importante que a classe que representa o todo não tenha um método de acesso que retorne uma referência para o(s) objeto(s) da(s) parte(s).\n\nRepare que, como nenhum outro objeto consegue ter uma referência para os objetos motor e portas, esses objetos só podem ser destruídos juntos com o carro.\nPortanto o tempo de vida deles está completamente controlado pelo carro.\n\n\nCaso essa regra não seja seguida haverá uma quebra do encapsulamento.\n\nNão adianta o motor ser declarado com visibilidade privada, se houver um método de acesso que retorne o motor.\nPor que, outra classe poderia usar esse método para ter acesso ao motor e chamar métodos modificadores do motor sem que a classe Carro tomasse conhecimento."
  },
  {
    "objectID": "cap6-1.html#composição---resumo",
    "href": "cap6-1.html#composição---resumo",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Composição - Resumo",
    "text": "Composição - Resumo"
  },
  {
    "objectID": "cap6-1.html#section-14",
    "href": "cap6-1.html#section-14",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Vamos ver agora um outro tipo de relacionamento.\n\nEle é parecido, mas é diferente ☺"
  },
  {
    "objectID": "cap6-1.html#section-15",
    "href": "cap6-1.html#section-15",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Voltando nesse exemplo, qual seria o relacionamento entre os produtos e o depósito?\n\n\n\nUm depósito tem vários produtos.\nE um produto é parte de um depósito.\n\n\n\nEntão, à primeira vista, parece uma composição, certo?"
  },
  {
    "objectID": "cap6-1.html#section-16",
    "href": "cap6-1.html#section-16",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Mas imagine essa situação:\n\n\nRepare que os produtos continuam existindo ao deixarem o depósito, certo?"
  },
  {
    "objectID": "cap6-1.html#section-17",
    "href": "cap6-1.html#section-17",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "O fato é que os produtos podem sair do depósito e ir para as gôndolas.\n\nAlém disso, podem existir produtos que vão direto para as gôndolas (sem passar pelo depósito).\nPortanto, o depósito não controla o tempo de vida dos produtos.\n\n\nDizendo de outra forma, não é o todo quem controla o tempo de vida das partes.\n\n\nNós chamamos esse tipo de relacionamento de agregação."
  },
  {
    "objectID": "cap6-1.html#agregação---exemplo-de-código",
    "href": "cap6-1.html#agregação---exemplo-de-código",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Agregação - Exemplo de Código",
    "text": "Agregação - Exemplo de Código\nEm um sistema de gestão escolar, podemos ter as classes Departamento e Professor.\n\nComo o departamento tem professores, os professores devem ser atributos do departamento.\nMas se o departamento deixar de existir os professores continuam existindo. Ufa!!! ☺\nPortanto essa é uma relação de agregação.\n\n\n\npublic class Departamento {\n    private ArrayList&lt;Professor&gt; professores;\n\n    public Departamento() {\n        professores = new ArrayList&lt;&gt;();\n    }\n    \n    public void contratarProfessor(Professor professor) {\n        professores.add(professor);\n    }\n\n    // restante do código omitido\n}"
  },
  {
    "objectID": "cap6-1.html#section-18",
    "href": "cap6-1.html#section-18",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Lembre-se que, em uma agregação, o todo não controla o tempo de vida das partes.\n\nIsso pode ficar explícito no código de duas formas:\n\nNão é a classe que representa o todo que cria o objeto da parte (como é o caso do exemplo anterior).\nE/ou, a classe do todo pode até criar a parte, mas ela tem algum método de acesso que retorna (o endereço da) a parte.\n\nPermitindo que outras classes mantenham o objeto da parte, sem o conhecimento da classe que representa o todo."
  },
  {
    "objectID": "cap6-1.html#section-19",
    "href": "cap6-1.html#section-19",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Uma outra forma de diferenciar Composição de Agregação é pensar que:\n\nNa composição, as partes estão totalmente encapsuladas no todo.\nDe fora da classe do todo, nem precisamos saber como a parte é tratada."
  },
  {
    "objectID": "cap6-1.html#agregação---resumo",
    "href": "cap6-1.html#agregação---resumo",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Agregação - Resumo",
    "text": "Agregação - Resumo"
  },
  {
    "objectID": "cap6-1.html#section-20",
    "href": "cap6-1.html#section-20",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Veremos agora o terceiro tipo de relacionamento:\n\nSuponha, por exemplo, que um professor que dá aulas particulares, resolva fazer um sistema para controlar suas atividades.\nEle criou uma classe Professor e uma classe Aluno.\n\nQual é o relacionamento entre essas classes?\n\n\n\n\n\nO professor dá aulas para o aluno e o aluno tem aulas com o professor.\n\nMas não faz sentido dizer que o aluno é parte do professor ou que o professor é formado por alunos.\nPortanto, não é um relacionamento todo / parte.\n\n\n\n\n\n\nNós chamamos esse tipo de relacionamento de associação."
  },
  {
    "objectID": "cap6-1.html#associação---exemplo-de-código",
    "href": "cap6-1.html#associação---exemplo-de-código",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Associação - Exemplo de Código",
    "text": "Associação - Exemplo de Código\nVamos pensar no relacionamento entre as classes Motorista, CarteiraDeMotorista e Carro.\n\nA carteira de motorista não é parte de um motorista e nem o contrário. Portanto, é uma associação.\n\nElas têm um relacionamento baseado em propriedade. Um motorista possui uma CNH.\n\nDa mesma forma um carro não é parte de um motorista e nem o contrário. Portanto, também é uma associação.\n\nElas têm um relacionamento: um motorista viaja em um carro."
  },
  {
    "objectID": "cap6-1.html#associação---exemplo-de-código-1",
    "href": "cap6-1.html#associação---exemplo-de-código-1",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Associação - Exemplo de Código",
    "text": "Associação - Exemplo de Código\n\npublic class Motorista {\n    private CarteiraMotorista cnh;\n    \n    public void tirarCarteira(CarteiraMotorista cnh)    \n        this.cnh = cnh;\n    }\n\n    public void viajar(Carro carro, int distancia){\n        ...\n        carro.acelerar();\n        ...\n        carro.parar();\n    }\n\n    // restante do código omitido\n}"
  },
  {
    "objectID": "cap6-1.html#section-21",
    "href": "cap6-1.html#section-21",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Repare que, no exemplo anterior, existem duas formas de implementação de associação.\n\nUma através de atributo e outra não.\nO que importa no final das contas é que na associação um objeto chama métodos de outro.\n\nMas o relacionamento não é todo/parte."
  },
  {
    "objectID": "cap6-1.html#resumo-relacionamentos",
    "href": "cap6-1.html#resumo-relacionamentos",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "Resumo: Relacionamentos",
    "text": "Resumo: Relacionamentos"
  },
  {
    "objectID": "cap6-1.html#section-22",
    "href": "cap6-1.html#section-22",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Em séries, como Game of Thrones, vemos que não é possível separar completamente os personagens em bons e maus, mocinhos e bandidos.\n\nOu seja, ninguém é 100% bom ou 100% mau.\n\n\n\nDa mesma forma, a classificação da relação (se é associação, agregação ou composição) é relativa.\n\nDepende do contexto."
  },
  {
    "objectID": "cap6-1.html#section-23",
    "href": "cap6-1.html#section-23",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Voltemos ao exemplo das classes Carro e Motor.\n\nNós vimos que a relação entre essas classes foi classificada como Composição.\n\n\n\nMas o que vocês pensam sobre esse caso?"
  },
  {
    "objectID": "cap6-1.html#section-24",
    "href": "cap6-1.html#section-24",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Nesse caso, um motor existe independentemente do carro.\n\nPortanto, não é o carro quem controla o tempo de vida do motor.\nE, por isso, o relacionamento não pode mais ser classificado como composição.\n\n\nQual seria o relacionamento nesse caso então?\n\nComo continua sendo um relacionamento todo/parte,\nÉ um relacionamento de agregação."
  },
  {
    "objectID": "cap6-1.html#section-25",
    "href": "cap6-1.html#section-25",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Podemos então concluir que:\n\nNão basta simplesmente decorar pares de classes com suas respectivas relações.\nO relacionamento entre as classes sempre dependerá do contexto, do problema que está sendo tratado."
  },
  {
    "objectID": "cap6-1.html#section-26",
    "href": "cap6-1.html#section-26",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Exercício\n\n\nDefina o relacionamento entre as classes representadas pelas palavras destacadas nas situações abaixo:\n\nEstamos trabalhando em um sistema para controlar um aeroporto. Precisaremos modelar a pista de pouso e os aviões para simular os pousos e decolagens.\nO jogo vai ser muito bacana. Vai ter um helicóptero que voa baixo e rápido e que possui metralhadoras acopladas. Mas tem que treinar bastante pra conseguir ser um bom piloto e fazer um ataque de verdade.\nA Câmara de Vereadores está informatizando todo seu processo legislativo. Como forma de divulgação, eles farão um jogo educativo no qual os cidadãos poderão propor leis que melhorem a vida na cidade."
  },
  {
    "objectID": "cap6-1.html#section-27",
    "href": "cap6-1.html#section-27",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Exercício (entrega)\n\n\n\nCrie classes em Java para as situações apresentadas no exerício anterior.\n\nNo comentário do cabeçalho de cada classe coloque o tipo de relacionamento que a classe possui com a outra classe e justifique sua resposta.\n\nEx.: Esta classe PistaDePouso possui um relacionamento de __________ com a classe Avião, pois ______.\n\n\nObs.: você não precisa criar a classe completa, mas precisa fazer um código que demonstre completamente que ele implementa o tipo de relacionamento que você respondeu no exercício."
  },
  {
    "objectID": "cap6-1.html#section-28",
    "href": "cap6-1.html#section-28",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Vale a pena reforçar um ponto que foi discutido ao apresentar o Relacionamento de Composição.\n\nVamos fazer isso através de um exemplo.\n\n\nNo início da disciplina, usamos o projeto casa, que tinha uma classe Figura.\n\nA classe Figura desenhava uma casa formada por uma parede, uma janela e um telhado, sendo estes objetos das classes Quadrado e Triangulo.\nSeguindo o conceito de encapsulamento, os atributos da classe são privados.\n\n\n\nRepare que o relacionamento entre a classe Figura e as classes Quadrado e Triangulo é de composição.\n\nPois a figura tem paredes (quadrado) e telhado (triângulo), eles são partes da figura.\nE a figura controla o tempo de vida das partes."
  },
  {
    "objectID": "cap6-1.html#section-29",
    "href": "cap6-1.html#section-29",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Mas suponha que a classe Figura tivesse um método de acesso que retornasse o telhado.\n\nO relacionamento continuaria sendo de composição?\nE, principalmente, o encapsulamento continuaria sendo respeitado?\n\n\n    public Triangulo obterTelhado(){\n        return telhado;\n    }"
  },
  {
    "objectID": "cap6-1.html#section-30",
    "href": "cap6-1.html#section-30",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Suponha, por exemplo, que tenhamos um objeto figura1 como mostrado na figura abaixo.\n\nRepare que podemos, de fora da classe Figura, obter uma referência para o objeto telhado."
  },
  {
    "objectID": "cap6-1.html#section-31",
    "href": "cap6-1.html#section-31",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "E, com isso, podemos alterar a cor do telhado sem que a classe Figura tome conhecimento.\n\nO que é uma falha de encapsulamento!"
  },
  {
    "objectID": "cap6-1.html#section-32",
    "href": "cap6-1.html#section-32",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Veja que um método de acesso que retorne um atributo que é um objeto:\n\ntem o mesmo efeito de deixar o atributo público.\n\n\nMas, se o relacionamento desejado era de composição,\n\nIsto é uma falha de encapsulamento.\nAlém de, tecnicamente, no código, o relacionamento se tornar uma agregação.\n\n\n\nPor isso, é muito importante, ao criar uma classe, documentar o seu relacionamento com as classes dos atributos.\n\nPodemos fazer isso nos comentários da classe.\nOu, usando Diagramas de Classes UML (assunto visto na disciplina PPOO)."
  },
  {
    "objectID": "cap6-1.html#section-33",
    "href": "cap6-1.html#section-33",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Por outro lado, veja que nos casos onde o relacionamento desejado é de agregação,\n\nnão há problema em ter um método de acesso que retorne o atributo.\nPois, nestes casos, o todo não controla o tempo de vida das partes.\n\nE se houver alguma modificação no atributo, isso não é um problema para o todo.\n\n\n\nVeja, por exemplo, o caso do relacionamento entre as classes Local e Item no jogo que você está fazendo, baseado no World of Zuul.\n\nUm local tem um item, e um item faz parte do local.\nMas não é o local quem controla o tempo de vida dos itens.\n\nPois os itens são criados fora do local e podem ser removidos do local.\n\nPortanto, o relacionamento entre as classes é de agregação.\nNeste caso, a classe Local pode ter um método que retorne o item, e isso não é uma falha de encapsulamento!"
  },
  {
    "objectID": "cap6-1.html#section-34",
    "href": "cap6-1.html#section-34",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "O conteúdo de Estratégias de Depuração está em uma apresentação separada."
  },
  {
    "objectID": "cap6-1.html#section-35",
    "href": "cap6-1.html#section-35",
    "title": "IPOO - Relacionamentos de Classes",
    "section": "",
    "text": "Para ter presença nessa aula teórica ANP, você deve fazer a atividade abaixo.\n\n\n\n\n\n\n\nEntregas no Campus Virtual\n\n\nResponda a tarefa no Campus Virtual enviando os trechos de código em Java que você fez no exercício marcado para entrega."
  },
  {
    "objectID": "greenfoot-tutorial.html#a-interface-do-greenfoot",
    "href": "greenfoot-tutorial.html#a-interface-do-greenfoot",
    "title": "Tutorial do Greenfoot",
    "section": "A interface do Greenfoot",
    "text": "A interface do Greenfoot\nBaixe o projeto greenfoot-ursos e abra-o no Greenfoot.\n\nA interface do Greenfoot tem três áreas principais.\n\nO mundo.\n\nNa maior parte da tela aparece o mundo do jogo.\n\nAs classes.\n\nSão exibidas em caixas no diagrama do lado direito.\n\nE os botões de controle de execução.\n\nBotões abaixo do mundo que permitem controlar a execução do jogo."
  },
  {
    "objectID": "greenfoot-tutorial.html#colocando-objetos-no-mundo",
    "href": "greenfoot-tutorial.html#colocando-objetos-no-mundo",
    "title": "Tutorial do Greenfoot",
    "section": "Colocando objetos no mundo",
    "text": "Colocando objetos no mundo\nClique com o botão direito na classe Urso e acesse a opção new Urso().\n\nE então clique em qualquer lugar do mundo.\nVocê acabou de criar um objeto Urso.\n\n\nFaça o mesmo tipo de operação com as folhas, colocando algumas folhas no mundo.\n\n\nDica:\n\nExiste um atalho para colocar objetos no mundo.\nSelecione uma classe, e clique no mundo segurando a tecla Shift do teclado."
  },
  {
    "objectID": "greenfoot-tutorial.html#fazendo-objetos-agirem",
    "href": "greenfoot-tutorial.html#fazendo-objetos-agirem",
    "title": "Tutorial do Greenfoot",
    "section": "Fazendo objetos agirem",
    "text": "Fazendo objetos agirem\nClique no botão Executar uma vez (obs.: no Greenfoot em inglês o botão se chama Act).\n\nAo clicar no botão, cada objeto age.\nOu seja, faz o que foi programado para fazer.\n\n\nNeste exemplo, as folhas não fazem nada.\n\nE os ursos são programados para andar para frente.\nExperimente criar dois ursos e clicar de novo no botão Executar uma vez.\n\nOs dois ursos vão se mover.\n\n\n\n\nUrsos também comem folhas.\n\nExperimente colocar uma folha na frente de um urso e clicar no botão Executar uma vez."
  },
  {
    "objectID": "greenfoot-tutorial.html#chamar-métodos-diretamente",
    "href": "greenfoot-tutorial.html#chamar-métodos-diretamente",
    "title": "Tutorial do Greenfoot",
    "section": "Chamar métodos diretamente",
    "text": "Chamar métodos diretamente\nEm vez de executar todo o cenário, você pode chamar métodos para cada objeto separadamente.\n\nExperimente clicar em um urso colocado no mundo.\nVocê verá as opções de chamar os métodos, da mesma forma que vemos no BlueJ.\n\n\nExperimente chamar o método virarAEsquerda para algum urso.\n\nE depois o método mover.\n\n\n\nRepare que há um método chamado act.\n\nÉ este método que é chamado toda vez que clicamos no botão Executar uma vez."
  },
  {
    "objectID": "greenfoot-tutorial.html#criar-um-novo-mundo",
    "href": "greenfoot-tutorial.html#criar-um-novo-mundo",
    "title": "Tutorial do Greenfoot",
    "section": "Criar um novo mundo",
    "text": "Criar um novo mundo\nVocê pode recomeçar tudo, criando um novo mundo.\n\nPara isso use o obtão Reiniciar.\nO objeto do mundo será descartado (junto com os objetos adicionados nele).\nE um novo mundo será criado.\n\nObs.: Só pode existir um mundo ativo por vez."
  },
  {
    "objectID": "greenfoot-tutorial.html#chamando-um-método-do-mundo",
    "href": "greenfoot-tutorial.html#chamando-um-método-do-mundo",
    "title": "Tutorial do Greenfoot",
    "section": "Chamando um método do mundo",
    "text": "Chamando um método do mundo\nÉ possível também chamar métodos do mundo.\n\nBasta clicar em uma área vazia do mundo (sem ursos, nem folhas),\n\nou na área cinza ao redor do mundo.\n\nE serão exibidos os seus métodos.\n\n\nExperimente chamar o método povoar.\n\nEste método cria vários ursos e folhas.\nExecute então o jogo.\n\n\n\nExperimente agora o método folhasAleatorias.\n\nA quantidade de folhas pode ser passada por parâmetro.\nObs.: às vezes pode parecer que não apareceram todas as folhas.\n\nMas é que pode acontecer de duas folhas acabarem caindo na mesma célula."
  },
  {
    "objectID": "greenfoot-tutorial.html#section",
    "href": "greenfoot-tutorial.html#section",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Bom, chega de ursos andando em círculos…\n\nVamos agora para outro exemplo no qual faremos algo mais interessante: programar!"
  },
  {
    "objectID": "greenfoot-tutorial.html#o-cenário-caranguejo",
    "href": "greenfoot-tutorial.html#o-cenário-caranguejo",
    "title": "Tutorial do Greenfoot",
    "section": "O cenário caranguejo",
    "text": "O cenário caranguejo\nBaixe o projeto greenfoot-caranguejo e abra-o no Greenfoot.\n\nVocê verá um mundo de areia.\n\n\nCrie um caranguejo e coloque-o no mundo.\n\nClique então em Executar.\nAconteceu alguma coisa?"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-1",
    "href": "greenfoot-tutorial.html#section-1",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "O caranguejo não fez nada porque não tem nada programado para ele fazer.\n\nVamos mudar isso!\n\n\nAbra a classe Caranguejo (clicando duas vezes na caixa da classe).\n\nVeja que a classe tem um método act (agir) vazio, por isso o caranguejo não faz nada.\nExperimente colocar o comando move(4) dentro do método act.\n\nCompile a classe, coloque um caranguejo no mundo e clique em executar.\nVeja que o caranguejo se move para a direita até parar na borda do mundo.\nVocê pode até pausar o mundo e arrastar o caranguejo para que ele ande novamente."
  },
  {
    "objectID": "greenfoot-tutorial.html#só-para-os-curiosos",
    "href": "greenfoot-tutorial.html#só-para-os-curiosos",
    "title": "Tutorial do Greenfoot",
    "section": "Só para os curiosos",
    "text": "Só para os curiosos\nMas de onde veio esse método move?\n\nE por que estamos chamando o método sem usar nenhum objeto?\n\n\nNós vamos entender isso melhor ao estudarmos o conceito de Herança.\n\n\nMas, para os curiosos, vai aqui um spoiler:\n\nO método move (e outros que usaremos da mesma forma) está definido na classe Actor.\nA classe Caranguejo é uma subclasse de Actor.\n\nIsso significa que ela herda os métodos da classe Actor.\nE assim, podemos chamar os métodos da classe Actor dentro da classe Caranguejo como se eles estivessem definidos na própria classe Caranguejo."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-2",
    "href": "greenfoot-tutorial.html#section-2",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Experimente agora colocar dois caranguejos e chamar o método Executar.\n\nOs dois caranguejos fazem a mesma coisa, pois são objetos da mesma classe.\n\n\nExperimente passar valores diferentes para o método move.\n\nVocê pode testar valores menores, maiores e até negativos.\n\n\n\nO método move faz um ator se mover para frente pela quantidade passada.\n\nUm ator sempre começa “olhando” para a direita da tela.\nPortanto, a princípio, ele se move para a direita da tela."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-3",
    "href": "greenfoot-tutorial.html#section-3",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Acrescente agora mais uma linha no método act, de forma que ele fique como mostrado abaixo:\n\n    move(4);\n    turn(3);\n\n\nExecute o jogo, com alguns caranguejos e veja o que acontece.\n\nExperimente passar valores diferentes para o método turn.\n\nMais uma vez, valores maiores, menores e até negativos.\n\n\n\n\nNote que o método turn gira o ator pelo ângulo passado (em graus)."
  },
  {
    "objectID": "greenfoot-tutorial.html#controle-usando-o-teclado",
    "href": "greenfoot-tutorial.html#controle-usando-o-teclado",
    "title": "Tutorial do Greenfoot",
    "section": "Controle usando o teclado",
    "text": "Controle usando o teclado\nFica mais interessante se pudermos controlar o caranguejo.\n\npara isso, podemos usar o método estático isKeyDown da classe Greenfoot.\n\n\nPor exemplo, podemos verificar se a tecla seta para a esquerda está pressionada assim:\n\n    if (Greenfoot.isKeyDown(\"left\")) {\n        // implementamos aqui o que deve acontecer se a tecla seta para\n        // a esquerda estiver pressionada\n    }"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-4",
    "href": "greenfoot-tutorial.html#section-4",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Experimente, por exemplo, implementar o método act conforme mostrado abaixo:\n\nTeste o jogo com um e com vários caranguejos.\nUse seta para a esquerda e seta para a direita para controlar os caranguejos.\n\n\n    public void act() \n    {\n        move(4);\n        \n        if (Greenfoot.isKeyDown(\"left\")) {    \n            turn(-3);   \n        }\n        if (Greenfoot.isKeyDown(\"right\")) {    \n            turn(3);   \n        }\n    }"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-5",
    "href": "greenfoot-tutorial.html#section-5",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Você pode alterar os valores passados para o método turn para mudar o quanto os caranguejos giram.\n\nE pode também alterar as teclas utilizadas para controlar o caranguejo.\nVocê pode usar as letras ou caracteres para indicar as teclas (ex.: \"a\").\n\nOu os nomes das teclas (ex.: \"space\" ou \"control\").\n\n\n\nPara pensar:\n\nComo você pode tratar para que o jogo possa ser jogado tanto nas teclas de direção quanto usando as teclas ASDW?"
  },
  {
    "objectID": "greenfoot-tutorial.html#opcional-controlando-um-carro",
    "href": "greenfoot-tutorial.html#opcional-controlando-um-carro",
    "title": "Tutorial do Greenfoot",
    "section": "Opcional: controlando um carro",
    "text": "Opcional: controlando um carro\nEm casa, tente criar uma classe Carro e controlar os carros da seguinte forma:\n\nUsando seta para cima para acelerar o carro.\nSeta para baixo dar ré no carro.\nSeta para a esquerda para virar o carro para a esquerda.\nSeta para a direita para virar o carro para a esquerda."
  },
  {
    "objectID": "greenfoot-tutorial.html#comendo-larvas",
    "href": "greenfoot-tutorial.html#comendo-larvas",
    "title": "Tutorial do Greenfoot",
    "section": "Comendo larvas",
    "text": "Comendo larvas\nVamos criar uma classe para representar larvas que serão a comida dos caranguejos.\n\nPara isso clique com o botão direito na classe Actor e vá na opção Nova subclasse....\n\n\nNa janela que se abre dê o nome Larva para a classe (lembre-se de usar L maiúsculo).\n\nE escolha a imagem larva.png para representar as larvas.\nAo clicar em OK, a classe Larva aparecerá no diagrama do Greenfoot.\n\n\n\nSe abrir o código da classe verá que ela ainda não faz nada.\n\nMas nós vamos deixar assim.\nAs larvas desse jogo são preguiçosas e só ficam paradas mesmo."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-6",
    "href": "greenfoot-tutorial.html#section-6",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "A ideia agora é modificar a classe Caranguejo para que um caranguejo coma uma larva sempre que passar sobre ela.\n\nPara fazer isso, vamos usar o método getOneIntersectingObject.\n\nPodemos acrescentar o seguinte trecho de código ao final do método act.\n\n\n\n\n    // se o caranguejo estiver colidindo (tocando) uma larva, a larva será\n    // retornada. Se não estiver colidindo com nenhuma, o método retornará null.\n    Actor larva = getOneIntersectingObject(Larva.class);\n    // Se havia colisão com alguma larva\n    if (larva != null) {\n        // Obtemos uma referência (ponteiro) para o mundo\n        World mundo = getWorld();\n        // Removemos a larva do mundo\n        mundo.removeObject(larva);\n    }"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-7",
    "href": "greenfoot-tutorial.html#section-7",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Altere o método act conforme mostrado no slide anterior.\n\nColoque várias larvas e vários caranguejos no mundo.\nE testes as alterações. Conseguiu capturar todas as larvas?"
  },
  {
    "objectID": "greenfoot-tutorial.html#coesão-de-método",
    "href": "greenfoot-tutorial.html#coesão-de-método",
    "title": "Tutorial do Greenfoot",
    "section": "Coesão de método",
    "text": "Coesão de método\nRepare que nosso método act está ficando um pouco confuso.\n\nIsso porque ele agora faz duas coisas: movimenta o caranguejo e o faz comer larvas.\n\n\nComo podemos melhorar isso?\n\nPodemos criar um método movimentar e outro comer.\nLevando para esses métodos os trechos de código que hoje estão no método act.\nO método act passaria então a ter apenas duas linhas:\n\n\n\n\n    public void act() {\n        movimentar();\n        comer();\n    }\n\n\n\nVeja que, com isso, o código fica mais fácil de entender e de se alterar.\n\nMais adiante na disciplina aprofundaremos essa questão, ao estudarmos o conceito coesão de métodos."
  },
  {
    "objectID": "greenfoot-tutorial.html#salvando-o-mundo",
    "href": "greenfoot-tutorial.html#salvando-o-mundo",
    "title": "Tutorial do Greenfoot",
    "section": "Salvando o mundo",
    "text": "Salvando o mundo\nVocê deve ter ficado cansado de tanto colocar caranguejos e larvas no mundo.\n\nMas nós podemos adicionar código para que isso seja feito automaticamente.\nOu melhor ainda, pedir ao Greenfoot para fazer esse código para nós.\n\n\nPara isso, faça o seguinte:\n\nAcrescente alguns caranguejos e algumas larvas no mundo.\nAntes de clicar em Executar, clique com o botão direito no mundo e acesse a opção Salvar o mundo.\n\nO Greenfoot colocará trechos de código na classe do mundo.\nQue criam e posicionam os atores nos mesmos lugares onde você tinha colocado.\nDê uma olhada no código!\n\n\n\n\nDepois disso, toda vez que o mundo for criado, ele já terá os caranguejos e as larvas."
  },
  {
    "objectID": "greenfoot-tutorial.html#tocando-sons",
    "href": "greenfoot-tutorial.html#tocando-sons",
    "title": "Tutorial do Greenfoot",
    "section": "Tocando sons",
    "text": "Tocando sons\nÉ bem simples tocar sons no Greenfoot.\n\nBasta que você tenha um arquivo de som na pasta sounds do seu projeto.\nE use o método estático playSound da classe Greenfoot para tocar o arquivo.\n\n\nO projeto caranguejo já tem um arquivo comendo.wav na pasta sounds.\n\nExperimente então acrescentar uma linha de código na classe Caranguejo, logo após remover uma larva do mundo:\n\nGreenfoot.playSound(\"comendo.wav\");\n\nTeste o jogo!"
  },
  {
    "objectID": "greenfoot-tutorial.html#criando-sons",
    "href": "greenfoot-tutorial.html#criando-sons",
    "title": "Tutorial do Greenfoot",
    "section": "Criando sons",
    "text": "Criando sons\nPara criar seu jogo, você pode procurar por trilha e efeitos sonoros livres e gratuitos na internet.\n\nOu você pode criar seus próprios sons usando o Greenfoot mesmo.\n\n\nPara criar um som, acesse o menu Ferramentas → Mostrar gravador de som....\n\nVocê pode gravar sons e ouvi-los.\nE, ao final, dar um nome para o arquivo e salvar.\n\nDepois, basta usar esse nome de arquivo no código para tocá-lo."
  },
  {
    "objectID": "greenfoot-tutorial.html#criando-sons-1",
    "href": "greenfoot-tutorial.html#criando-sons-1",
    "title": "Tutorial do Greenfoot",
    "section": "Criando sons",
    "text": "Criando sons\nDica:\n\nSilêncios no início ou no final do som podem criar uma experiência desagradável para o jogador.\nVocê pode evitar isso usando o botão Cortar até a seleção.\n\nVocê pode selecionar o trecho do áudio que tem a parte que você quer que fique no arquivo.\nE usar o botão para cortar o áudio, ignorando o que tinha antes e depois da seleção."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-8",
    "href": "greenfoot-tutorial.html#section-8",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Vamos criar uma lagosta que se move em linha reta e que pode comer caranguejos.\n\nCrie uma classe Lagosta clicando com o botão direito em Actor e depois em Nova subclasse....\nEscolha a imagem da lagosta que já existe no projeto.\n\nObs.: quando você quiser usar uma imagem que não tem no Greenfoot, basta colocá-la na pasta images do projeto.\n\n\n\nNas partes anteriores do tutorial já vimos como movimentar um ator e como remover um ator do mundo.\n\nEntão você mesmo pode implementar a ação da lagosta.\nEla deve se movimentar sempre para a direita e,\n\nSe colidir com um caranguejo, o caranguejo deve ser removido do mundo.\nPara ficar mais interessante, grave o seu próprio som e use-o quando isso acontecer."
  },
  {
    "objectID": "greenfoot-tutorial.html#aleatoriedade",
    "href": "greenfoot-tutorial.html#aleatoriedade",
    "title": "Tutorial do Greenfoot",
    "section": "Aleatoriedade",
    "text": "Aleatoriedade\nBom, o jogo ainda está muito fácil. Vamos deixá-lo menos previsível.\n\nA ideia é que as lagostas possam girar a cada hora por um ângulo diferente.\nPodemos fazer isso usando o método estático getRandomNumber da classe Greenfoot.\n\nExemplo: int angulo = Greenfoot.getRandomNumber(90);.\n\nE então usamos o ângulo como parâmetro do método turn.\n\nExemplo: turn(angulo);.\n\nImplemente e teste o jogo.\n\n\nO que achou do resultado?\n\nA lagosta não é um oponente desafiador ainda, certo? :)"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-9",
    "href": "greenfoot-tutorial.html#section-9",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Um dos problemas é que a lagosta gira toda hora, com isso ela fica só rodopiando.\n\nSeria melhor se ela virasse apenas de vez em quando.\nPodemos implementar isso, fazendo com que o método turn não seja chamado toda hora que o act é executado.\n\n\nUma das formas de fazer isso é mostrada abaixo.\n\nExperimente implementar e ver a diferença no comportamento da lagosta.\n\n\n    move(4);\n    if (Greenfoot.getRandomNumber(100) &lt; 10) {\n        int angulo = Greenfoot.getRandomNumber(90);\n        turn(angulo);\n    }"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-10",
    "href": "greenfoot-tutorial.html#section-10",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Mas o que exatamente foi feito?\n\nVeja que o comando Greenfoot.getRandomNumber(100) retorna um número aleatório entre 0 a 99.\nSe esse método for chamado muitas vezes ele vai retornar cada numéro possível a mesma quantidade de vezes (em média).\n\nPortanto, em média, ele retorna 0 em 1% das vezes, retorna 1 em 1% das vezes e assim por diante.\nLogo, ele retorna um valor menor que 10 em 10% das vezes, certo?\n\nCom isso, a expressão do comando if (Greenfoot.getRandomNumber(100) &lt; 10), retornará true, em média, a cada 10 vezes que for chamado.\n\nIsso faz com que cada lagosta se movimente de forma diferente, girando só de vez em quando."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-11",
    "href": "greenfoot-tutorial.html#section-11",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Repare que podemos deixar a lagosta ainda melhor fazendo com que ela possa girar para os dois lados.\n\nComo estamos passando sempre um número positivo, ela está girando sempre para o mesmo lado.\nComo podemos fazê-la girar para os dois lados?\n\n\nPodemos mudar a forma que o ângulo é definido:\n\nAgora teremos valores variando entre 0 - 45 = -45 e 89 - 45 = 44.\n\n\n        int angulo = Greenfoot.getRandomNumber(90) - 45;"
  },
  {
    "objectID": "greenfoot-tutorial.html#section-12",
    "href": "greenfoot-tutorial.html#section-12",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Faça as últimas alterações no seu código e coloque várias lagostas e larvas, e alguns caranguejos no mundo.\n\nNão esqueça de salvar o mundo!\nJogue e veja como a lagosta é agora um inimigo bem mais desafiador.\n\n\nMas você deve ter reparado que a lagosta ainda não sabe lidar bem com as bordas do mundo.\n\nComo podemos melhorar isso?\nBasta acrescentarmos um código para que ela gire 180 graus sempre que chegar perto da borda do mundo.\n\nObs.: você pode chamar o método isAtEdge para verificar se um ator está na borda do mundo."
  },
  {
    "objectID": "greenfoot-tutorial.html#desafio-opcional",
    "href": "greenfoot-tutorial.html#desafio-opcional",
    "title": "Tutorial do Greenfoot",
    "section": "Desafio (Opcional)",
    "text": "Desafio (Opcional)\nComo você poderia fazer um jogo para dois jogadores?\n\nImagine que um jogador utilize as setas do teclado e outro as teclas ASDW.\nCrie uma nova classe no jogo do caranguejo com um animal que possa ser controlado por um segundo jogador.\n\nE faça os tratamentos necessários."
  },
  {
    "objectID": "greenfoot-tutorial.html#section-13",
    "href": "greenfoot-tutorial.html#section-13",
    "title": "Tutorial do Greenfoot",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa aula e envie o código do projeto greenfoot-caranguejo da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap5-3.html#section-12",
    "href": "cap5-3.html#section-12",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Nós podemos definir métodos estáticos usando a palavra-chave static na assinatura do método.\n\nSuponha, por exemplo, que uma classe Calendario tenha o método estático abaixo:\n\n    public static int obterNumeroDeDiasDoMesAtual() {\n        . . .\n    }\n\n\n\nNós poderíamos chamar esse método usando o comando abaixo:\n\nRepare que usamos o nome da classe antes do . para chamar o método, em vez de usar um objeto.\n\n\n    int dias = Calendario.obterNumeroDeDiasDoMesAtual();"
  },
  {
    "objectID": "cap5-3.html#section-13",
    "href": "cap5-3.html#section-13",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Podemos encontrar vários exemplos de métodos estáticos na classe Math do Java.\n\nEla possui métodos, por exemplo, para encontrar o máximo ou o mínimo entre dois números.\n\nOu ainda calcular seno e cosseno, por exemplo.\n\n\n\n\n    int maximo = Math.max(numeroA, numeroB);\n    double valor = Math.cos(angulo);\n\n\n\nRepare que esses métodos dependem apenas dos parâmetros passados.\n\nEles não dependem de atributos de um possível objeto Math, ou seja, não dependem do estado de um objeto.\nGeralmente é nesses casos que usamos métodos estáticos."
  },
  {
    "objectID": "cap5-3.html#section-14",
    "href": "cap5-3.html#section-14",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A classe Math do Java possui também exemplos de uso de constantes.\n\nO valor de PI, por exemplo, pode ser acessado com o comando Math.PI.\nRepare que estamos acessando o atributo diretamente, usando o nome da classe, em vez de um objeto.\n\nDa mesma forma que usamos para chamar métodos estáticos.\n\nNós conseguimos fazer isso porque PI é declarado como uma constante pública.\n\n\nMas não seria uma falha de encapsulamento declarar um atributo público?\n\nNote que não há falha de encapsulamento em declarar um atributo público, se ele for uma constante.\nJá que não seria possível alterar seu valor de fora da classe."
  },
  {
    "objectID": "cap5-3.html#section-15",
    "href": "cap5-3.html#section-15",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Você já usou métodos estáticos antes, sem saber.\n\nRepare como os métodos abaixo são chamados.\n\n\n\nGreenfoot.isKeyDown(\"left\");\n\nGreenfoot.playSound(\"comendo.wav\");\n\nGreenfoot.getRandomNumber(90);\n\n\n\nEm todas essas chamadas nós usamos o nome da classe Greenfoot para chamar o método.\n\nIsso porque todos esses métodos são estáticos.\nTodos eles implementam ações que dependem apenas dos parâmetros passados\n\n(não dependem do estado de um objeto)."
  },
  {
    "objectID": "cap5-3.html#section-16",
    "href": "cap5-3.html#section-16",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\nAltere a declaração do atributo GRAVIDADE da classe Bola de forma que ele não seja mais uma constante. Mas, mantenha a inicialização do atributo na declaração.\nCrie um método modificador que permita alterar o valor do atributo.\nExecute o programa e pause-o antes das bolas pararem de quicar. Clique em uma das bolas e chame o método que você criou, informando um novo valor para a gravidade.\nContinue a execução do programa e repare que acontece. A gravidade foi alterada só para a bola que você chamou o método, ou para todas elas?\nDepois que as bolas pararem, pause o programa novamente, e use a opção Inspecionar em cada bola para conferir o valor do atributo GRAVIDADE. (Obs.: na janela de inspeção, use o botão mostrar campos estáticos)."
  },
  {
    "objectID": "cap5-3.html#section-17",
    "href": "cap5-3.html#section-17",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Na segunda parte da aula, faremos um exercício que nos permitirá comparar o uso de ArrayList e HashMap.\n\nNo capítulo anterior, fizemos um exercício que tratava do estoque de produtos.\nOs produtos eram guardados em um ArrayList.\nE, em várias situações, precisávamos encontrar um produto pelo seu identificador.\n\n\nRepare que, nesse contexto, podemos tratar a coleção de produtos como pares de objetos identificador-produto.\n\nOu seja, como pares de objetos chave-valor.\nQue é justamente o que um HashMap faz.\nPortanto, nos exercícios a seguir vamos alterar o projeto para trabalhar com HashMap em vez de ArrayList."
  },
  {
    "objectID": "cap5-3.html#section-18",
    "href": "cap5-3.html#section-18",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\n\nBaixe o projeto produtos que você entregou como exercício na aula prática do capítulo anterior e renomeie a pasta do projeto para produtos-com-hashmap.\nAltere o projeto substituindo o uso de ArrayList por HashMap.\n\nComo citado no slide anterior, a ideia é que o HashMap guarde entradas tendo o identificador do produto como chave e o produto como valor.\nPlaneje as alterações a serem feitas antes de realmente alterar o código.\nPense em como a implementação pode ser feita com o mínimo de alterações.\n\nTeste suas alterações (teste todos os métodos que tinha implementado)!"
  },
  {
    "objectID": "cap5-3.html#section-19",
    "href": "cap5-3.html#section-19",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\n\nCompare o código do projeto produtos com o código do projeto produtos-com-hashmap.\nVocê viu alguma vantagem em utilizar HashMap em vez de ArrayList?\n\nSe você tivesse começando o projeto do zero, você acha que seria melhor usar HashMap desde o início? Por quê?\n\nEscreva sua resposta no comentário javadoc da classe GerenciadorDeEstoque do projeto produtos-com-hashmap."
  },
  {
    "objectID": "cap5-3.html#section-20",
    "href": "cap5-3.html#section-20",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "No projeto produtos-com-hashmap como você tratou a versão sobrecarregada do método encontrarProduto que recebe o nome do produto por parâmetro?\n\nProvavelmente, você implementou um loop para percorrer as chaves do HashMap e verificou o nome do produto, certo?\nVocê acha que existe alguma forma mais eficiente de fazer isso?\n\n\nPense sobre isso antes de continuar."
  },
  {
    "objectID": "cap5-3.html#section-21",
    "href": "cap5-3.html#section-21",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Repare que quando usamos um HashMap, se quisermos encontrar um valor a partir de uma chave, nós não precisamos implementar um loop.\n\nNós podemos simplesmente usar o método get.\n\n\nÉ interessante que você saiba que isso não é apenas uma questão de ficar mais fácil para implementar.\n\nUm ponto importante é que o método get de um HashMap é muito mais eficiente do que um loop que percorre todos os elementos de uma coleção.\n\nPense, por exemplo, em um estoque com milhares de produtos.\n\nÉ mais eficiente porque o HashMap usa uma estrutura de dados chamada tabela Hash que otimiza a busca de valores a partir de chaves.\n\nVocê aprenderá sobre isso na disciplina de Estrutura de Dados.\n\nMas, por enquanto, basta que saiba que um programa será mais rápido se usar get em vez de um loop em um ArrayList, por exemplo."
  },
  {
    "objectID": "cap5-3.html#section-22",
    "href": "cap5-3.html#section-22",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Sabendo disso, como você poderia implementar, de forma mais eficiente, o método encontrarProduto que recebe o nome do produto por parâmetro?\n\nPense um pouco antes de continuar.\n\n\nVocê talvez tenha pensado que se tivermos um HashMap que use o nome do produto como chave e o produto como valor,\n\npoderíamos simplesmente usar o método get do HashMap para encontrar o produto.\nO que tornaria a busca mais rápida.\n\n\n\nMas se substituirmos o HashMap que temos até agora, que usa o identificador como chave,\n\nteríamos que voltar a fazer um loop na outra versão do método encontrarProduto que recebe o identificador por parâmetro.\n\n\n\nO que poderíamos fazer então?"
  },
  {
    "objectID": "cap5-3.html#section-23",
    "href": "cap5-3.html#section-23",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "A solução nesse caso seria ter dois objetos HashMap:\n\nUm que use o identificador como chave e outro que use o nome do produto como chave.\nAssim, poderíamos usar um HashMap para buscar produtos pelo identificador e outro para buscar pelo nome.\n\n\nRepare que essa é uma solução de compromisso (trade-off).\n\nNós estamos usando mais memória do computador (para guardar um segundo HashMap).\nMas com a vantagem de tornar nosso programa mais eficiente (mais rápido).\nEm um sistema com muitos produtos, a diferença de eficiência pode ser significativa."
  },
  {
    "objectID": "cap5-3.html#section-24",
    "href": "cap5-3.html#section-24",
    "title": "IPOO - Cap. 5 Comportamento Mais Sofisticado",
    "section": "",
    "text": "Exercício\n\n\n\nAltere o projeto produtos-com-hashmap para que ele tenha dois objetos HashMap:\n\nUm que use o identificador como chave e outro que use o nome do produto como chave.\nAltere o método encontrarProduto que recebe o nome do produto por parâmetro para usar o HashMap que usa o nome do produto como chave.\nE, claro, lembre-se de tratar o segundo HashMap no método adicionarProduto.\n\nTeste suas alterações!"
  },
  {
    "objectID": "cap10-1.html#principais-conceitos-da-aula",
    "href": "cap10-1.html#principais-conceitos-da-aula",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "Principais Conceitos da Aula",
    "text": "Principais Conceitos da Aula\n\nClasses Abstratas\nInterfaces\nHerança Múltipla\n\n\nConstruções Java do capítulo\n\nabstract, implements, interface\n\n\n\nNesta aula vamos aprofundar nas técnicas relacionadas a herança que podem ser usadas para melhorar a estrutura das classes e aumentar a manutenibilidade e extensibilidade do código.\n\nVeremos um projeto de exemplo que aborda uma simulação e com ele discutiremos novamente os conceitos de herança, polimorfismo, classes abstratas e interfaces."
  },
  {
    "objectID": "cap10-1.html#section",
    "href": "cap10-1.html#section",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Estes slides se baseiam no Cap. 10 do livro do Barnes e Kölling.\n\n\n\n\n\n\n\n\n\n\nA diferença é que o livro apresenta os conceitos de classe abstrata, método abstrato e interface neste capítulo, já estes slides consideram que esses conceitos já foram apresentados.\nAlém disso, ele se baseia em um projeto a ser executado no VS Code, enquanto o livro se baseia no BlueJ.\n\n\n\n\nDica: vale a pena estudar pelo livro, porque ele apresenta bem mais detalhes do que os apresentados aqui."
  },
  {
    "objectID": "cap10-1.html#section-1",
    "href": "cap10-1.html#section-1",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "É muito comum usarmos computadores para simularmos fenômenos do mundo real.\n\nAlguns exemplos são sistemas que:\n\nmodelam o tráfego em uma cidade\nmodelam a previsão do tempo\nsimulam o espalhamento de uma doença\nanalisam o mercado de ações de uma bolsa de valores\ne muitos outros.\n\n\n\nQualquer simulação faz uso das técnicas de abstração, pois tenta modelar o comportamento de um subconjunto do mundo real.\n\nDecidir quais detalhes devem ser incluídos é geralmente um desafio.\nMais detalhes podem levar a uma simulação mais precisa, mas que requer mais esforço de programação e mais equipamento e tempo de execução."
  },
  {
    "objectID": "cap10-1.html#section-2",
    "href": "cap10-1.html#section-2",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "De todo modo, simulações são muito úteis pois permitem fazer o que muitas vezes não conseguimos no mundo real.\n\nSeja porque não temos controle sobre o comportamento real (ex.: clima).\nOu porque é muito caro, ou muito perigoso.\n\n\nA ideia de uma simulação é então experimentar cenários para responder perguntas do tipo “e se”.\n\nUm exemplo seria tentar investigar o efeito da ação humana em habitats naturais.\nImagine a construção de uma rodovia no meio de uma reserva ecológica, por exemplo.\nComo isso afeta a fauna e flora do local?\nFaz diferença dividir a reserva em duas partes? Muda alguma coisa para os animais que vivem ali?"
  },
  {
    "objectID": "cap10-1.html#section-3",
    "href": "cap10-1.html#section-3",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Nesta aula vamos trabalhar em um projeto inspirado nessa ideia de simular o comportamento de animais em um habitat natural.\n\nMas, como o objetivo é ilustrar conceitos de design e implementação OO, vamos tratar uma simulação bem simplificada.\nDe todo modo, nem sempre uma simulação mais complexa leva a um resultado mais preciso.\nMuitas vezes, uma simulação mais simples pode ser mais útil."
  },
  {
    "objectID": "cap10-1.html#section-4",
    "href": "cap10-1.html#section-4",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "O projeto que vamos usar de exemplo é uma simulação do tipo predador-presa.\n\nEsse tipo de simulação é muito comum em biologia, e é usado para estudar a variação no tamanho das populações de predadores e presas.\nUma grande população de presas fornece comida para uma pequena população de predadores.\nMas, se a população de predadores crescer demais, a população de presas pode diminuir muito (ou até desaparecer).\nAlém disso, o tamanho do habitat natural também influencia o tamanho das populações, pois pode facilitar ou dificultar que os predadores encontrem suas presas.\n\n\nO projeto que vamos usar segue a mesma ideia do World of Zuul que trabalhamos nas aulas de Design de Classes,\n\nno sentido de que é um projeto que funciona corretamente do ponto de vista do usuário;\n\nmas que tem problemas de design e implementação.\n\nEspecialmente por não utilizar os conceitos de herança que vimos nas últimas aulas."
  },
  {
    "objectID": "cap10-1.html#section-5",
    "href": "cap10-1.html#section-5",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "O projeto raposas-e-coelhos-v1 está disponível no repositório do curso.\n\nO diagrama abaixo mostra as classes do projeto."
  },
  {
    "objectID": "cap10-1.html#section-6",
    "href": "cap10-1.html#section-6",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "As principais classes que vamos focar são Simulador, Raposa e Coelho.\n\nAs classes Raposa e Coelho representam o comportamento do predador e da presa, respectivamente.\nTrataremos principalmente os aspectos que afetam o tamanho de suas populações: nascimento, morte e fornecimento de comida."
  },
  {
    "objectID": "cap10-1.html#section-7",
    "href": "cap10-1.html#section-7",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "A classe Simulador é responsável por criar o estado inicial da simulação, controlá-la e executá-la.\n\nA ideia básica é simples:\n\no simulador tem coleções de coelhos e raposas.\na cada passo da simulação, a classe permite que cada animal possa viver por um passo de seu ciclo de vida.\n\nnão estamos preocupados sobre quanto tempo significa um passo aqui.\n\ne então o estado atual do campo é mostrado na tela."
  },
  {
    "objectID": "cap10-1.html#section-8",
    "href": "cap10-1.html#section-8",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Resumidamente, o objetivo das demais classes é:\n\nCampo representa um campo de duas dimensões onde os animais vivem.\n\nO campo é formado por um número fixo de localizações (células), arranjadas em linhas e colunas.\nApenas um animal pode ocupar uma localização por vez.\nUma localização pode estar vazia ou ocupada por um animal.\n\nLocalizacao representa uma célula dentro do campo, definida por um valor de linha e um de coluna.\nAs classes Simulador, Raposa, Coelho, Campo e Localizacao definem completamente o comportamento da simulação.\n\nAs demais classes são acessórias."
  },
  {
    "objectID": "cap10-1.html#section-9",
    "href": "cap10-1.html#section-9",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "A classe Randomizador nos permite ter um certo grau de controle sobre a aleatoriedade da simulação.\n\nEx.: quando os animais nascem.\n\nAs classes VisaoSimulador, EstatisticasCampo e Contador fornecem uma visualização gráfica da simulação.\n\nVisaoSimulador exibe uma visualização do estado do campo.\nEstatisticasCampo mostra as quantidades de coelhos e raposas.\nContador é uma classe auxiliar que trata a contagem dos animais."
  },
  {
    "objectID": "cap10-1.html#section-10",
    "href": "cap10-1.html#section-10",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nInicie o projeto raposas-e-coelhos-v1. Você verá o estado inical da simulação. Os retângulos em maior número representam os coelhos e os demais as raposas.\nAcione o botão Simular um Passo. O número de raposas se altera se você aciona o botão apenas uma vez?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nO número de raposas se altera a cada passo da simulação?\nQuais processos naturais vocês acha que estão sendo modelados para fazer o número de raposas aumentar ou diminuir?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAcione agora o botão Simular Vários Passos e escolha uma grande quantidade de passos (como 80 ou 100).\nO número de raposas e coelhos aumentam ou diminuem na mesma taxa?"
  },
  {
    "objectID": "cap10-1.html#section-11",
    "href": "cap10-1.html#section-11",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nQuais mudanças vocês nota ao executar o botão de Simulação Longa?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAcione o botão Reiniciar para criar um novo estado inicial para a simulação e rode a simulação novamente.\nA simulação é exatamente igual dessa vez? Se não é, você nota algum padrão similar entre as execuções?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nSe você executa a simulação por tempo suficiente, acontece de todas as raposas ou coelhos morrerem?\nEm caso afirmativo, por que você acha que isso acontece?"
  },
  {
    "objectID": "cap10-1.html#a-classe-coelho",
    "href": "cap10-1.html#a-classe-coelho",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A classe Coelho",
    "text": "A classe Coelho\nAbra o código da classe Coelho.\n\nVocê notará que a classe tem vários atributos estáticos que definem as configurações de todos os coelhos.\nO controle de aleatoriedade é centralizado através de um único objeto Random fornecido pela classe Randomizador.\n\nIsso permite a repetibilidade dos testes da simulação.\n\nCada coelho tem quatro atributos comuns (não estáticos), que descrevem seu estado.\n\nidade (dada pelo número de passos), se está vivo ou não, e sua localização específica no campo.\n\nVocê notará também as simplificações feitas na simulação e como a aleatoriedade é tratada."
  },
  {
    "objectID": "cap10-1.html#a-classe-raposa",
    "href": "cap10-1.html#a-classe-raposa",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A classe Raposa",
    "text": "A classe Raposa\nAbra o código da classe Raposa.\n\nVocê verá que ele tem muitas similaridades com a classe Coelho.\nAs diferenças se referem, principalmente, aos comportamentos de cacar (caçar) e buscarComida."
  },
  {
    "objectID": "cap10-1.html#section-12",
    "href": "cap10-1.html#section-12",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nO botão Reiniciar Randomizador chama o método reiniciar da classe Randomizador e também da classe Simulador. Isso faz com que a simulação seja exetamente igual à primeira simulação executada.\nVerifique o código da classe Randomizador e a documentação da classe java.util.Random para entender porque isso acontece."
  },
  {
    "objectID": "cap10-1.html#a-classe-simulador",
    "href": "cap10-1.html#a-classe-simulador",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A classe Simulador",
    "text": "A classe Simulador\nVamos agora analisar o código da classe Simulador.\n\nEla é peça principal do sistema, pois ela controla todas as outras partes.\nAs principais partes são o construtor e os métodos povoar e simularUmPasso.\nRepare que o método povoar criaos amimais com idades aleatórias.\n\nIsso representa mais corretamente uma população variada que seria um estado normal da simulação.\nAlém disso, se todos os animais começassem recém-nascidos, até que eles tivessem idade para se reproduzir, pode ser que os coelhos fossem todos caçados ou as raposas morressem de fome.\n\nO método simularUmPasso é o responsável por fazer a simulação de um passo."
  },
  {
    "objectID": "cap10-1.html#section-13",
    "href": "cap10-1.html#section-13",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nVocê acha que não ter um atributo gênero, para indicar se o coelho é macho ou fêmea, provavelmente leva a uma simulação imprecisa?\nJustifique sua resposta.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nVocê acha que há outras simplificações na implementação da classe Coelho em relação ao mundo real?\nDiscuta se isso poderia impactar na precisão da simulação.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente alterar alguns dos atributos da classe Coelho e verifique como isso impacta o comportamento da simulação.\nPor exemplo: o que acontece se a probabilidade de reprodução for muito maior ou muito menor?"
  },
  {
    "objectID": "cap10-1.html#a-classe-simulador-1",
    "href": "cap10-1.html#a-classe-simulador-1",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A classe Simulador",
    "text": "A classe Simulador\nAvalie agora o código da classe simularUmPasso.\n\nRepare que não estamos usando herança nesta implementação.\nRepare também como são tratadas as listas de coelhos e raposas (e como elas são atualizadas com os recém-nascidos)."
  },
  {
    "objectID": "cap10-1.html#começando-a-melhorar-a-simulação",
    "href": "cap10-1.html#começando-a-melhorar-a-simulação",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "Começando a melhorar a simulação",
    "text": "Começando a melhorar a simulação\nAgora que entendemos como a simulação funciona, já podemos começar a melhorar o design e a implementação do projeto.\n\nFaremos isso passo a passo.\nPoderíamos começar por vários pontos, mas um ponto fraco óbvio do design atual é que ele não usa herança.\n\nQue poderia evitar diversas replicações de código entre as classes Coelho e Raposa."
  },
  {
    "objectID": "cap10-1.html#section-14",
    "href": "cap10-1.html#section-14",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nAssim como foi feito para os coelhos, avalise se as simplificações implementadas na classe Raposa podem levar a uma simulação imprecisa.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nSe aumentarmos a idade máxima das raposas, você acha que a população das raposas vai aumentar, ou é mais provável que a população de coelhos seja reduzida a zero?\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExperimente diferentes valores para os atributos das classes Coelho e Raposa.\nAlguma espécie sempre desaparece em alguma configuração específica?\nHá configurações que são mais estáveis, ou seja, geram um equilíbrio entre as populações por mais tempo?"
  },
  {
    "objectID": "cap10-1.html#section-15",
    "href": "cap10-1.html#section-15",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nExperimente alterar o método main da classe App, chamando o construtor sobrecarregado da classe Simulador para definir campos de tamanhos diferentes.\nO tamanho do campo afeta a probabilidade das espécies sobreviverem?\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAtualmente, uma raposa come no máximo um coelho em cada passo.\nModifique o método buscarComida para que os coelhos em todos os locais vizinhos sejam comidos em um único passo. Avalie o impacto dessa alteração nos resultados da simulação.\nObserve que o método buscarComida atualmente retorna a localização do único coelho que é comido, portanto, você precisará retornar a localização de um dos coelhos comidos na sua versão.\nNo entanto, não se esqueça de retornar null se não houver coelhos para comer."
  },
  {
    "objectID": "cap10-1.html#section-16",
    "href": "cap10-1.html#section-16",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nSeguindo o exercício anterior, se uma raposa comer vários coelhos de uma só vez, existem diversas possibilidades de como podemos modelar seu nível de comida.\nSe somarmos todos os valores de comida dos coelhos, a raposa terá um nível de comida muito alto, tornando improvável que ela morra de fome tão cedo.\nAlternativamente, poderíamos impor um limite ao nível de comida da raposa. Isso modela o efeito de um predador que mata a presa independentemente de estar com fome ou não.\nAltere o código para tratar esse limite e avalie os impactos da implementação dessa escolha na simulação resultante."
  },
  {
    "objectID": "cap10-1.html#section-17",
    "href": "cap10-1.html#section-17",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nExperimente alterar o método povoar para que os coelhos e raposas comecem com idade inicial zero.\nExecute várias simulações e verifique se isso é sempre catastrófico.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nSe apenas os coelhos tiverem uma idade inicial aleatória, a população de coelhos tenderá a crescer, enquanto a população de raposas permanecerá muito pequena.\nQuando as raposas atingirem idade suficiente para se reproduzir, a simulação tende a se comportar novamente como a versão original?\nO que isso sugere sobre os tamanhos relativos das populações iniciais e seu impacto no resultado da simulação?"
  },
  {
    "objectID": "cap10-1.html#section-18",
    "href": "cap10-1.html#section-18",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nIdentifique as semelhanças e diferenças entre as classes Coelho e Raposa.\nFaça listas separadas dos atributos, métodos e construtores e diferencie entre os atributos estáticos e ​​de instância.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nMétodos idênticos nas subclasses são claramente candidatos a serem levados para uma superclasse.\nQuais métodos são realmente idênticos nas classes Coelho e Raposa? Para chegar a uma conclusão, considere:\n\nse faz diferença a flexão de gênero (como vivo ou viva);\ncomo se os valores dos atributos estáticos fossem usados diretamente no código."
  },
  {
    "objectID": "cap10-1.html#section-19",
    "href": "cap10-1.html#section-19",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nNa versão atual da simulação, os valores de todos os atributos estáticos com nomes semelhantes são diferentes.\nSe os dois valores de um atributo estático específico (como IDADE_REPRODUCAO, por exemplo) fossem idênticos, isso faria alguma diferença na sua avaliação de quais métodos são realmente idênticos?"
  },
  {
    "objectID": "cap10-1.html#a-superclasse-animal",
    "href": "cap10-1.html#a-superclasse-animal",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A superclasse Animal",
    "text": "A superclasse Animal\nVamos começar levando para a classe Animal aquilo que é idêntico nas duas subclasses.\n\nVamos levar os atributos vivo(a), localizacao e campo para a superclasse.\n\nO atributo idade discutiremos mais adiante.\nOs atributos serão criados com visibilidade privada para respeitar o encapsulamento.\nO atributo vivo será inicializado com true no construtor, e os demais serão passados pelas subclasses usando super."
  },
  {
    "objectID": "cap10-1.html#section-20",
    "href": "cap10-1.html#section-20",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Nós já conhecemos os conceitos de herança e polimorfismo\n\nE, por isso, sabemos que como Coelho e Raposa têm muitas características em comum,\n\nelas podem ser tornar subclasse de uma classe chamada Animal, por exemplo.\n\nVamos agora começar a fazer modificações para melhorar o design e a implementação do sistema.\nNós já sabemos que, pelo polimorfismo, evitaremos replicação de código\n\ne simplificaremos o código da classe Simulador, que usa as classes Coelho e Raposa.\n\n\n\nÉ importante ressaltar que vamos realizar um processo de refatoração que não deve alterar o comportamento do sistema do ponto de vista do usuário final."
  },
  {
    "objectID": "cap10-1.html#a-superclasse-animal-1",
    "href": "cap10-1.html#a-superclasse-animal-1",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A superclasse Animal",
    "text": "A superclasse Animal\nOs métodos de acesso e modificadores desses atributos devem também ser levados para superclasse.\n\nMas qual deve ser a visibilidade deles?\ndefinirLocalizacao é privado em Coelho e Raposa, mas não pode permanecer privado em Animal pois é usado por métodos que estão nas subclasses.\n\nDevemos definir então como protected.\n\nmorrer era público em Coelho mas privado em Raposa. Deveria ser público em Animal?\n\nSó era público em Coelho porque Raposa precisava chamar o método.\nAgora que as classes são irmãs, o método pode ser protected, indicando que ele não faz parte da interface geral dos animais (pelo menos até agora)."
  },
  {
    "objectID": "cap10-1.html#section-21",
    "href": "cap10-1.html#section-21",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Uma tarefa importante quando refatoramos um sistema é planejar testes que garantam que o sistema continua funcionando como antes do ponto de vista do usuário.\n\nA classe Randomizador existe para ajudar nesse processo.\nPois sabemos que, ao reiniciar o randomizador, o comportamento da simulação é sempre o mesmo.\nAssim, podemos implementar a classe Animal em uma cópia do projeto e comparar as simulações antes e depois das alterações."
  },
  {
    "objectID": "cap10-1.html#a-superclasse-animal-2",
    "href": "cap10-1.html#a-superclasse-animal-2",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "A superclasse Animal",
    "text": "A superclasse Animal\nOutro ponto importante sobre a classe Animal é que nós nunca vamos instanciar um objeto dessa classe.\n\nPortanto, sabemos que ela deve ser abstrata.\n\n\n\n\n\n\nConceito\n\n\nUma classe abstrata é uma classe que não é criada para ser instanciada. Seu propósito é servir como uma superclasse para outras classes. Classes abstratas podem conter métodos abstratos."
  },
  {
    "objectID": "cap10-1.html#section-22",
    "href": "cap10-1.html#section-22",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nCrie a classe Animal em uma cópia do projeto de acordo com o que foi apresentado anteriormente.\nGaranta que a simulação continua funcionando como antes do ponto de vista do usuário.\n\n\n\n\n\n\n\n\nExercício\n\n\nDiscuta sobre como o conceito de herança melhorou o projeto até agora."
  },
  {
    "objectID": "cap10-1.html#section-23",
    "href": "cap10-1.html#section-23",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Até agora a superclasse Animal ajudou a evitar replicação de código nas subclasses Coelho e Raposa.\n\nE também tornou mais fácil incluir um novo tipo de animal na simulação, se necessário.\n\n\nMas nós já samos que o uso inteligente de herança ajudaria a simplificar também o código da classe cliente,\n\nou seja, da classe que usa a hierarquia de herança, que, nesse caso, é a classe Simulador."
  },
  {
    "objectID": "cap10-1.html#section-24",
    "href": "cap10-1.html#section-24",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "A classe Simulador tem uma lista separada para cada espécie de animal.\n\nE sabemos que, com o polimorfismo, podemos usar uma única lista para armazenar todos os animais.\n\n\nMas surge um problema na hora de fazer isso, ao tratar o método simularUmPasso.\n\nNós ainda precisamos trabalhar com tipos específicos de animais para saber qual método devemos chamar.\nJá que, para os coelhos deve ser chamado o método correr,\n\ne para as raposas o método cacar.\n\nUma maneira tratar isso é usar instanceof e type casting.\n\nMas esse é um sinal de que não estamos aproveitando tudo que a herança pode nos oferecer.\n\n\n\n\nQue solução melhor poderíamos adotar?"
  },
  {
    "objectID": "cap10-1.html#section-25",
    "href": "cap10-1.html#section-25",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Poderíamos criar um método na superclasse Animal e sobrescrevê-lo nas subclasses,\n\nde forma que uma chamada ao método polimórfico faria com que cada animal agisse de forma diferente.\n\n\nEssa é uma técnica de refatoração padrão para esses casos\n\nnos quais nós temos um comportamento que é específico dos subtipos,\nmas que precisa ser chamado de um contexto que lida apenas com o supertipo."
  },
  {
    "objectID": "cap10-1.html#section-26",
    "href": "cap10-1.html#section-26",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Nós podemos então criar um método chamado agir na superclasse Animal e sobrescrevê-lo nas subclasses.\n\nE renomear os métodos de ação específicos (correr em Coelho e cacar em Raposa) para agir.\nDessa forma, em vez da simulação dizer a cada animal exatamente o que fazer,\n\nestamos apenas dizendo a ele para agir,\ne deixando que o próprio animal decida exatamente o que quer fazer.\n\n\n\nDessa forma, estamos reduzindo o acoplamento entre a classe Simulador e as subclasses Coelho e Raposa."
  },
  {
    "objectID": "cap10-1.html#section-27",
    "href": "cap10-1.html#section-27",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "E o que seria implementado no método agir da classe Animal?\n\nNão temos nada a implementar, certo? Como o método deve ser definido então?\nComo um método abstrato.\n\n\n\n\n\n\nConceito\n\n\nUma método abstrato possui apenas assinatura e não tem um corpo. Ele é marcado com a palavra-chave abstract.\n\n\n\n\n\n\n\n\n\n\nConceito\n\n\nSubclasse abstrata. Para que uma subclasse de uma classe abstrata se torne concreta, ela deve fornecer implementações para todos os métodos abstratos herdados. Caso contrário, a própria subclasse será abstrata."
  },
  {
    "objectID": "cap10-1.html#section-28",
    "href": "cap10-1.html#section-28",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nAltere o projeto incluindo o método agir conforme discutido anteriormente.\nObs.: como agora todos os animais fazem parte de uma única lista, e o sistema possui aleatoriedade, a ordem que os animais agem não vai mais ser a mesma de antes dessa alteração. Portanto, não é mais possível comparar exatamente duas simulações (antes e depois das alterações) como fizemos anteriormente.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExplique porque não seria possível implementar de forma adequada o método agir se a lista de animais guardasse objetos do tipo Object em vez de Animal.\n\n\n\n\n\n\n\n\n\n\nExercício\n\n\nExplique como o método simularUmPasso da classe Simulador utiliza o conceito de polimorfismo.\nEm sua resposta, inclua os conceitos de variável polimórfica, tipo estático, tipo dinâmico, dynamic dispatch e polimorfismo de método."
  },
  {
    "objectID": "cap10-1.html#section-29",
    "href": "cap10-1.html#section-29",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "As últimas alterações que fizemos no simulador removeram as dependências (acoplamentos) do método simularUmPasso com as classes Coelho e Raposa.\n\nA classe Simulador, no entanto, ainda está acoplada às classes Coelho e Raposa, porque essas classes são referenciadas no método povoar.\nNão há como evitar isso, pois quando criamos instâncias de animais, precisamos especificar exatamente que tipo de animal criar.\n\n\nMas isso poderia ser melhorado dividindo Simulador em duas classes:\n\numa classe, Simulador, que executa a simulação e é completamente desacoplada das classes concretas de animais,\ne outra classe, GeradorDePopulacoes (criada e chamada pelo simulador), que cria a população.\n\nSomente esta classe está acoplada às classes concretas de animais, facilitando para um programador de manutenção encontrar pontos onde a mudança é necessária quando o aplicativo for estendido (quando for incluída uma nova espécie de animal, por exemplo)."
  },
  {
    "objectID": "cap10-1.html#section-30",
    "href": "cap10-1.html#section-30",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nTente implementar a refatoração citada, criando a classe GeradorDePopulacoes."
  },
  {
    "objectID": "cap10-1.html#section-31",
    "href": "cap10-1.html#section-31",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "O projeto raposas-e-coelhos-v2, disponível no repositório do curso, tem as melhorias de design e alterações que discutimos até agora.\n\nMas atenção: a melhor maneira de estudar esse material é tentar implementar as mudanças você mesmo no projeto raposas-e-coelhos-v1 e só depois comparar com o projeto raposas-e-coelhos-v2.\nEstudar apenas lendo o código pronto não é uma boa prática, pois o aprendizado não é o mesmo.\nÉ muito mais efetivo aprender fazendo do que apenas lendo."
  },
  {
    "objectID": "cap10-1.html#section-32",
    "href": "cap10-1.html#section-32",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "O repositório do curso também tem o projeto raposas-e-coelhos-v2-grafico.\n\nEsse projeto tem a mesma modelagem de simulação do projeto v2.\nMas acrescenta um gráfico de acompanhamento da simulação."
  },
  {
    "objectID": "cap10-1.html#section-33",
    "href": "cap10-1.html#section-33",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Quando identificamos as características comuns entre as classes Coelho e Raposa, para criar a classe Animal, nós adiamos o tratamento do atributo idade e dos métodos associados a ele.\n\nA princípio, parece que seria muito simples ter levado o atributo para a classe Animal, criado um método de acesso e levado o método modificador incrementarIdade.\nO problema é que o método incrementarIdade depende do atributo estático IDADE_MAXIMA, que, apesar do mesmo nome, tem valores diferentes nas duas subclasses.\n\nPortanto, não dá para simplesmente levar o atributo IDADE_MAXIMA para a superclasse.\n\n\n\nSerá que seria possível sobrescrever um atributo?\n\nPara os próximos exercícios, use o projeto raposas-e-coelhos-v2-grafico como base."
  },
  {
    "objectID": "cap10-1.html#section-34",
    "href": "cap10-1.html#section-34",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Quando identificamos as características comuns entre as classes Coelho e Raposa, para criar a classe Animal, nós adiamos o tratamento do atributo idade e dos métodos associados a ele.\n\nA princípio, parece que seria muito simples ter levado o atributo para a classe Animal, criado um método de acesso e levado o método modificador incrementarIdade.\nO problema é que o método incrementarIdade depende do atributo estático IDADE_MAXIMA, que, apesar do mesmo nome, tem valores diferentes nas duas subclasses.\n\nPortanto, não dá para simplesmente levar o atributo IDADE_MAXIMA para a superclasse.\n\n\n\nSerá que seria possível sobrescrever um atributo?\n\nPara os próximos exercícios, use o projeto raposas-e-coelhos-v2-grafico como base."
  },
  {
    "objectID": "cap10-1.html#section-35",
    "href": "cap10-1.html#section-35",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nLeve o atributo idade das subclasses para a classe Animal. Para isso, será necessário:\n\nAlterar os construtores das subclasses para que a inicialização completa da idade seja tratada na superclasse.\n\nCom isso a classe animal vai precisar também de uma atributo randomizador.\n\nCriar um método de acesso para o atributo idade na superclasse, com visibilidade protected.\nLevar o método incrementarIdade para a superclasse.\n\nA questão é que para o método incrementarIdade compilar na classe Animal precisaremos definir um atributo estático IDADE_MAXIMA na superclasse.\n\nSerá o que acontece se esse atributo existir na superclasse e nas subclasses? Funciona como uma sobrescrita dos métodos?\nPara verificar isso, define IDADE_MAXIMA com valor 1 na superclasse Animal e execute a simulação.\nO que acontece com a simulação?"
  },
  {
    "objectID": "cap10-1.html#section-36",
    "href": "cap10-1.html#section-36",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Vimos que a simulação para no passo 2, pois todos os animais morrem.\n\nIsso aconteceu porque não existe sobrescrita de atributos.\nAssim, o valor usado para definir a idade dos animais foi aquele definido na classe Animal (e era 1).\n\n\nJá que a sobrescrita funciona apenas para métodos, e se criássemos um método estático para retornar a idade máxima e tentarmos sobrescrever esse método nas subclasses?"
  },
  {
    "objectID": "cap10-1.html#section-37",
    "href": "cap10-1.html#section-37",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nCrie um método estático na superclasse Animal e nas subclasses Coelho e Raposa para retornar o atributo IDADE_MAXIMA.\nO código dos métodos será exatamente igual, mas precisamos disso porque apesar dos atributos terem o mesmo nome (IDADE_MAXIMA), sabemos que são três atributos diferentes (um de cada classe).\nExecute a simulação e verifique se o problema foi resolvido."
  },
  {
    "objectID": "cap10-1.html#section-38",
    "href": "cap10-1.html#section-38",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Veja que, mais uma vez, a simulação termina no passo 2 com todos os animais mortos.\n\nMas por que isso aconteceu?\n\n\nA questão é que também não existe sobrescrita de métodos estáticos.\n\nIsso acontece porque é o compilador que decide o método a ser chamado (no caso de métodos estáticos).\n\n\n\nO que podemos fazer então?"
  },
  {
    "objectID": "cap10-1.html#section-39",
    "href": "cap10-1.html#section-39",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nExperimente remover a palavra-chave static do método que retorna a idade máxima e executar a simulação.\n\n\n\n\n\nVeja que agora a idade máxima retornada é a da subclasse, o que resolve o problema.\n\nMas, da forma que ficou, veja que a implementação do método na superclasse Animal é inútil.\n\nBem como a declaração do atributo IDADE_MAXIMA na superclasse.\n\n\n\n\n\n\n\n\nExercício\n\n\nRemova o atributo IDADE_MAXIMA da superclasse Animal.\nO método que retornava o atributo pode ser removido da classe Animal?\n\nSe não puder, como ele deve ser declarado?"
  },
  {
    "objectID": "cap10-1.html#section-40",
    "href": "cap10-1.html#section-40",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nLeve os métodos podeProcriar e procriar para superclasse Animal.\nNesse processo você dever criar os métodos necessários para garantir que os valores idade de reprodução, a probabilidade de reprodução e o tamanho máximo de ninhada, efetivamente usados, sejam os das subclasses.\nReflita sobre o nível de visibilidade adequado para cada método tratado.\n\n\n\n\n\n\n\n\n\nExercício\n\n\nAs alterações que fizemos tiveram impacto em alguma outra classe do sistema?\nSe não, o que isso sugere sobre os graus de encapsulamento e acoplamento que estavam presentes na versão original do projeto?"
  },
  {
    "objectID": "cap10-1.html#section-41",
    "href": "cap10-1.html#section-41",
    "title": "PPOO - Técnicas de Abstração Adicionais",
    "section": "",
    "text": "Exercício\n\n\nDESAFIO: as implementações dos métodos reproduzir nas classes Coelho e Raposa são muito similares. A diferença é que um cria objetos do tipo Coelho e o outro do tipo Raposa.\nUsando a mesma ideia adotada para tratar o método podeProcriar, seria possível mover o método reproduzir para a superclasse Animal?\nDica: as regras de substituição polimórfica se aplicam também a valores retornados por métodos da mesma forma que é feita para atribuições e passagens de parâmetros."
  },
  {
    "objectID": "cap1-2.html#section-12",
    "href": "cap1-2.html#section-12",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa segunda parte dos exercícios e envie o código do projeto casa da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar)."
  },
  {
    "objectID": "cap1-2.html#section-21",
    "href": "cap1-2.html#section-21",
    "title": "IPOO - Cap. 1 Objetos e Classes",
    "section": "",
    "text": "Entrega no Campus Virtual\n\n\nAcesse, no Campus Virtual, a atividade correspondente a essa segunda parte dos exercícios e envie o código do projeto nave da forma que ficou após as suas alterações (compacte a pasta em um arquivo .zip para enviar);"
  }
]